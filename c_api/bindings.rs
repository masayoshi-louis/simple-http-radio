/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}

impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }

    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];

        let bit_index = index % 8;
        let mask = 1 << bit_index;

        byte & mask == mask
    }

    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];

        let bit_index = index % 8;
        let mask = 1 << bit_index;

        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }

    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        let mut val = 0;

        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                val |= 1 << i;
            }
        }

        val
    }

    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            self.set_bit(i + bit_offset, val_bit_is_set);
        }
    }
}
pub const FLAC_API_VERSION_CURRENT: ::std::os::raw::c_uint = 11;
pub const FLAC_API_VERSION_REVISION: ::std::os::raw::c_uint = 0;
pub const FLAC_API_VERSION_AGE: ::std::os::raw::c_uint = 3;
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __DARWIN_ONLY_64_BIT_INO_T: ::std::os::raw::c_uint = 0;
pub const __DARWIN_ONLY_VERS_1050: ::std::os::raw::c_uint = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 1;
pub const __DARWIN_UNIX03: ::std::os::raw::c_uint = 1;
pub const __DARWIN_64_BIT_INO_T: ::std::os::raw::c_uint = 0;
pub const __DARWIN_VERS_1050: ::std::os::raw::c_uint = 0;
pub const __DARWIN_NON_CANCELABLE: ::std::os::raw::c_uint = 0;
pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: ::std::os::raw::c_uint = 4096;
pub const __DARWIN_C_FULL: ::std::os::raw::c_uint = 900000;
pub const __DARWIN_C_LEVEL: ::std::os::raw::c_uint = 900000;
pub const __STDC_WANT_LIB_EXT1__: ::std::os::raw::c_uint = 1;
pub const __DARWIN_NO_LONG_LONG: ::std::os::raw::c_uint = 0;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 3;
pub const __PTHREAD_SIZE__: ::std::os::raw::c_uint = 8176;
pub const __PTHREAD_ATTR_SIZE__: ::std::os::raw::c_uint = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_MUTEX_SIZE__: ::std::os::raw::c_uint = 56;
pub const __PTHREAD_CONDATTR_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_COND_SIZE__: ::std::os::raw::c_uint = 40;
pub const __PTHREAD_ONCE_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_RWLOCK_SIZE__: ::std::os::raw::c_uint = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: ::std::os::raw::c_uint = 16;
pub const INT8_MAX: ::std::os::raw::c_uint = 127;
pub const INT16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INT8_MIN: ::std::os::raw::c_int = -128;
pub const INT16_MIN: ::std::os::raw::c_int = -32768;
pub const INT32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const UINT8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT64_MAX: ::std::os::raw::c_int = -1;
pub const INT_LEAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_LEAST64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_LEAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_LEAST64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_LEAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT_LEAST64_MAX: ::std::os::raw::c_int = -1;
pub const INT_FAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_FAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_FAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_FAST64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_FAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_FAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_FAST64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_FAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_FAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT_FAST64_MAX: ::std::os::raw::c_int = -1;
pub const INTPTR_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INTPTR_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const UINTPTR_MAX: ::std::os::raw::c_int = -1;
pub const INTMAX_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTMAX_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTMAX_MAX: ::std::os::raw::c_int = -1;
pub const PTRDIFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const SIZE_MAX: ::std::os::raw::c_int = -1;
pub const RSIZE_MAX: ::std::os::raw::c_int = -1;
pub const WINT_MIN: ::std::os::raw::c_int = -2147483648;
pub const WINT_MAX: ::std::os::raw::c_uint = 2147483647;
pub const SIG_ATOMIC_MIN: ::std::os::raw::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: ::std::os::raw::c_uint = 2147483647;
pub const true_: ::std::os::raw::c_uint = 1;
pub const false_: ::std::os::raw::c_uint = 0;
pub const __API_TO_BE_DEPRECATED: ::std::os::raw::c_uint = 100000;
pub const __MAC_10_0: ::std::os::raw::c_uint = 1000;
pub const __MAC_10_1: ::std::os::raw::c_uint = 1010;
pub const __MAC_10_2: ::std::os::raw::c_uint = 1020;
pub const __MAC_10_3: ::std::os::raw::c_uint = 1030;
pub const __MAC_10_4: ::std::os::raw::c_uint = 1040;
pub const __MAC_10_5: ::std::os::raw::c_uint = 1050;
pub const __MAC_10_6: ::std::os::raw::c_uint = 1060;
pub const __MAC_10_7: ::std::os::raw::c_uint = 1070;
pub const __MAC_10_8: ::std::os::raw::c_uint = 1080;
pub const __MAC_10_9: ::std::os::raw::c_uint = 1090;
pub const __MAC_10_10: ::std::os::raw::c_uint = 101000;
pub const __MAC_10_10_2: ::std::os::raw::c_uint = 101002;
pub const __MAC_10_10_3: ::std::os::raw::c_uint = 101003;
pub const __MAC_10_11: ::std::os::raw::c_uint = 101100;
pub const __MAC_10_11_2: ::std::os::raw::c_uint = 101102;
pub const __MAC_10_11_3: ::std::os::raw::c_uint = 101103;
pub const __MAC_10_11_4: ::std::os::raw::c_uint = 101104;
pub const __MAC_10_12: ::std::os::raw::c_uint = 101200;
pub const __MAC_10_12_1: ::std::os::raw::c_uint = 101201;
pub const __MAC_10_12_2: ::std::os::raw::c_uint = 101202;
pub const __MAC_10_12_4: ::std::os::raw::c_uint = 101204;
pub const __MAC_10_13: ::std::os::raw::c_uint = 101300;
pub const __MAC_10_13_1: ::std::os::raw::c_uint = 101301;
pub const __MAC_10_13_2: ::std::os::raw::c_uint = 101302;
pub const __MAC_10_13_4: ::std::os::raw::c_uint = 101304;
pub const __MAC_10_14: ::std::os::raw::c_uint = 101400;
pub const __MAC_10_14_1: ::std::os::raw::c_uint = 101401;
pub const __MAC_10_14_4: ::std::os::raw::c_uint = 101404;
pub const __IPHONE_2_0: ::std::os::raw::c_uint = 20000;
pub const __IPHONE_2_1: ::std::os::raw::c_uint = 20100;
pub const __IPHONE_2_2: ::std::os::raw::c_uint = 20200;
pub const __IPHONE_3_0: ::std::os::raw::c_uint = 30000;
pub const __IPHONE_3_1: ::std::os::raw::c_uint = 30100;
pub const __IPHONE_3_2: ::std::os::raw::c_uint = 30200;
pub const __IPHONE_4_0: ::std::os::raw::c_uint = 40000;
pub const __IPHONE_4_1: ::std::os::raw::c_uint = 40100;
pub const __IPHONE_4_2: ::std::os::raw::c_uint = 40200;
pub const __IPHONE_4_3: ::std::os::raw::c_uint = 40300;
pub const __IPHONE_5_0: ::std::os::raw::c_uint = 50000;
pub const __IPHONE_5_1: ::std::os::raw::c_uint = 50100;
pub const __IPHONE_6_0: ::std::os::raw::c_uint = 60000;
pub const __IPHONE_6_1: ::std::os::raw::c_uint = 60100;
pub const __IPHONE_7_0: ::std::os::raw::c_uint = 70000;
pub const __IPHONE_7_1: ::std::os::raw::c_uint = 70100;
pub const __IPHONE_8_0: ::std::os::raw::c_uint = 80000;
pub const __IPHONE_8_1: ::std::os::raw::c_uint = 80100;
pub const __IPHONE_8_2: ::std::os::raw::c_uint = 80200;
pub const __IPHONE_8_3: ::std::os::raw::c_uint = 80300;
pub const __IPHONE_8_4: ::std::os::raw::c_uint = 80400;
pub const __IPHONE_9_0: ::std::os::raw::c_uint = 90000;
pub const __IPHONE_9_1: ::std::os::raw::c_uint = 90100;
pub const __IPHONE_9_2: ::std::os::raw::c_uint = 90200;
pub const __IPHONE_9_3: ::std::os::raw::c_uint = 90300;
pub const __IPHONE_10_0: ::std::os::raw::c_uint = 100000;
pub const __IPHONE_10_1: ::std::os::raw::c_uint = 100100;
pub const __IPHONE_10_2: ::std::os::raw::c_uint = 100200;
pub const __IPHONE_10_3: ::std::os::raw::c_uint = 100300;
pub const __IPHONE_11_0: ::std::os::raw::c_uint = 110000;
pub const __IPHONE_11_1: ::std::os::raw::c_uint = 110100;
pub const __IPHONE_11_2: ::std::os::raw::c_uint = 110200;
pub const __IPHONE_11_3: ::std::os::raw::c_uint = 110300;
pub const __IPHONE_11_4: ::std::os::raw::c_uint = 110400;
pub const __IPHONE_12_0: ::std::os::raw::c_uint = 120000;
pub const __IPHONE_12_1: ::std::os::raw::c_uint = 120100;
pub const __IPHONE_12_2: ::std::os::raw::c_uint = 120200;
pub const __TVOS_9_0: ::std::os::raw::c_uint = 90000;
pub const __TVOS_9_1: ::std::os::raw::c_uint = 90100;
pub const __TVOS_9_2: ::std::os::raw::c_uint = 90200;
pub const __TVOS_10_0: ::std::os::raw::c_uint = 100000;
pub const __TVOS_10_0_1: ::std::os::raw::c_uint = 100001;
pub const __TVOS_10_1: ::std::os::raw::c_uint = 100100;
pub const __TVOS_10_2: ::std::os::raw::c_uint = 100200;
pub const __TVOS_11_0: ::std::os::raw::c_uint = 110000;
pub const __TVOS_11_1: ::std::os::raw::c_uint = 110100;
pub const __TVOS_11_2: ::std::os::raw::c_uint = 110200;
pub const __TVOS_11_3: ::std::os::raw::c_uint = 110300;
pub const __TVOS_11_4: ::std::os::raw::c_uint = 110400;
pub const __TVOS_12_0: ::std::os::raw::c_uint = 120000;
pub const __TVOS_12_1: ::std::os::raw::c_uint = 120100;
pub const __TVOS_12_2: ::std::os::raw::c_uint = 120200;
pub const __WATCHOS_1_0: ::std::os::raw::c_uint = 10000;
pub const __WATCHOS_2_0: ::std::os::raw::c_uint = 20000;
pub const __WATCHOS_2_1: ::std::os::raw::c_uint = 20100;
pub const __WATCHOS_2_2: ::std::os::raw::c_uint = 20200;
pub const __WATCHOS_3_0: ::std::os::raw::c_uint = 30000;
pub const __WATCHOS_3_1: ::std::os::raw::c_uint = 30100;
pub const __WATCHOS_3_1_1: ::std::os::raw::c_uint = 30101;
pub const __WATCHOS_3_2: ::std::os::raw::c_uint = 30200;
pub const __WATCHOS_4_0: ::std::os::raw::c_uint = 40000;
pub const __WATCHOS_4_1: ::std::os::raw::c_uint = 40100;
pub const __WATCHOS_4_2: ::std::os::raw::c_uint = 40200;
pub const __WATCHOS_4_3: ::std::os::raw::c_uint = 40300;
pub const __WATCHOS_5_0: ::std::os::raw::c_uint = 50000;
pub const __WATCHOS_5_1: ::std::os::raw::c_uint = 50100;
pub const __WATCHOS_5_2: ::std::os::raw::c_uint = 50200;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: ::std::os::raw::c_uint = 101404;
pub const __DARWIN_WCHAR_MIN: ::std::os::raw::c_int = -2147483648;
pub const _FORTIFY_SOURCE: ::std::os::raw::c_uint = 0;
pub const __DARWIN_NSIG: ::std::os::raw::c_uint = 32;
pub const NSIG: ::std::os::raw::c_uint = 32;
pub const _I386_SIGNAL_H_: ::std::os::raw::c_uint = 1;
pub const SIGHUP: ::std::os::raw::c_uint = 1;
pub const SIGINT: ::std::os::raw::c_uint = 2;
pub const SIGQUIT: ::std::os::raw::c_uint = 3;
pub const SIGILL: ::std::os::raw::c_uint = 4;
pub const SIGTRAP: ::std::os::raw::c_uint = 5;
pub const SIGABRT: ::std::os::raw::c_uint = 6;
pub const SIGIOT: ::std::os::raw::c_uint = 6;
pub const SIGEMT: ::std::os::raw::c_uint = 7;
pub const SIGFPE: ::std::os::raw::c_uint = 8;
pub const SIGKILL: ::std::os::raw::c_uint = 9;
pub const SIGBUS: ::std::os::raw::c_uint = 10;
pub const SIGSEGV: ::std::os::raw::c_uint = 11;
pub const SIGSYS: ::std::os::raw::c_uint = 12;
pub const SIGPIPE: ::std::os::raw::c_uint = 13;
pub const SIGALRM: ::std::os::raw::c_uint = 14;
pub const SIGTERM: ::std::os::raw::c_uint = 15;
pub const SIGURG: ::std::os::raw::c_uint = 16;
pub const SIGSTOP: ::std::os::raw::c_uint = 17;
pub const SIGTSTP: ::std::os::raw::c_uint = 18;
pub const SIGCONT: ::std::os::raw::c_uint = 19;
pub const SIGCHLD: ::std::os::raw::c_uint = 20;
pub const SIGTTIN: ::std::os::raw::c_uint = 21;
pub const SIGTTOU: ::std::os::raw::c_uint = 22;
pub const SIGIO: ::std::os::raw::c_uint = 23;
pub const SIGXCPU: ::std::os::raw::c_uint = 24;
pub const SIGXFSZ: ::std::os::raw::c_uint = 25;
pub const SIGVTALRM: ::std::os::raw::c_uint = 26;
pub const SIGPROF: ::std::os::raw::c_uint = 27;
pub const SIGWINCH: ::std::os::raw::c_uint = 28;
pub const SIGINFO: ::std::os::raw::c_uint = 29;
pub const SIGUSR1: ::std::os::raw::c_uint = 30;
pub const SIGUSR2: ::std::os::raw::c_uint = 31;
pub const FP_PREC_24B: ::std::os::raw::c_uint = 0;
pub const FP_PREC_53B: ::std::os::raw::c_uint = 2;
pub const FP_PREC_64B: ::std::os::raw::c_uint = 3;
pub const FP_RND_NEAR: ::std::os::raw::c_uint = 0;
pub const FP_RND_DOWN: ::std::os::raw::c_uint = 1;
pub const FP_RND_UP: ::std::os::raw::c_uint = 2;
pub const FP_CHOP: ::std::os::raw::c_uint = 3;
pub const FP_STATE_BYTES: ::std::os::raw::c_uint = 512;
pub const SIGEV_NONE: ::std::os::raw::c_uint = 0;
pub const SIGEV_SIGNAL: ::std::os::raw::c_uint = 1;
pub const SIGEV_THREAD: ::std::os::raw::c_uint = 3;
pub const ILL_NOOP: ::std::os::raw::c_uint = 0;
pub const ILL_ILLOPC: ::std::os::raw::c_uint = 1;
pub const ILL_ILLTRP: ::std::os::raw::c_uint = 2;
pub const ILL_PRVOPC: ::std::os::raw::c_uint = 3;
pub const ILL_ILLOPN: ::std::os::raw::c_uint = 4;
pub const ILL_ILLADR: ::std::os::raw::c_uint = 5;
pub const ILL_PRVREG: ::std::os::raw::c_uint = 6;
pub const ILL_COPROC: ::std::os::raw::c_uint = 7;
pub const ILL_BADSTK: ::std::os::raw::c_uint = 8;
pub const FPE_NOOP: ::std::os::raw::c_uint = 0;
pub const FPE_FLTDIV: ::std::os::raw::c_uint = 1;
pub const FPE_FLTOVF: ::std::os::raw::c_uint = 2;
pub const FPE_FLTUND: ::std::os::raw::c_uint = 3;
pub const FPE_FLTRES: ::std::os::raw::c_uint = 4;
pub const FPE_FLTINV: ::std::os::raw::c_uint = 5;
pub const FPE_FLTSUB: ::std::os::raw::c_uint = 6;
pub const FPE_INTDIV: ::std::os::raw::c_uint = 7;
pub const FPE_INTOVF: ::std::os::raw::c_uint = 8;
pub const SEGV_NOOP: ::std::os::raw::c_uint = 0;
pub const SEGV_MAPERR: ::std::os::raw::c_uint = 1;
pub const SEGV_ACCERR: ::std::os::raw::c_uint = 2;
pub const BUS_NOOP: ::std::os::raw::c_uint = 0;
pub const BUS_ADRALN: ::std::os::raw::c_uint = 1;
pub const BUS_ADRERR: ::std::os::raw::c_uint = 2;
pub const BUS_OBJERR: ::std::os::raw::c_uint = 3;
pub const TRAP_BRKPT: ::std::os::raw::c_uint = 1;
pub const TRAP_TRACE: ::std::os::raw::c_uint = 2;
pub const CLD_NOOP: ::std::os::raw::c_uint = 0;
pub const CLD_EXITED: ::std::os::raw::c_uint = 1;
pub const CLD_KILLED: ::std::os::raw::c_uint = 2;
pub const CLD_DUMPED: ::std::os::raw::c_uint = 3;
pub const CLD_TRAPPED: ::std::os::raw::c_uint = 4;
pub const CLD_STOPPED: ::std::os::raw::c_uint = 5;
pub const CLD_CONTINUED: ::std::os::raw::c_uint = 6;
pub const POLL_IN: ::std::os::raw::c_uint = 1;
pub const POLL_OUT: ::std::os::raw::c_uint = 2;
pub const POLL_MSG: ::std::os::raw::c_uint = 3;
pub const POLL_ERR: ::std::os::raw::c_uint = 4;
pub const POLL_PRI: ::std::os::raw::c_uint = 5;
pub const POLL_HUP: ::std::os::raw::c_uint = 6;
pub const SA_ONSTACK: ::std::os::raw::c_uint = 1;
pub const SA_RESTART: ::std::os::raw::c_uint = 2;
pub const SA_RESETHAND: ::std::os::raw::c_uint = 4;
pub const SA_NOCLDSTOP: ::std::os::raw::c_uint = 8;
pub const SA_NODEFER: ::std::os::raw::c_uint = 16;
pub const SA_NOCLDWAIT: ::std::os::raw::c_uint = 32;
pub const SA_SIGINFO: ::std::os::raw::c_uint = 64;
pub const SA_USERTRAMP: ::std::os::raw::c_uint = 256;
pub const SA_64REGSET: ::std::os::raw::c_uint = 512;
pub const SA_USERSPACE_MASK: ::std::os::raw::c_uint = 127;
pub const SIG_BLOCK: ::std::os::raw::c_uint = 1;
pub const SIG_UNBLOCK: ::std::os::raw::c_uint = 2;
pub const SIG_SETMASK: ::std::os::raw::c_uint = 3;
pub const SI_USER: ::std::os::raw::c_uint = 65537;
pub const SI_QUEUE: ::std::os::raw::c_uint = 65538;
pub const SI_TIMER: ::std::os::raw::c_uint = 65539;
pub const SI_ASYNCIO: ::std::os::raw::c_uint = 65540;
pub const SI_MESGQ: ::std::os::raw::c_uint = 65541;
pub const SS_ONSTACK: ::std::os::raw::c_uint = 1;
pub const SS_DISABLE: ::std::os::raw::c_uint = 4;
pub const MINSIGSTKSZ: ::std::os::raw::c_uint = 32768;
pub const SIGSTKSZ: ::std::os::raw::c_uint = 131072;
pub const SV_ONSTACK: ::std::os::raw::c_uint = 1;
pub const SV_INTERRUPT: ::std::os::raw::c_uint = 2;
pub const SV_RESETHAND: ::std::os::raw::c_uint = 4;
pub const SV_NODEFER: ::std::os::raw::c_uint = 16;
pub const SV_NOCLDSTOP: ::std::os::raw::c_uint = 8;
pub const SV_SIGINFO: ::std::os::raw::c_uint = 64;
pub const PRIO_PROCESS: ::std::os::raw::c_uint = 0;
pub const PRIO_PGRP: ::std::os::raw::c_uint = 1;
pub const PRIO_USER: ::std::os::raw::c_uint = 2;
pub const PRIO_DARWIN_THREAD: ::std::os::raw::c_uint = 3;
pub const PRIO_DARWIN_PROCESS: ::std::os::raw::c_uint = 4;
pub const PRIO_MIN: ::std::os::raw::c_int = -20;
pub const PRIO_MAX: ::std::os::raw::c_uint = 20;
pub const PRIO_DARWIN_BG: ::std::os::raw::c_uint = 4096;
pub const PRIO_DARWIN_NONUI: ::std::os::raw::c_uint = 4097;
pub const RUSAGE_SELF: ::std::os::raw::c_uint = 0;
pub const RUSAGE_CHILDREN: ::std::os::raw::c_int = -1;
pub const RUSAGE_INFO_V0: ::std::os::raw::c_uint = 0;
pub const RUSAGE_INFO_V1: ::std::os::raw::c_uint = 1;
pub const RUSAGE_INFO_V2: ::std::os::raw::c_uint = 2;
pub const RUSAGE_INFO_V3: ::std::os::raw::c_uint = 3;
pub const RUSAGE_INFO_V4: ::std::os::raw::c_uint = 4;
pub const RUSAGE_INFO_CURRENT: ::std::os::raw::c_uint = 4;
pub const RLIMIT_CPU: ::std::os::raw::c_uint = 0;
pub const RLIMIT_FSIZE: ::std::os::raw::c_uint = 1;
pub const RLIMIT_DATA: ::std::os::raw::c_uint = 2;
pub const RLIMIT_STACK: ::std::os::raw::c_uint = 3;
pub const RLIMIT_CORE: ::std::os::raw::c_uint = 4;
pub const RLIMIT_AS: ::std::os::raw::c_uint = 5;
pub const RLIMIT_RSS: ::std::os::raw::c_uint = 5;
pub const RLIMIT_MEMLOCK: ::std::os::raw::c_uint = 6;
pub const RLIMIT_NPROC: ::std::os::raw::c_uint = 7;
pub const RLIMIT_NOFILE: ::std::os::raw::c_uint = 8;
pub const RLIM_NLIMITS: ::std::os::raw::c_uint = 9;
pub const _RLIMIT_POSIX_FLAG: ::std::os::raw::c_uint = 4096;
pub const RLIMIT_WAKEUPS_MONITOR: ::std::os::raw::c_uint = 1;
pub const RLIMIT_CPU_USAGE_MONITOR: ::std::os::raw::c_uint = 2;
pub const RLIMIT_THREAD_CPULIMITS: ::std::os::raw::c_uint = 3;
pub const RLIMIT_FOOTPRINT_INTERVAL: ::std::os::raw::c_uint = 4;
pub const WAKEMON_ENABLE: ::std::os::raw::c_uint = 1;
pub const WAKEMON_DISABLE: ::std::os::raw::c_uint = 2;
pub const WAKEMON_GET_PARAMS: ::std::os::raw::c_uint = 4;
pub const WAKEMON_SET_DEFAULTS: ::std::os::raw::c_uint = 8;
pub const WAKEMON_MAKE_FATAL: ::std::os::raw::c_uint = 16;
pub const CPUMON_MAKE_FATAL: ::std::os::raw::c_uint = 4096;
pub const FOOTPRINT_INTERVAL_RESET: ::std::os::raw::c_uint = 1;
pub const IOPOL_TYPE_DISK: ::std::os::raw::c_uint = 0;
pub const IOPOL_TYPE_VFS_ATIME_UPDATES: ::std::os::raw::c_uint = 2;
pub const IOPOL_SCOPE_PROCESS: ::std::os::raw::c_uint = 0;
pub const IOPOL_SCOPE_THREAD: ::std::os::raw::c_uint = 1;
pub const IOPOL_SCOPE_DARWIN_BG: ::std::os::raw::c_uint = 2;
pub const IOPOL_DEFAULT: ::std::os::raw::c_uint = 0;
pub const IOPOL_IMPORTANT: ::std::os::raw::c_uint = 1;
pub const IOPOL_PASSIVE: ::std::os::raw::c_uint = 2;
pub const IOPOL_THROTTLE: ::std::os::raw::c_uint = 3;
pub const IOPOL_UTILITY: ::std::os::raw::c_uint = 4;
pub const IOPOL_STANDARD: ::std::os::raw::c_uint = 5;
pub const IOPOL_APPLICATION: ::std::os::raw::c_uint = 5;
pub const IOPOL_NORMAL: ::std::os::raw::c_uint = 1;
pub const IOPOL_ATIME_UPDATES_DEFAULT: ::std::os::raw::c_uint = 0;
pub const IOPOL_ATIME_UPDATES_OFF: ::std::os::raw::c_uint = 1;
pub const WNOHANG: ::std::os::raw::c_uint = 1;
pub const WUNTRACED: ::std::os::raw::c_uint = 2;
pub const WCOREFLAG: ::std::os::raw::c_uint = 128;
pub const _WSTOPPED: ::std::os::raw::c_uint = 127;
pub const WEXITED: ::std::os::raw::c_uint = 4;
pub const WSTOPPED: ::std::os::raw::c_uint = 8;
pub const WCONTINUED: ::std::os::raw::c_uint = 16;
pub const WNOWAIT: ::std::os::raw::c_uint = 32;
pub const WAIT_ANY: ::std::os::raw::c_int = -1;
pub const WAIT_MYPGRP: ::std::os::raw::c_uint = 0;
pub const _QUAD_HIGHWORD: ::std::os::raw::c_uint = 1;
pub const _QUAD_LOWWORD: ::std::os::raw::c_uint = 0;
pub const __DARWIN_LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const __DARWIN_BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const __DARWIN_PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const __DARWIN_BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const EXIT_FAILURE: ::std::os::raw::c_uint = 1;
pub const EXIT_SUCCESS: ::std::os::raw::c_uint = 0;
pub const RAND_MAX: ::std::os::raw::c_uint = 2147483647;
pub const FLAC__MAX_METADATA_TYPE_CODE: ::std::os::raw::c_uint = 126;
pub const FLAC__MIN_BLOCK_SIZE: ::std::os::raw::c_uint = 16;
pub const FLAC__MAX_BLOCK_SIZE: ::std::os::raw::c_uint = 65535;
pub const FLAC__SUBSET_MAX_BLOCK_SIZE_48000HZ: ::std::os::raw::c_uint = 4608;
pub const FLAC__MAX_CHANNELS: ::std::os::raw::c_uint = 8;
pub const FLAC__MIN_BITS_PER_SAMPLE: ::std::os::raw::c_uint = 4;
pub const FLAC__MAX_BITS_PER_SAMPLE: ::std::os::raw::c_uint = 32;
pub const FLAC__REFERENCE_CODEC_MAX_BITS_PER_SAMPLE: ::std::os::raw::c_uint = 24;
pub const FLAC__MAX_SAMPLE_RATE: ::std::os::raw::c_uint = 655350;
pub const FLAC__MAX_LPC_ORDER: ::std::os::raw::c_uint = 32;
pub const FLAC__SUBSET_MAX_LPC_ORDER_48000HZ: ::std::os::raw::c_uint = 12;
pub const FLAC__MIN_QLP_COEFF_PRECISION: ::std::os::raw::c_uint = 5;
pub const FLAC__MAX_QLP_COEFF_PRECISION: ::std::os::raw::c_uint = 15;
pub const FLAC__MAX_FIXED_ORDER: ::std::os::raw::c_uint = 4;
pub const FLAC__MAX_RICE_PARTITION_ORDER: ::std::os::raw::c_uint = 15;
pub const FLAC__SUBSET_MAX_RICE_PARTITION_ORDER: ::std::os::raw::c_uint = 8;
pub const FLAC__STREAM_SYNC_LENGTH: ::std::os::raw::c_uint = 4;
pub const FLAC__STREAM_METADATA_STREAMINFO_LENGTH: ::std::os::raw::c_uint = 34;
pub const FLAC__STREAM_METADATA_SEEKPOINT_LENGTH: ::std::os::raw::c_uint = 18;
pub const FLAC__STREAM_METADATA_HEADER_LENGTH: ::std::os::raw::c_uint = 4;
pub const __DARWIN_FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const __DARWIN_NBBY: ::std::os::raw::c_uint = 8;
pub const NBBY: ::std::os::raw::c_uint = 8;
pub const FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const RENAME_SECLUDE: ::std::os::raw::c_uint = 1;
pub const RENAME_SWAP: ::std::os::raw::c_uint = 2;
pub const RENAME_EXCL: ::std::os::raw::c_uint = 4;
pub const __SLBF: ::std::os::raw::c_uint = 1;
pub const __SNBF: ::std::os::raw::c_uint = 2;
pub const __SRD: ::std::os::raw::c_uint = 4;
pub const __SWR: ::std::os::raw::c_uint = 8;
pub const __SRW: ::std::os::raw::c_uint = 16;
pub const __SEOF: ::std::os::raw::c_uint = 32;
pub const __SERR: ::std::os::raw::c_uint = 64;
pub const __SMBF: ::std::os::raw::c_uint = 128;
pub const __SAPP: ::std::os::raw::c_uint = 256;
pub const __SSTR: ::std::os::raw::c_uint = 512;
pub const __SOPT: ::std::os::raw::c_uint = 1024;
pub const __SNPT: ::std::os::raw::c_uint = 2048;
pub const __SOFF: ::std::os::raw::c_uint = 4096;
pub const __SMOD: ::std::os::raw::c_uint = 8192;
pub const __SALC: ::std::os::raw::c_uint = 16384;
pub const __SIGN: ::std::os::raw::c_uint = 32768;
pub const _IOFBF: ::std::os::raw::c_uint = 0;
pub const _IOLBF: ::std::os::raw::c_uint = 1;
pub const _IONBF: ::std::os::raw::c_uint = 2;
pub const BUFSIZ: ::std::os::raw::c_uint = 1024;
pub const EOF: ::std::os::raw::c_int = -1;
pub const FOPEN_MAX: ::std::os::raw::c_uint = 20;
pub const FILENAME_MAX: ::std::os::raw::c_uint = 1024;
pub const P_tmpdir: &'static [u8; 10usize] = b"/var/tmp/\0";
pub const L_tmpnam: ::std::os::raw::c_uint = 1024;
pub const TMP_MAX: ::std::os::raw::c_uint = 308915776;
pub const SEEK_SET: ::std::os::raw::c_uint = 0;
pub const SEEK_CUR: ::std::os::raw::c_uint = 1;
pub const SEEK_END: ::std::os::raw::c_uint = 2;
pub const L_ctermid: ::std::os::raw::c_uint = 1024;
pub const __CTERMID_DEFINED: ::std::os::raw::c_uint = 1;
extern "C" {
    #[link_name = "\u{1}_FLAC_API_SUPPORTS_OGG_FLAC"]
    pub static mut FLAC_API_SUPPORTS_OGG_FLAC: ::std::os::raw::c_int;
}
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__mbstate8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>()))._mbstateL as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __uint32_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__routine as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__arg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__next as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_t>())).__cleanup_stack as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__opaque as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type FLAC__int8 = i8;
pub type FLAC__uint8 = u8;
pub type FLAC__int16 = i16;
pub type FLAC__int32 = i32;
pub type FLAC__int64 = i64;
pub type FLAC__uint16 = u16;
pub type FLAC__uint32 = u32;
pub type FLAC__uint64 = u64;
pub type FLAC__bool = ::std::os::raw::c_int;
pub type FLAC__byte = FLAC__uint8;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = u32;
pub type pid_t = __darwin_pid_t;
pub type id_t = __darwin_id_t;
pub type sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_i386_thread_state {
    pub __eax: ::std::os::raw::c_uint,
    pub __ebx: ::std::os::raw::c_uint,
    pub __ecx: ::std::os::raw::c_uint,
    pub __edx: ::std::os::raw::c_uint,
    pub __edi: ::std::os::raw::c_uint,
    pub __esi: ::std::os::raw::c_uint,
    pub __ebp: ::std::os::raw::c_uint,
    pub __esp: ::std::os::raw::c_uint,
    pub __ss: ::std::os::raw::c_uint,
    pub __eflags: ::std::os::raw::c_uint,
    pub __eip: ::std::os::raw::c_uint,
    pub __cs: ::std::os::raw::c_uint,
    pub __ds: ::std::os::raw::c_uint,
    pub __es: ::std::os::raw::c_uint,
    pub __fs: ::std::os::raw::c_uint,
    pub __gs: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___darwin_i386_thread_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_i386_thread_state>(),
        64usize,
        concat!("Size of: ", stringify!(__darwin_i386_thread_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_i386_thread_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_i386_thread_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__eax as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__eax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__ebx as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__ebx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__ecx as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__ecx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__edx as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__edx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__edi as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__edi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__esi as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__esi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__ebp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__ebp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__esp as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__esp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__ss as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__eflags as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__eflags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__eip as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__eip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__cs as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__ds as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__ds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__es as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__fs as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__gs as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__gs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_fp_control {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub __bindgen_align: [u16; 0usize],
}
#[test]
fn bindgen_test_layout___darwin_fp_control() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_fp_control>(),
        2usize,
        concat!("Size of: ", stringify!(__darwin_fp_control))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_fp_control>(),
        2usize,
        concat!("Alignment of ", stringify!(__darwin_fp_control))
    );
}
impl __darwin_fp_control {
    #[inline]
    pub fn __invalid(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___invalid(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __denorm(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___denorm(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __zdiv(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___zdiv(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __ovrfl(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___ovrfl(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __undfl(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___undfl(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __precis(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___precis(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __pc(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set___pc(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn __rc(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set___rc(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __invalid: ::std::os::raw::c_ushort,
        __denorm: ::std::os::raw::c_ushort,
        __zdiv: ::std::os::raw::c_ushort,
        __ovrfl: ::std::os::raw::c_ushort,
        __undfl: ::std::os::raw::c_ushort,
        __precis: ::std::os::raw::c_ushort,
        __pc: ::std::os::raw::c_ushort,
        __rc: ::std::os::raw::c_ushort,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let __invalid: u16 = unsafe { ::std::mem::transmute(__invalid) };
            __invalid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let __denorm: u16 = unsafe { ::std::mem::transmute(__denorm) };
            __denorm as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let __zdiv: u16 = unsafe { ::std::mem::transmute(__zdiv) };
            __zdiv as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let __ovrfl: u16 = unsafe { ::std::mem::transmute(__ovrfl) };
            __ovrfl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let __undfl: u16 = unsafe { ::std::mem::transmute(__undfl) };
            __undfl as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let __precis: u16 = unsafe { ::std::mem::transmute(__precis) };
            __precis as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let __pc: u16 = unsafe { ::std::mem::transmute(__pc) };
            __pc as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let __rc: u16 = unsafe { ::std::mem::transmute(__rc) };
            __rc as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type __darwin_fp_control_t = __darwin_fp_control;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_fp_status {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub __bindgen_align: [u16; 0usize],
}
#[test]
fn bindgen_test_layout___darwin_fp_status() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_fp_status>(),
        2usize,
        concat!("Size of: ", stringify!(__darwin_fp_status))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_fp_status>(),
        2usize,
        concat!("Alignment of ", stringify!(__darwin_fp_status))
    );
}
impl __darwin_fp_status {
    #[inline]
    pub fn __invalid(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___invalid(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __denorm(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___denorm(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __zdiv(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___zdiv(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __ovrfl(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___ovrfl(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __undfl(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___undfl(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __precis(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___precis(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __stkflt(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___stkflt(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __errsumm(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___errsumm(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __c0(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___c0(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __c1(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___c1(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __c2(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___c2(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __tos(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set___tos(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn __c3(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___c3(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __busy(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___busy(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __invalid: ::std::os::raw::c_ushort,
        __denorm: ::std::os::raw::c_ushort,
        __zdiv: ::std::os::raw::c_ushort,
        __ovrfl: ::std::os::raw::c_ushort,
        __undfl: ::std::os::raw::c_ushort,
        __precis: ::std::os::raw::c_ushort,
        __stkflt: ::std::os::raw::c_ushort,
        __errsumm: ::std::os::raw::c_ushort,
        __c0: ::std::os::raw::c_ushort,
        __c1: ::std::os::raw::c_ushort,
        __c2: ::std::os::raw::c_ushort,
        __tos: ::std::os::raw::c_ushort,
        __c3: ::std::os::raw::c_ushort,
        __busy: ::std::os::raw::c_ushort,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let __invalid: u16 = unsafe { ::std::mem::transmute(__invalid) };
            __invalid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let __denorm: u16 = unsafe { ::std::mem::transmute(__denorm) };
            __denorm as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let __zdiv: u16 = unsafe { ::std::mem::transmute(__zdiv) };
            __zdiv as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let __ovrfl: u16 = unsafe { ::std::mem::transmute(__ovrfl) };
            __ovrfl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let __undfl: u16 = unsafe { ::std::mem::transmute(__undfl) };
            __undfl as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let __precis: u16 = unsafe { ::std::mem::transmute(__precis) };
            __precis as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let __stkflt: u16 = unsafe { ::std::mem::transmute(__stkflt) };
            __stkflt as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let __errsumm: u16 = unsafe { ::std::mem::transmute(__errsumm) };
            __errsumm as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let __c0: u16 = unsafe { ::std::mem::transmute(__c0) };
            __c0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let __c1: u16 = unsafe { ::std::mem::transmute(__c1) };
            __c1 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let __c2: u16 = unsafe { ::std::mem::transmute(__c2) };
            __c2 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 3u8, {
            let __tos: u16 = unsafe { ::std::mem::transmute(__tos) };
            __tos as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let __c3: u16 = unsafe { ::std::mem::transmute(__c3) };
            __c3 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let __busy: u16 = unsafe { ::std::mem::transmute(__busy) };
            __busy as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type __darwin_fp_status_t = __darwin_fp_status;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mmst_reg {
    pub __mmst_reg: [::std::os::raw::c_char; 10usize],
    pub __mmst_rsrv: [::std::os::raw::c_char; 6usize],
}
#[test]
fn bindgen_test_layout___darwin_mmst_reg() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mmst_reg>(),
        16usize,
        concat!("Size of: ", stringify!(__darwin_mmst_reg))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mmst_reg>(),
        1usize,
        concat!("Alignment of ", stringify!(__darwin_mmst_reg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mmst_reg>())).__mmst_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mmst_reg),
            "::",
            stringify!(__mmst_reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mmst_reg>())).__mmst_rsrv as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mmst_reg),
            "::",
            stringify!(__mmst_rsrv)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_xmm_reg {
    pub __xmm_reg: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout___darwin_xmm_reg() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_xmm_reg>(),
        16usize,
        concat!("Size of: ", stringify!(__darwin_xmm_reg))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_xmm_reg>(),
        1usize,
        concat!("Alignment of ", stringify!(__darwin_xmm_reg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_xmm_reg>())).__xmm_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_xmm_reg),
            "::",
            stringify!(__xmm_reg)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_ymm_reg {
    pub __ymm_reg: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout___darwin_ymm_reg() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_ymm_reg>(),
        32usize,
        concat!("Size of: ", stringify!(__darwin_ymm_reg))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_ymm_reg>(),
        1usize,
        concat!("Alignment of ", stringify!(__darwin_ymm_reg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ymm_reg>())).__ymm_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ymm_reg),
            "::",
            stringify!(__ymm_reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_zmm_reg {
    pub __zmm_reg: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout___darwin_zmm_reg() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_zmm_reg>(),
        64usize,
        concat!("Size of: ", stringify!(__darwin_zmm_reg))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_zmm_reg>(),
        1usize,
        concat!("Alignment of ", stringify!(__darwin_zmm_reg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_zmm_reg>())).__zmm_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_zmm_reg),
            "::",
            stringify!(__zmm_reg)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_opmask_reg {
    pub __opmask_reg: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout___darwin_opmask_reg() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_opmask_reg>(),
        8usize,
        concat!("Size of: ", stringify!(__darwin_opmask_reg))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_opmask_reg>(),
        1usize,
        concat!("Alignment of ", stringify!(__darwin_opmask_reg))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_opmask_reg>())).__opmask_reg as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_opmask_reg),
            "::",
            stringify!(__opmask_reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_i386_float_state {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 224usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_i386_float_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_i386_float_state>(),
        524usize,
        concat!("Size of: ", stringify!(__darwin_i386_float_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_i386_float_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_i386_float_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_reserved as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_fcw as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_fsw as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_ftw as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_rsrv1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_fop as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_ip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_cs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_rsrv2 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_dp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_ds as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_rsrv3 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_mxcsr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_mxcsrmask as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm0 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm1 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm3 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm4 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm5 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm6 as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm7 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm0 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm2 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm3 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm4 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm5 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm6 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm7 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_rsrv4 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_reserved1 as *const _
                as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_i386_avx_state {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 224usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
}
#[test]
fn bindgen_test_layout___darwin_i386_avx_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_i386_avx_state>(),
        716usize,
        concat!("Size of: ", stringify!(__darwin_i386_avx_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_i386_avx_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_i386_avx_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_fcw as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_fsw as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ftw as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_rsrv1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_fop as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_cs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_rsrv2 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_dp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ds as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_rsrv3 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_mxcsr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_mxcsrmask as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm0 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm1 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm3 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm4 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm5 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm6 as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm7 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm0 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm2 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm3 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm4 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm5 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm6 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm7 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_rsrv4 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_reserved1 as *const _ as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__avx_reserved1 as *const _ as usize
        },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__avx_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh0 as *const _ as usize
        },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh1 as *const _ as usize
        },
        604usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh2 as *const _ as usize
        },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh3 as *const _ as usize
        },
        636usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh4 as *const _ as usize
        },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh5 as *const _ as usize
        },
        668usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh6 as *const _ as usize
        },
        684usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh7 as *const _ as usize
        },
        700usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh7)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_i386_avx512_state {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 224usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
    pub __fpu_k0: __darwin_opmask_reg,
    pub __fpu_k1: __darwin_opmask_reg,
    pub __fpu_k2: __darwin_opmask_reg,
    pub __fpu_k3: __darwin_opmask_reg,
    pub __fpu_k4: __darwin_opmask_reg,
    pub __fpu_k5: __darwin_opmask_reg,
    pub __fpu_k6: __darwin_opmask_reg,
    pub __fpu_k7: __darwin_opmask_reg,
    pub __fpu_zmmh0: __darwin_ymm_reg,
    pub __fpu_zmmh1: __darwin_ymm_reg,
    pub __fpu_zmmh2: __darwin_ymm_reg,
    pub __fpu_zmmh3: __darwin_ymm_reg,
    pub __fpu_zmmh4: __darwin_ymm_reg,
    pub __fpu_zmmh5: __darwin_ymm_reg,
    pub __fpu_zmmh6: __darwin_ymm_reg,
    pub __fpu_zmmh7: __darwin_ymm_reg,
}
#[test]
fn bindgen_test_layout___darwin_i386_avx512_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_i386_avx512_state>(),
        1036usize,
        concat!("Size of: ", stringify!(__darwin_i386_avx512_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_i386_avx512_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_i386_avx512_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_reserved as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_fcw as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_fsw as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ftw as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_rsrv1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_fop as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_cs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_rsrv2 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_dp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ds as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_rsrv3 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_mxcsr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_mxcsrmask as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm0 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm1 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm3 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm4 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm5 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm6 as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm7 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm0 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm2 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm3 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm4 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm5 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm6 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm7 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_rsrv4 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_reserved1 as *const _
                as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__avx_reserved1 as *const _
                as usize
        },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__avx_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh0 as *const _ as usize
        },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh1 as *const _ as usize
        },
        604usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh2 as *const _ as usize
        },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh3 as *const _ as usize
        },
        636usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh4 as *const _ as usize
        },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh5 as *const _ as usize
        },
        668usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh6 as *const _ as usize
        },
        684usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh7 as *const _ as usize
        },
        700usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k0 as *const _ as usize
        },
        716usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k1 as *const _ as usize
        },
        724usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k2 as *const _ as usize
        },
        732usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k3 as *const _ as usize
        },
        740usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k4 as *const _ as usize
        },
        748usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k5 as *const _ as usize
        },
        756usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k6 as *const _ as usize
        },
        764usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k7 as *const _ as usize
        },
        772usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh0 as *const _ as usize
        },
        780usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh1 as *const _ as usize
        },
        812usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh2 as *const _ as usize
        },
        844usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh3 as *const _ as usize
        },
        876usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh4 as *const _ as usize
        },
        908usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh5 as *const _ as usize
        },
        940usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh6 as *const _ as usize
        },
        972usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh7 as *const _ as usize
        },
        1004usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh7)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_i386_exception_state {
    pub __trapno: __uint16_t,
    pub __cpu: __uint16_t,
    pub __err: __uint32_t,
    pub __faultvaddr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_i386_exception_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_i386_exception_state>(),
        12usize,
        concat!("Size of: ", stringify!(__darwin_i386_exception_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_i386_exception_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_i386_exception_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_exception_state>())).__trapno as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_exception_state),
            "::",
            stringify!(__trapno)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_exception_state>())).__cpu as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_exception_state),
            "::",
            stringify!(__cpu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_exception_state>())).__err as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_exception_state),
            "::",
            stringify!(__err)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_exception_state>())).__faultvaddr as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_exception_state),
            "::",
            stringify!(__faultvaddr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_x86_debug_state32 {
    pub __dr0: ::std::os::raw::c_uint,
    pub __dr1: ::std::os::raw::c_uint,
    pub __dr2: ::std::os::raw::c_uint,
    pub __dr3: ::std::os::raw::c_uint,
    pub __dr4: ::std::os::raw::c_uint,
    pub __dr5: ::std::os::raw::c_uint,
    pub __dr6: ::std::os::raw::c_uint,
    pub __dr7: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___darwin_x86_debug_state32() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_debug_state32>(),
        32usize,
        concat!("Size of: ", stringify!(__darwin_x86_debug_state32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_debug_state32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_x86_debug_state32))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr0 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr1 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr2 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr3 as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr4 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr5 as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr6 as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr7 as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr7)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_x86_thread_state64 {
    pub __rax: __uint64_t,
    pub __rbx: __uint64_t,
    pub __rcx: __uint64_t,
    pub __rdx: __uint64_t,
    pub __rdi: __uint64_t,
    pub __rsi: __uint64_t,
    pub __rbp: __uint64_t,
    pub __rsp: __uint64_t,
    pub __r8: __uint64_t,
    pub __r9: __uint64_t,
    pub __r10: __uint64_t,
    pub __r11: __uint64_t,
    pub __r12: __uint64_t,
    pub __r13: __uint64_t,
    pub __r14: __uint64_t,
    pub __r15: __uint64_t,
    pub __rip: __uint64_t,
    pub __rflags: __uint64_t,
    pub __cs: __uint64_t,
    pub __fs: __uint64_t,
    pub __gs: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_thread_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_thread_state64>(),
        168usize,
        concat!("Size of: ", stringify!(__darwin_x86_thread_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_thread_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_x86_thread_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rax as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rbx as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rbx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rcx as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rcx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rdx as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rdi as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rdi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rsi as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rsi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rbp as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rbp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rsp as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rsp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r8 as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r9 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r10 as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r11 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r12 as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r13 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r14 as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r15 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rip as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rflags as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rflags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__cs as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__fs as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__fs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__gs as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__gs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_x86_thread_full_state64 {
    pub ss64: __darwin_x86_thread_state64,
    pub __ds: __uint64_t,
    pub __es: __uint64_t,
    pub __ss: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_thread_full_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_thread_full_state64>(),
        192usize,
        concat!("Size of: ", stringify!(__darwin_x86_thread_full_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_thread_full_state64>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__darwin_x86_thread_full_state64)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_full_state64>())).ss64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_full_state64),
            "::",
            stringify!(ss64)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_full_state64>())).__ds as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_full_state64),
            "::",
            stringify!(__ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_full_state64>())).__es as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_full_state64),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_full_state64>())).__ss as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_full_state64),
            "::",
            stringify!(__ss)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_x86_float_state64 {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_xmm8: __darwin_xmm_reg,
    pub __fpu_xmm9: __darwin_xmm_reg,
    pub __fpu_xmm10: __darwin_xmm_reg,
    pub __fpu_xmm11: __darwin_xmm_reg,
    pub __fpu_xmm12: __darwin_xmm_reg,
    pub __fpu_xmm13: __darwin_xmm_reg,
    pub __fpu_xmm14: __darwin_xmm_reg,
    pub __fpu_xmm15: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 96usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_x86_float_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_float_state64>(),
        524usize,
        concat!("Size of: ", stringify!(__darwin_x86_float_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_float_state64>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_x86_float_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_reserved as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_fcw as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_fsw as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_ftw as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_rsrv1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_fop as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_ip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_cs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_rsrv2 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_dp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_ds as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_rsrv3 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_mxcsr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_mxcsrmask as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm0 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm1 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm3 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm4 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm5 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm6 as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm7 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm0 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm2 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm3 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm4 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm5 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm6 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm7 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm8 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm9 as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm10 as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm11 as *const _ as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm12 as *const _ as usize
        },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm13 as *const _ as usize
        },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm14 as *const _ as usize
        },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm15 as *const _ as usize
        },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_rsrv4 as *const _ as usize
        },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_reserved1 as *const _
                as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_x86_avx_state64 {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_xmm8: __darwin_xmm_reg,
    pub __fpu_xmm9: __darwin_xmm_reg,
    pub __fpu_xmm10: __darwin_xmm_reg,
    pub __fpu_xmm11: __darwin_xmm_reg,
    pub __fpu_xmm12: __darwin_xmm_reg,
    pub __fpu_xmm13: __darwin_xmm_reg,
    pub __fpu_xmm14: __darwin_xmm_reg,
    pub __fpu_xmm15: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 96usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
    pub __fpu_ymmh8: __darwin_xmm_reg,
    pub __fpu_ymmh9: __darwin_xmm_reg,
    pub __fpu_ymmh10: __darwin_xmm_reg,
    pub __fpu_ymmh11: __darwin_xmm_reg,
    pub __fpu_ymmh12: __darwin_xmm_reg,
    pub __fpu_ymmh13: __darwin_xmm_reg,
    pub __fpu_ymmh14: __darwin_xmm_reg,
    pub __fpu_ymmh15: __darwin_xmm_reg,
}
#[test]
fn bindgen_test_layout___darwin_x86_avx_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_avx_state64>(),
        844usize,
        concat!("Size of: ", stringify!(__darwin_x86_avx_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_avx_state64>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_x86_avx_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_fcw as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_fsw as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ftw as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_rsrv1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_fop as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_cs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_rsrv2 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_dp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ds as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_rsrv3 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_mxcsr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_mxcsrmask as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm0 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm1 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm3 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm4 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm5 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm6 as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm7 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm0 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm2 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm3 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm4 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm5 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm6 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm7 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm8 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm9 as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm10 as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm11 as *const _ as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm12 as *const _ as usize
        },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm13 as *const _ as usize
        },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm14 as *const _ as usize
        },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm15 as *const _ as usize
        },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_rsrv4 as *const _ as usize
        },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_reserved1 as *const _
                as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__avx_reserved1 as *const _
                as usize
        },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__avx_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh0 as *const _ as usize
        },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh1 as *const _ as usize
        },
        604usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh2 as *const _ as usize
        },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh3 as *const _ as usize
        },
        636usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh4 as *const _ as usize
        },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh5 as *const _ as usize
        },
        668usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh6 as *const _ as usize
        },
        684usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh7 as *const _ as usize
        },
        700usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh8 as *const _ as usize
        },
        716usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh9 as *const _ as usize
        },
        732usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh10 as *const _ as usize
        },
        748usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh11 as *const _ as usize
        },
        764usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh12 as *const _ as usize
        },
        780usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh13 as *const _ as usize
        },
        796usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh14 as *const _ as usize
        },
        812usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh15 as *const _ as usize
        },
        828usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh15)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_x86_avx512_state64 {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_xmm8: __darwin_xmm_reg,
    pub __fpu_xmm9: __darwin_xmm_reg,
    pub __fpu_xmm10: __darwin_xmm_reg,
    pub __fpu_xmm11: __darwin_xmm_reg,
    pub __fpu_xmm12: __darwin_xmm_reg,
    pub __fpu_xmm13: __darwin_xmm_reg,
    pub __fpu_xmm14: __darwin_xmm_reg,
    pub __fpu_xmm15: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 96usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
    pub __fpu_ymmh8: __darwin_xmm_reg,
    pub __fpu_ymmh9: __darwin_xmm_reg,
    pub __fpu_ymmh10: __darwin_xmm_reg,
    pub __fpu_ymmh11: __darwin_xmm_reg,
    pub __fpu_ymmh12: __darwin_xmm_reg,
    pub __fpu_ymmh13: __darwin_xmm_reg,
    pub __fpu_ymmh14: __darwin_xmm_reg,
    pub __fpu_ymmh15: __darwin_xmm_reg,
    pub __fpu_k0: __darwin_opmask_reg,
    pub __fpu_k1: __darwin_opmask_reg,
    pub __fpu_k2: __darwin_opmask_reg,
    pub __fpu_k3: __darwin_opmask_reg,
    pub __fpu_k4: __darwin_opmask_reg,
    pub __fpu_k5: __darwin_opmask_reg,
    pub __fpu_k6: __darwin_opmask_reg,
    pub __fpu_k7: __darwin_opmask_reg,
    pub __fpu_zmmh0: __darwin_ymm_reg,
    pub __fpu_zmmh1: __darwin_ymm_reg,
    pub __fpu_zmmh2: __darwin_ymm_reg,
    pub __fpu_zmmh3: __darwin_ymm_reg,
    pub __fpu_zmmh4: __darwin_ymm_reg,
    pub __fpu_zmmh5: __darwin_ymm_reg,
    pub __fpu_zmmh6: __darwin_ymm_reg,
    pub __fpu_zmmh7: __darwin_ymm_reg,
    pub __fpu_zmmh8: __darwin_ymm_reg,
    pub __fpu_zmmh9: __darwin_ymm_reg,
    pub __fpu_zmmh10: __darwin_ymm_reg,
    pub __fpu_zmmh11: __darwin_ymm_reg,
    pub __fpu_zmmh12: __darwin_ymm_reg,
    pub __fpu_zmmh13: __darwin_ymm_reg,
    pub __fpu_zmmh14: __darwin_ymm_reg,
    pub __fpu_zmmh15: __darwin_ymm_reg,
    pub __fpu_zmm16: __darwin_zmm_reg,
    pub __fpu_zmm17: __darwin_zmm_reg,
    pub __fpu_zmm18: __darwin_zmm_reg,
    pub __fpu_zmm19: __darwin_zmm_reg,
    pub __fpu_zmm20: __darwin_zmm_reg,
    pub __fpu_zmm21: __darwin_zmm_reg,
    pub __fpu_zmm22: __darwin_zmm_reg,
    pub __fpu_zmm23: __darwin_zmm_reg,
    pub __fpu_zmm24: __darwin_zmm_reg,
    pub __fpu_zmm25: __darwin_zmm_reg,
    pub __fpu_zmm26: __darwin_zmm_reg,
    pub __fpu_zmm27: __darwin_zmm_reg,
    pub __fpu_zmm28: __darwin_zmm_reg,
    pub __fpu_zmm29: __darwin_zmm_reg,
    pub __fpu_zmm30: __darwin_zmm_reg,
    pub __fpu_zmm31: __darwin_zmm_reg,
}
#[test]
fn bindgen_test_layout___darwin_x86_avx512_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_avx512_state64>(),
        2444usize,
        concat!("Size of: ", stringify!(__darwin_x86_avx512_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_avx512_state64>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_x86_avx512_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_reserved as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_fcw as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_fsw as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ftw as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_rsrv1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_fop as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_cs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_rsrv2 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_dp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ds as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_rsrv3 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_mxcsr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_mxcsrmask as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm0 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm1 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm3 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm4 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm5 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm6 as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm7 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm0 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm2 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm3 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm4 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm5 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm6 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm7 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm8 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm9 as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm10 as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm11 as *const _ as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm12 as *const _ as usize
        },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm13 as *const _ as usize
        },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm14 as *const _ as usize
        },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm15 as *const _ as usize
        },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_rsrv4 as *const _ as usize
        },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_reserved1 as *const _
                as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__avx_reserved1 as *const _
                as usize
        },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__avx_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh0 as *const _ as usize
        },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh1 as *const _ as usize
        },
        604usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh2 as *const _ as usize
        },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh3 as *const _ as usize
        },
        636usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh4 as *const _ as usize
        },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh5 as *const _ as usize
        },
        668usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh6 as *const _ as usize
        },
        684usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh7 as *const _ as usize
        },
        700usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh8 as *const _ as usize
        },
        716usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh9 as *const _ as usize
        },
        732usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh10 as *const _
                as usize
        },
        748usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh11 as *const _
                as usize
        },
        764usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh12 as *const _
                as usize
        },
        780usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh13 as *const _
                as usize
        },
        796usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh14 as *const _
                as usize
        },
        812usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh15 as *const _
                as usize
        },
        828usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k0 as *const _ as usize
        },
        844usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k1 as *const _ as usize
        },
        852usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k2 as *const _ as usize
        },
        860usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k3 as *const _ as usize
        },
        868usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k4 as *const _ as usize
        },
        876usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k5 as *const _ as usize
        },
        884usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k6 as *const _ as usize
        },
        892usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k7 as *const _ as usize
        },
        900usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh0 as *const _ as usize
        },
        908usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh1 as *const _ as usize
        },
        940usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh2 as *const _ as usize
        },
        972usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh3 as *const _ as usize
        },
        1004usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh4 as *const _ as usize
        },
        1036usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh5 as *const _ as usize
        },
        1068usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh6 as *const _ as usize
        },
        1100usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh7 as *const _ as usize
        },
        1132usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh8 as *const _ as usize
        },
        1164usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh9 as *const _ as usize
        },
        1196usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh10 as *const _
                as usize
        },
        1228usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh11 as *const _
                as usize
        },
        1260usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh12 as *const _
                as usize
        },
        1292usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh13 as *const _
                as usize
        },
        1324usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh14 as *const _
                as usize
        },
        1356usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh15 as *const _
                as usize
        },
        1388usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm16 as *const _ as usize
        },
        1420usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm17 as *const _ as usize
        },
        1484usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm17)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm18 as *const _ as usize
        },
        1548usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm18)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm19 as *const _ as usize
        },
        1612usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm19)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm20 as *const _ as usize
        },
        1676usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm20)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm21 as *const _ as usize
        },
        1740usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm21)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm22 as *const _ as usize
        },
        1804usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm22)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm23 as *const _ as usize
        },
        1868usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm23)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm24 as *const _ as usize
        },
        1932usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm24)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm25 as *const _ as usize
        },
        1996usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm25)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm26 as *const _ as usize
        },
        2060usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm26)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm27 as *const _ as usize
        },
        2124usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm27)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm28 as *const _ as usize
        },
        2188usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm28)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm29 as *const _ as usize
        },
        2252usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm29)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm30 as *const _ as usize
        },
        2316usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm30)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm31 as *const _ as usize
        },
        2380usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm31)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_x86_exception_state64 {
    pub __trapno: __uint16_t,
    pub __cpu: __uint16_t,
    pub __err: __uint32_t,
    pub __faultvaddr: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_exception_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_exception_state64>(),
        16usize,
        concat!("Size of: ", stringify!(__darwin_x86_exception_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_exception_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_x86_exception_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_exception_state64>())).__trapno as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_exception_state64),
            "::",
            stringify!(__trapno)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_exception_state64>())).__cpu as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_exception_state64),
            "::",
            stringify!(__cpu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_exception_state64>())).__err as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_exception_state64),
            "::",
            stringify!(__err)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_exception_state64>())).__faultvaddr as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_exception_state64),
            "::",
            stringify!(__faultvaddr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_x86_debug_state64 {
    pub __dr0: __uint64_t,
    pub __dr1: __uint64_t,
    pub __dr2: __uint64_t,
    pub __dr3: __uint64_t,
    pub __dr4: __uint64_t,
    pub __dr5: __uint64_t,
    pub __dr6: __uint64_t,
    pub __dr7: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_debug_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_debug_state64>(),
        64usize,
        concat!("Size of: ", stringify!(__darwin_x86_debug_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_debug_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_x86_debug_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr0 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr1 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr3 as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr4 as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr5 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr6 as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr7 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr7)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_x86_cpmu_state64 {
    pub __ctrs: [__uint64_t; 16usize],
}
#[test]
fn bindgen_test_layout___darwin_x86_cpmu_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_cpmu_state64>(),
        128usize,
        concat!("Size of: ", stringify!(__darwin_x86_cpmu_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_cpmu_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_x86_cpmu_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_cpmu_state64>())).__ctrs as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_cpmu_state64),
            "::",
            stringify!(__ctrs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext32 {
    pub __es: __darwin_i386_exception_state,
    pub __ss: __darwin_i386_thread_state,
    pub __fs: __darwin_i386_float_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext32() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext32>(),
        600usize,
        concat!("Size of: ", stringify!(__darwin_mcontext32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext32>())).__es as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext32>())).__ss as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext32>())).__fs as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext_avx32 {
    pub __es: __darwin_i386_exception_state,
    pub __ss: __darwin_i386_thread_state,
    pub __fs: __darwin_i386_avx_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx32() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext_avx32>(),
        792usize,
        concat!("Size of: ", stringify!(__darwin_mcontext_avx32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext_avx32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext_avx32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx32>())).__es as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx32),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx32>())).__ss as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx32),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx32>())).__fs as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx32),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext_avx512_32 {
    pub __es: __darwin_i386_exception_state,
    pub __ss: __darwin_i386_thread_state,
    pub __fs: __darwin_i386_avx512_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx512_32() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext_avx512_32>(),
        1112usize,
        concat!("Size of: ", stringify!(__darwin_mcontext_avx512_32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext_avx512_32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext_avx512_32))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_32>())).__es as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_32),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_32>())).__ss as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_32),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_32>())).__fs as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_32),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext64 {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_state64,
    pub __fs: __darwin_x86_float_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext64>(),
        712usize,
        concat!("Size of: ", stringify!(__darwin_mcontext64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext64>())).__es as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext64>())).__ss as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext64>())).__fs as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext_avx64 {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_state64,
    pub __fs: __darwin_x86_avx_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext_avx64>(),
        1032usize,
        concat!("Size of: ", stringify!(__darwin_mcontext_avx64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext_avx64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext_avx64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx64>())).__es as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx64),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx64>())).__ss as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx64),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx64>())).__fs as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx64),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext_avx512_64 {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_state64,
    pub __fs: __darwin_x86_avx512_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx512_64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext_avx512_64>(),
        2632usize,
        concat!("Size of: ", stringify!(__darwin_mcontext_avx512_64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext_avx512_64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext_avx512_64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_64>())).__es as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_64),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_64>())).__ss as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_64),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_64>())).__fs as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_64),
            "::",
            stringify!(__fs)
        )
    );
}
pub type mcontext_t = *mut __darwin_mcontext64;
pub type pthread_attr_t = __darwin_pthread_attr_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_size: __darwin_size_t,
    pub ss_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_sigaltstack() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_sigaltstack>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_sigaltstack))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_sigaltstack>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_sigaltstack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_sigaltstack>())).ss_sp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_sigaltstack>())).ss_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_sigaltstack>())).ss_flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_flags)
        )
    );
}
pub type stack_t = __darwin_sigaltstack;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_ucontext {
    pub uc_onstack: ::std::os::raw::c_int,
    pub uc_sigmask: __darwin_sigset_t,
    pub uc_stack: __darwin_sigaltstack,
    pub uc_link: *mut __darwin_ucontext,
    pub uc_mcsize: __darwin_size_t,
    pub uc_mcontext: *mut __darwin_mcontext64,
}
#[test]
fn bindgen_test_layout___darwin_ucontext() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_ucontext>(),
        56usize,
        concat!("Size of: ", stringify!(__darwin_ucontext))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_ucontext>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_ucontext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_onstack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_onstack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_sigmask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_sigmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_stack as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_link as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_mcsize as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_mcsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_mcontext as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_mcontext)
        )
    );
}
pub type ucontext_t = __darwin_ucontext;
pub type sigset_t = __darwin_sigset_t;
pub type uid_t = __darwin_uid_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sigval() {
    assert_eq!(
        ::std::mem::size_of::<sigval>(),
        8usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::std::mem::align_of::<sigval>(),
        8usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigval>())).sival_int as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_int)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigval>())).sival_ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_ptr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_notify: ::std::os::raw::c_int,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_value: sigval,
    pub sigev_notify_function: ::std::option::Option<unsafe extern "C" fn(arg1: sigval)>,
    pub sigev_notify_attributes: *mut pthread_attr_t,
}
#[test]
fn bindgen_test_layout_sigevent() {
    assert_eq!(
        ::std::mem::size_of::<sigevent>(),
        32usize,
        concat!("Size of: ", stringify!(sigevent))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_notify as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_signo as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_notify_function as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify_function)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigevent>())).sigev_notify_attributes as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify_attributes)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __siginfo {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub si_pid: pid_t,
    pub si_uid: uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_value: sigval,
    pub si_band: ::std::os::raw::c_long,
    pub __pad: [::std::os::raw::c_ulong; 7usize],
}
#[test]
fn bindgen_test_layout___siginfo() {
    assert_eq!(
        ::std::mem::size_of::<__siginfo>(),
        104usize,
        concat!("Size of: ", stringify!(__siginfo))
    );
    assert_eq!(
        ::std::mem::align_of::<__siginfo>(),
        8usize,
        concat!("Alignment of ", stringify!(__siginfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_signo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_errno as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_errno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_code as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_pid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_uid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_status as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_addr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_value as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_band as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_band)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).__pad as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(__pad)
        )
    );
}
pub type siginfo_t = __siginfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sigaction_u {
    pub __sa_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub __sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut __siginfo,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout___sigaction_u() {
    assert_eq!(
        ::std::mem::size_of::<__sigaction_u>(),
        8usize,
        concat!("Size of: ", stringify!(__sigaction_u))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigaction_u>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigaction_u))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction_u>())).__sa_handler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction_u),
            "::",
            stringify!(__sa_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction_u>())).__sa_sigaction as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction_u),
            "::",
            stringify!(__sa_sigaction)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_tramp: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
            arg4: *mut siginfo_t,
            arg5: *mut ::std::os::raw::c_void,
        ),
    >,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sigaction() {
    assert_eq!(
        ::std::mem::size_of::<__sigaction>(),
        24usize,
        concat!("Size of: ", stringify!(__sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigaction))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction>())).__sigaction_u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(__sigaction_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction>())).sa_tramp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_tramp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction>())).sa_mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction>())).sa_flags as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigaction() {
    assert_eq!(
        ::std::mem::size_of::<sigaction>(),
        16usize,
        concat!("Size of: ", stringify!(sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).__sigaction_u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(__sigaction_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
}
pub type sig_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigvec {
    pub sv_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub sv_mask: ::std::os::raw::c_int,
    pub sv_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigvec() {
    assert_eq!(
        ::std::mem::size_of::<sigvec>(),
        16usize,
        concat!("Size of: ", stringify!(sigvec))
    );
    assert_eq!(
        ::std::mem::align_of::<sigvec>(),
        8usize,
        concat!("Alignment of ", stringify!(sigvec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigvec>())).sv_handler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigvec>())).sv_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigvec>())).sv_flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_char,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
    assert_eq!(
        ::std::mem::size_of::<sigstack>(),
        16usize,
        concat!("Size of: ", stringify!(sigstack))
    );
    assert_eq!(
        ::std::mem::align_of::<sigstack>(),
        8usize,
        concat!("Alignment of ", stringify!(sigstack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigstack>())).ss_sp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigstack>())).ss_onstack as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_onstack)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_signal"]
    pub fn signal(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __darwin_time_t,
    pub tv_usec: __darwin_suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type rlim_t = __uint64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub ru_maxrss: ::std::os::raw::c_long,
    pub ru_ixrss: ::std::os::raw::c_long,
    pub ru_idrss: ::std::os::raw::c_long,
    pub ru_isrss: ::std::os::raw::c_long,
    pub ru_minflt: ::std::os::raw::c_long,
    pub ru_majflt: ::std::os::raw::c_long,
    pub ru_nswap: ::std::os::raw::c_long,
    pub ru_inblock: ::std::os::raw::c_long,
    pub ru_oublock: ::std::os::raw::c_long,
    pub ru_msgsnd: ::std::os::raw::c_long,
    pub ru_msgrcv: ::std::os::raw::c_long,
    pub ru_nsignals: ::std::os::raw::c_long,
    pub ru_nvcsw: ::std::os::raw::c_long,
    pub ru_nivcsw: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_rusage() {
    assert_eq!(
        ::std::mem::size_of::<rusage>(),
        144usize,
        concat!("Size of: ", stringify!(rusage))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_utime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_utime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_stime as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_stime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_maxrss as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_maxrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_ixrss as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_ixrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_idrss as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_idrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_isrss as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_isrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_minflt as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_minflt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_majflt as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_majflt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_nswap as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nswap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_inblock as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_inblock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_oublock as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_oublock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_msgsnd as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_msgsnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_msgrcv as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_msgrcv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_nsignals as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nsignals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_nvcsw as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nvcsw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_nivcsw as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nivcsw)
        )
    );
}
pub type rusage_info_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v0 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v0() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v0>(),
        96usize,
        concat!("Size of: ", stringify!(rusage_info_v0))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v0>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v0))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_uuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_user_time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_system_time as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v0>())).ri_pkg_idle_wkups as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v0>())).ri_interrupt_wkups as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_pageins as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_wired_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_resident_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v0>())).ri_phys_footprint as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v0>())).ri_proc_start_abstime as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v0>())).ri_proc_exit_abstime as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v1 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v1() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v1>(),
        144usize,
        concat!("Size of: ", stringify!(rusage_info_v1))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v1>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_uuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_user_time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_system_time as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_pkg_idle_wkups as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_interrupt_wkups as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_pageins as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_wired_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_resident_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_phys_footprint as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_proc_start_abstime as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_proc_exit_abstime as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_user_time as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_system_time as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_pkg_idle_wkups as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_interrupt_wkups as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_pageins as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_elapsed_abstime as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v2 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v2() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v2>(),
        160usize,
        concat!("Size of: ", stringify!(rusage_info_v2))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v2>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_uuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_user_time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_system_time as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_pkg_idle_wkups as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_interrupt_wkups as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_pageins as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_wired_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_resident_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_phys_footprint as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_proc_start_abstime as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_proc_exit_abstime as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_user_time as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_system_time as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_pkg_idle_wkups as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_interrupt_wkups as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_pageins as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_elapsed_abstime as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_diskio_bytesread as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_diskio_byteswritten as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v3 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v3() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v3>(),
        232usize,
        concat!("Size of: ", stringify!(rusage_info_v3))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v3>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_uuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_user_time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_system_time as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_pkg_idle_wkups as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_interrupt_wkups as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_pageins as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_wired_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_resident_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_phys_footprint as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_proc_start_abstime as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_proc_exit_abstime as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_user_time as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_system_time as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_pkg_idle_wkups as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_interrupt_wkups as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_pageins as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_elapsed_abstime as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_diskio_bytesread as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_diskio_byteswritten as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_default as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_maintenance as *const _
                as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_background as *const _
                as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_utility as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_legacy as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_user_initiated as *const _
                as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_user_interactive as *const _
                as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_billed_system_time as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_serviced_system_time as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v4 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_unused: [u64; 1usize],
}
#[test]
fn bindgen_test_layout_rusage_info_v4() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v4>(),
        296usize,
        concat!("Size of: ", stringify!(rusage_info_v4))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v4>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_uuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_user_time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_system_time as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_pkg_idle_wkups as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_interrupt_wkups as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_pageins as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_wired_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_resident_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_phys_footprint as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_proc_start_abstime as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_proc_exit_abstime as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_child_user_time as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_child_system_time as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_child_pkg_idle_wkups as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_child_interrupt_wkups as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_child_pageins as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_child_elapsed_abstime as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_diskio_bytesread as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_diskio_byteswritten as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_default as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_maintenance as *const _
                as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_background as *const _
                as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_utility as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_legacy as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_user_initiated as *const _
                as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_user_interactive as *const _
                as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_billed_system_time as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_serviced_system_time as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_logical_writes as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_logical_writes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_lifetime_max_phys_footprint as *const _
                as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_lifetime_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_instructions as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_instructions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_cycles as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cycles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_billed_energy as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_billed_energy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_serviced_energy as *const _ as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_serviced_energy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_interval_max_phys_footprint as *const _
                as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_interval_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_unused as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_unused)
        )
    );
}
pub type rusage_info_current = rusage_info_v4;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[test]
fn bindgen_test_layout_rlimit() {
    assert_eq!(
        ::std::mem::size_of::<rlimit>(),
        16usize,
        concat!("Size of: ", stringify!(rlimit))
    );
    assert_eq!(
        ::std::mem::align_of::<rlimit>(),
        8usize,
        concat!("Alignment of ", stringify!(rlimit))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rlimit>())).rlim_cur as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit),
            "::",
            stringify!(rlim_cur)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rlimit>())).rlim_max as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit),
            "::",
            stringify!(rlim_max)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proc_rlimit_control_wakeupmon {
    pub wm_flags: u32,
    pub wm_rate: i32,
}
#[test]
fn bindgen_test_layout_proc_rlimit_control_wakeupmon() {
    assert_eq!(
        ::std::mem::size_of::<proc_rlimit_control_wakeupmon>(),
        8usize,
        concat!("Size of: ", stringify!(proc_rlimit_control_wakeupmon))
    );
    assert_eq!(
        ::std::mem::align_of::<proc_rlimit_control_wakeupmon>(),
        4usize,
        concat!("Alignment of ", stringify!(proc_rlimit_control_wakeupmon))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<proc_rlimit_control_wakeupmon>())).wm_flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(proc_rlimit_control_wakeupmon),
            "::",
            stringify!(wm_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<proc_rlimit_control_wakeupmon>())).wm_rate as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(proc_rlimit_control_wakeupmon),
            "::",
            stringify!(wm_rate)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_getpriority"]
    pub fn getpriority(arg1: ::std::os::raw::c_int, arg2: id_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getiopolicy_np"]
    pub fn getiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getrlimit"]
    pub fn getrlimit(arg1: ::std::os::raw::c_int, arg2: *mut rlimit) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getrusage"]
    pub fn getrusage(arg1: ::std::os::raw::c_int, arg2: *mut rusage) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_setpriority"]
    pub fn setpriority(
        arg1: ::std::os::raw::c_int,
        arg2: id_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_setiopolicy_np"]
    pub fn setiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_setrlimit"]
    pub fn setrlimit(arg1: ::std::os::raw::c_int, arg2: *const rlimit) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wait {
    pub w_status: ::std::os::raw::c_int,
    pub w_T: wait__bindgen_ty_1,
    pub w_S: wait__bindgen_ty_2,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_1))
    );
}
impl wait__bindgen_ty_1 {
    #[inline]
    pub fn w_Termsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_w_Termsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Coredump(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_w_Coredump(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Retcode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Retcode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Termsig: ::std::os::raw::c_uint,
        w_Coredump: ::std::os::raw::c_uint,
        w_Retcode: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let w_Termsig: u32 = unsafe { ::std::mem::transmute(w_Termsig) };
            w_Termsig as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let w_Coredump: u32 = unsafe { ::std::mem::transmute(w_Coredump) };
            w_Coredump as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Retcode: u32 = unsafe { ::std::mem::transmute(w_Retcode) };
            w_Retcode as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_2))
    );
}
impl wait__bindgen_ty_2 {
    #[inline]
    pub fn w_Stopval(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopval(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Stopsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Stopval: ::std::os::raw::c_uint,
        w_Stopsig: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let w_Stopval: u32 = unsafe { ::std::mem::transmute(w_Stopval) };
            w_Stopval as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Stopsig: u32 = unsafe { ::std::mem::transmute(w_Stopsig) };
            w_Stopsig as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_wait() {
    assert_eq!(
        ::std::mem::size_of::<wait>(),
        4usize,
        concat!("Size of: ", stringify!(wait))
    );
    assert_eq!(
        ::std::mem::align_of::<wait>(),
        4usize,
        concat!("Alignment of ", stringify!(wait))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait>())).w_status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wait),
            "::",
            stringify!(w_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait>())).w_T as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(wait), "::", stringify!(w_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait>())).w_S as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(wait), "::", stringify!(w_S))
    );
}
extern "C" {
    #[link_name = "\u{1}_wait"]
    pub fn wait(arg1: *mut ::std::os::raw::c_int) -> pid_t;
}
extern "C" {
    #[link_name = "\u{1}_waitpid"]
    pub fn waitpid(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> pid_t;
}
extern "C" {
    #[link_name = "\u{1}_waitid"]
    pub fn waitid(
        arg1: idtype_t,
        arg2: id_t,
        arg3: *mut siginfo_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_wait3"]
    pub fn wait3(
        arg1: *mut ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: *mut rusage,
    ) -> pid_t;
}
extern "C" {
    #[link_name = "\u{1}_wait4"]
    pub fn wait4(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut rusage,
    ) -> pid_t;
}
extern "C" {
    #[link_name = "\u{1}_alloca"]
    pub fn alloca(arg1: usize) -> *mut ::std::os::raw::c_void;
}
pub type ct_rune_t = __darwin_ct_rune_t;
pub type rune_t = __darwin_rune_t;
pub type wchar_t = __darwin_wchar_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}___mb_cur_max"]
    pub static mut __mb_cur_max: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_malloc"]
    pub fn malloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_calloc"]
    pub fn calloc(__count: usize, __size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_free"]
    pub fn free(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_realloc"]
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_valloc"]
    pub fn valloc(arg1: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_posix_memalign"]
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_abort"]
    pub fn abort();
}
extern "C" {
    #[link_name = "\u{1}_abs"]
    pub fn abs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_atexit"]
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_atof"]
    pub fn atof(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_atoi"]
    pub fn atoi(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_atol"]
    pub fn atol(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_atoll"]
    pub fn atoll(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[link_name = "\u{1}_bsearch"]
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_div"]
    pub fn div(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    #[link_name = "\u{1}_exit"]
    pub fn exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_getenv"]
    pub fn getenv(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_labs"]
    pub fn labs(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_ldiv"]
    pub fn ldiv(arg1: ::std::os::raw::c_long, arg2: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    #[link_name = "\u{1}_llabs"]
    pub fn llabs(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[link_name = "\u{1}_lldiv"]
    pub fn lldiv(arg1: ::std::os::raw::c_longlong, arg2: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    #[link_name = "\u{1}_mblen"]
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_mbstowcs"]
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const ::std::os::raw::c_char, arg3: usize) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_mbtowc"]
    pub fn mbtowc(
        arg1: *mut wchar_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_qsort"]
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    #[link_name = "\u{1}_rand"]
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_srand"]
    pub fn srand(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    #[link_name = "\u{1}_strtod"]
    pub fn strtod(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_strtof"]
    pub fn strtof(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_strtol"]
    pub fn strtol(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_strtold"]
    pub fn strtold(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_strtoll"]
    pub fn strtoll(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[link_name = "\u{1}_strtoul"]
    pub fn strtoul(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}_strtoull"]
    pub fn strtoull(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    #[link_name = "\u{1}_system"]
    pub fn system(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_wcstombs"]
    pub fn wcstombs(arg1: *mut ::std::os::raw::c_char, arg2: *const wchar_t, arg3: usize) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_wctomb"]
    pub fn wctomb(arg1: *mut ::std::os::raw::c_char, arg2: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__Exit"]
    pub fn _Exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_a64l"]
    pub fn a64l(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_drand48"]
    pub fn drand48() -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ecvt"]
    pub fn ecvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_erand48"]
    pub fn erand48(arg1: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_fcvt"]
    pub fn fcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_gcvt"]
    pub fn gcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_getsubopt"]
    pub fn getsubopt(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_grantpt"]
    pub fn grantpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_initstate"]
    pub fn initstate(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_jrand48"]
    pub fn jrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_l64a"]
    pub fn l64a(arg1: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_lcong48"]
    pub fn lcong48(arg1: *mut ::std::os::raw::c_ushort);
}
extern "C" {
    #[link_name = "\u{1}_lrand48"]
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_mktemp"]
    pub fn mktemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_mkstemp"]
    pub fn mkstemp(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_mrand48"]
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_nrand48"]
    pub fn nrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_posix_openpt"]
    pub fn posix_openpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ptsname"]
    pub fn ptsname(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ptsname_r"]
    pub fn ptsname_r(
        fildes: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_putenv"]
    pub fn putenv(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_random"]
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_rand_r"]
    pub fn rand_r(arg1: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_realpath$DARWIN_EXTSN"]
    pub fn realpath(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_seed48"]
    pub fn seed48(arg1: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    #[link_name = "\u{1}_setenv"]
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __overwrite: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_setkey"]
    pub fn setkey(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_setstate"]
    pub fn setstate(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_srand48"]
    pub fn srand48(arg1: ::std::os::raw::c_long);
}
extern "C" {
    #[link_name = "\u{1}_srandom"]
    pub fn srandom(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    #[link_name = "\u{1}_unlockpt"]
    pub fn unlockpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_unsetenv"]
    pub fn unsetenv(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
pub type dev_t = __darwin_dev_t;
pub type mode_t = __darwin_mode_t;
extern "C" {
    #[link_name = "\u{1}_arc4random"]
    pub fn arc4random() -> u32;
}
extern "C" {
    #[link_name = "\u{1}_arc4random_addrandom"]
    pub fn arc4random_addrandom(arg1: *mut ::std::os::raw::c_uchar, arg2: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_arc4random_buf"]
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __nbytes: usize);
}
extern "C" {
    #[link_name = "\u{1}_arc4random_stir"]
    pub fn arc4random_stir();
}
extern "C" {
    #[link_name = "\u{1}_arc4random_uniform"]
    pub fn arc4random_uniform(__upper_bound: u32) -> u32;
}
extern "C" {
    #[link_name = "\u{1}_atexit_b"]
    pub fn atexit_b(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_bsearch_b"]
    pub fn bsearch_b(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_cgetcap"]
    pub fn cgetcap(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_cgetclose"]
    pub fn cgetclose() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_cgetent"]
    pub fn cgetent(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_cgetfirst"]
    pub fn cgetfirst(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_cgetmatch"]
    pub fn cgetmatch(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_cgetnext"]
    pub fn cgetnext(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_cgetnum"]
    pub fn cgetnum(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_cgetset"]
    pub fn cgetset(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_cgetstr"]
    pub fn cgetstr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_cgetustr"]
    pub fn cgetustr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_daemon"]
    pub fn daemon(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_devname"]
    pub fn devname(arg1: dev_t, arg2: mode_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_devname_r"]
    pub fn devname_r(
        arg1: dev_t,
        arg2: mode_t,
        buf: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_getbsize"]
    pub fn getbsize(
        arg1: *mut ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_getloadavg"]
    pub fn getloadavg(arg1: *mut f64, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getprogname"]
    pub fn getprogname() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_heapsort"]
    pub fn heapsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_heapsort_b"]
    pub fn heapsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_mergesort"]
    pub fn mergesort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_mergesort_b"]
    pub fn mergesort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_psort"]
    pub fn psort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    #[link_name = "\u{1}_psort_b"]
    pub fn psort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_psort_r"]
    pub fn psort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    #[link_name = "\u{1}_qsort_b"]
    pub fn qsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_qsort_r"]
    pub fn qsort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    #[link_name = "\u{1}_radixsort"]
    pub fn radixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_setprogname"]
    pub fn setprogname(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_sradixsort"]
    pub fn sradixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sranddev"]
    pub fn sranddev();
}
extern "C" {
    #[link_name = "\u{1}_srandomdev"]
    pub fn srandomdev();
}
extern "C" {
    #[link_name = "\u{1}_reallocf"]
    pub fn reallocf(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_strtoq"]
    pub fn strtoq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[link_name = "\u{1}_strtouq"]
    pub fn strtouq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    #[link_name = "\u{1}_suboptarg"]
    pub static mut suboptarg: *mut ::std::os::raw::c_char;
}
/// This is the opaque handle type used by the callbacks.  Typically
/// this is a \c FILE* or address of a file descriptor.
pub type FLAC__IOHandle = *mut ::std::os::raw::c_void;
/// Signature for the read callback.
/// The signature and semantics match POSIX fread() implementations
/// and can generally be used interchangeably.
///
/// \param  ptr      The address of the read buffer.
/// \param  size     The size of the records to be read.
/// \param  nmemb    The number of records to be read.
/// \param  handle   The handle to the data source.
/// \retval size_t
/// The number of records read.
pub type FLAC__IOCallback_Read = ::std::option::Option<
    unsafe extern "C" fn(
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        nmemb: usize,
        handle: FLAC__IOHandle,
    ) -> usize,
>;
/// Signature for the write callback.
/// The signature and semantics match POSIX fwrite() implementations
/// and can generally be used interchangeably.
///
/// \param  ptr      The address of the write buffer.
/// \param  size     The size of the records to be written.
/// \param  nmemb    The number of records to be written.
/// \param  handle   The handle to the data source.
/// \retval size_t
/// The number of records written.
pub type FLAC__IOCallback_Write = ::std::option::Option<
    unsafe extern "C" fn(
        ptr: *const ::std::os::raw::c_void,
        size: usize,
        nmemb: usize,
        handle: FLAC__IOHandle,
    ) -> usize,
>;
/// Signature for the seek callback.
/// The signature and semantics mostly match POSIX fseek() WITH ONE IMPORTANT
/// EXCEPTION: the offset is a 64-bit type whereas fseek() is generally 'long'
/// and 32-bits wide.
///
/// \param  handle   The handle to the data source.
/// \param  offset   The new position, relative to \a whence
/// \param  whence   \c SEEK_SET, \c SEEK_CUR, or \c SEEK_END
/// \retval int
/// \c 0 on success, \c -1 on error.
pub type FLAC__IOCallback_Seek = ::std::option::Option<
    unsafe extern "C" fn(
        handle: FLAC__IOHandle,
        offset: FLAC__int64,
        whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
/// Signature for the tell callback.
/// The signature and semantics mostly match POSIX ftell() WITH ONE IMPORTANT
/// EXCEPTION: the offset is a 64-bit type whereas ftell() is generally 'long'
/// and 32-bits wide.
///
/// \param  handle   The handle to the data source.
/// \retval FLAC__int64
/// The current position on success, \c -1 on error.
pub type FLAC__IOCallback_Tell =
    ::std::option::Option<unsafe extern "C" fn(handle: FLAC__IOHandle) -> FLAC__int64>;
/// Signature for the EOF callback.
/// The signature and semantics mostly match POSIX feof() but WATCHOUT:
/// on many systems, feof() is a macro, so in this case a wrapper function
/// must be provided instead.
///
/// \param  handle   The handle to the data source.
/// \retval int
/// \c 0 if not at end of file, nonzero if at end of file.
pub type FLAC__IOCallback_Eof =
    ::std::option::Option<unsafe extern "C" fn(handle: FLAC__IOHandle) -> ::std::os::raw::c_int>;
/// Signature for the close callback.
/// The signature and semantics match POSIX fclose() implementations
/// and can generally be used interchangeably.
///
/// \param  handle   The handle to the data source.
/// \retval int
/// \c 0 on success, \c EOF on error.
pub type FLAC__IOCallback_Close =
    ::std::option::Option<unsafe extern "C" fn(handle: FLAC__IOHandle) -> ::std::os::raw::c_int>;
/// A structure for holding a set of callbacks.
/// Each FLAC interface that requires a FLAC__IOCallbacks structure will
/// describe which of the callbacks are required.  The ones that are not
/// required may be set to NULL.
///
/// If the seek requirement for an interface is optional, you can signify that
/// a data sorce is not seekable by setting the \a seek field to \c NULL.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__IOCallbacks {
    pub read: FLAC__IOCallback_Read,
    pub write: FLAC__IOCallback_Write,
    pub seek: FLAC__IOCallback_Seek,
    pub tell: FLAC__IOCallback_Tell,
    pub eof: FLAC__IOCallback_Eof,
    pub close: FLAC__IOCallback_Close,
}
#[test]
fn bindgen_test_layout_FLAC__IOCallbacks() {
    assert_eq!(
        ::std::mem::size_of::<FLAC__IOCallbacks>(),
        48usize,
        concat!("Size of: ", stringify!(FLAC__IOCallbacks))
    );
    assert_eq!(
        ::std::mem::align_of::<FLAC__IOCallbacks>(),
        8usize,
        concat!("Alignment of ", stringify!(FLAC__IOCallbacks))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FLAC__IOCallbacks>())).read as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__IOCallbacks),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FLAC__IOCallbacks>())).write as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__IOCallbacks),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FLAC__IOCallbacks>())).seek as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__IOCallbacks),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FLAC__IOCallbacks>())).tell as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__IOCallbacks),
            "::",
            stringify!(tell)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FLAC__IOCallbacks>())).eof as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__IOCallbacks),
            "::",
            stringify!(eof)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FLAC__IOCallbacks>())).close as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__IOCallbacks),
            "::",
            stringify!(close)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_FLAC__VERSION_STRING"]
    pub static mut FLAC__VERSION_STRING: *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__VENDOR_STRING"]
    pub static mut FLAC__VENDOR_STRING: *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__STREAM_SYNC_STRING"]
    pub static mut FLAC__STREAM_SYNC_STRING: [FLAC__byte; 4usize];
}
extern "C" {
    #[link_name = "\u{1}_FLAC__STREAM_SYNC"]
    pub static mut FLAC__STREAM_SYNC: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__STREAM_SYNC_LEN"]
    pub static mut FLAC__STREAM_SYNC_LEN: ::std::os::raw::c_uint;
}
pub const FLAC__EntropyCodingMethodType_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE:
    FLAC__EntropyCodingMethodType = 0;
pub const FLAC__EntropyCodingMethodType_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2:
    FLAC__EntropyCodingMethodType = 1;
pub type FLAC__EntropyCodingMethodType = u32;
extern "C" {
    #[link_name = "\u{1}_FLAC__EntropyCodingMethodTypeString"]
    pub static mut FLAC__EntropyCodingMethodTypeString: [*const ::std::os::raw::c_char; 0usize];
}
/// Contents of a Rice partitioned residual
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__EntropyCodingMethod_PartitionedRiceContents {
    pub parameters: *mut ::std::os::raw::c_uint,
    pub raw_bits: *mut ::std::os::raw::c_uint,
    pub capacity_by_order: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_FLAC__EntropyCodingMethod_PartitionedRiceContents() {
    assert_eq!(
        ::std::mem::size_of::<FLAC__EntropyCodingMethod_PartitionedRiceContents>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(FLAC__EntropyCodingMethod_PartitionedRiceContents)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FLAC__EntropyCodingMethod_PartitionedRiceContents>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(FLAC__EntropyCodingMethod_PartitionedRiceContents)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__EntropyCodingMethod_PartitionedRiceContents>())).parameters
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__EntropyCodingMethod_PartitionedRiceContents),
            "::",
            stringify!(parameters)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__EntropyCodingMethod_PartitionedRiceContents>())).raw_bits
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__EntropyCodingMethod_PartitionedRiceContents),
            "::",
            stringify!(raw_bits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__EntropyCodingMethod_PartitionedRiceContents>()))
                .capacity_by_order as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__EntropyCodingMethod_PartitionedRiceContents),
            "::",
            stringify!(capacity_by_order)
        )
    );
}
/// Header for a Rice partitioned residual.  (c.f. <A HREF="../format.html#partitioned_rice">format specification</A>)
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__EntropyCodingMethod_PartitionedRice {
    pub order: ::std::os::raw::c_uint,
    pub contents: *const FLAC__EntropyCodingMethod_PartitionedRiceContents,
}
#[test]
fn bindgen_test_layout_FLAC__EntropyCodingMethod_PartitionedRice() {
    assert_eq!(
        ::std::mem::size_of::<FLAC__EntropyCodingMethod_PartitionedRice>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(FLAC__EntropyCodingMethod_PartitionedRice)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FLAC__EntropyCodingMethod_PartitionedRice>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(FLAC__EntropyCodingMethod_PartitionedRice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__EntropyCodingMethod_PartitionedRice>())).order as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__EntropyCodingMethod_PartitionedRice),
            "::",
            stringify!(order)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__EntropyCodingMethod_PartitionedRice>())).contents
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__EntropyCodingMethod_PartitionedRice),
            "::",
            stringify!(contents)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ORDER_LEN"]
    pub static mut FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ORDER_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_PARAMETER_LEN"]
    pub static mut FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_PARAMETER_LEN:
        ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_PARAMETER_LEN"]
    pub static mut FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_PARAMETER_LEN:
        ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_RAW_LEN"]
    pub static mut FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_RAW_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ESCAPE_PARAMETER"]
    pub static mut FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ESCAPE_PARAMETER:
        ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_ESCAPE_PARAMETER"]
    pub static mut FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_ESCAPE_PARAMETER:
        ::std::os::raw::c_uint;
}
/// Header for the entropy coding method.  (c.f. <A HREF="../format.html#residual">format specification</A>)
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FLAC__EntropyCodingMethod {
    pub type_: FLAC__EntropyCodingMethodType,
    pub data: FLAC__EntropyCodingMethod__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FLAC__EntropyCodingMethod__bindgen_ty_1 {
    pub partitioned_rice: FLAC__EntropyCodingMethod_PartitionedRice,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_FLAC__EntropyCodingMethod__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<FLAC__EntropyCodingMethod__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(FLAC__EntropyCodingMethod__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FLAC__EntropyCodingMethod__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(FLAC__EntropyCodingMethod__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__EntropyCodingMethod__bindgen_ty_1>())).partitioned_rice
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__EntropyCodingMethod__bindgen_ty_1),
            "::",
            stringify!(partitioned_rice)
        )
    );
}
#[test]
fn bindgen_test_layout_FLAC__EntropyCodingMethod() {
    assert_eq!(
        ::std::mem::size_of::<FLAC__EntropyCodingMethod>(),
        24usize,
        concat!("Size of: ", stringify!(FLAC__EntropyCodingMethod))
    );
    assert_eq!(
        ::std::mem::align_of::<FLAC__EntropyCodingMethod>(),
        8usize,
        concat!("Alignment of ", stringify!(FLAC__EntropyCodingMethod))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FLAC__EntropyCodingMethod>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__EntropyCodingMethod),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FLAC__EntropyCodingMethod>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__EntropyCodingMethod),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_FLAC__ENTROPY_CODING_METHOD_TYPE_LEN"]
    pub static mut FLAC__ENTROPY_CODING_METHOD_TYPE_LEN: ::std::os::raw::c_uint;
}
pub const FLAC__SubframeType_FLAC__SUBFRAME_TYPE_CONSTANT: FLAC__SubframeType = 0;
pub const FLAC__SubframeType_FLAC__SUBFRAME_TYPE_VERBATIM: FLAC__SubframeType = 1;
pub const FLAC__SubframeType_FLAC__SUBFRAME_TYPE_FIXED: FLAC__SubframeType = 2;
pub const FLAC__SubframeType_FLAC__SUBFRAME_TYPE_LPC: FLAC__SubframeType = 3;
pub type FLAC__SubframeType = u32;
extern "C" {
    #[link_name = "\u{1}_FLAC__SubframeTypeString"]
    pub static mut FLAC__SubframeTypeString: [*const ::std::os::raw::c_char; 0usize];
}
/// CONSTANT subframe.  (c.f. <A HREF="../format.html#subframe_constant">format specification</A>)
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__Subframe_Constant {
    /// < The constant signal value.
    pub value: FLAC__int32,
}
#[test]
fn bindgen_test_layout_FLAC__Subframe_Constant() {
    assert_eq!(
        ::std::mem::size_of::<FLAC__Subframe_Constant>(),
        4usize,
        concat!("Size of: ", stringify!(FLAC__Subframe_Constant))
    );
    assert_eq!(
        ::std::mem::align_of::<FLAC__Subframe_Constant>(),
        4usize,
        concat!("Alignment of ", stringify!(FLAC__Subframe_Constant))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FLAC__Subframe_Constant>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__Subframe_Constant),
            "::",
            stringify!(value)
        )
    );
}
/// VERBATIM subframe.  (c.f. <A HREF="../format.html#subframe_verbatim">format specification</A>)
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__Subframe_Verbatim {
    /// < A pointer to verbatim signal.
    pub data: *const FLAC__int32,
}
#[test]
fn bindgen_test_layout_FLAC__Subframe_Verbatim() {
    assert_eq!(
        ::std::mem::size_of::<FLAC__Subframe_Verbatim>(),
        8usize,
        concat!("Size of: ", stringify!(FLAC__Subframe_Verbatim))
    );
    assert_eq!(
        ::std::mem::align_of::<FLAC__Subframe_Verbatim>(),
        8usize,
        concat!("Alignment of ", stringify!(FLAC__Subframe_Verbatim))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FLAC__Subframe_Verbatim>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__Subframe_Verbatim),
            "::",
            stringify!(data)
        )
    );
}
/// FIXED subframe.  (c.f. <A HREF="../format.html#subframe_fixed">format specification</A>)
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FLAC__Subframe_Fixed {
    pub entropy_coding_method: FLAC__EntropyCodingMethod,
    pub order: ::std::os::raw::c_uint,
    pub warmup: [FLAC__int32; 4usize],
    pub residual: *const FLAC__int32,
}
#[test]
fn bindgen_test_layout_FLAC__Subframe_Fixed() {
    assert_eq!(
        ::std::mem::size_of::<FLAC__Subframe_Fixed>(),
        56usize,
        concat!("Size of: ", stringify!(FLAC__Subframe_Fixed))
    );
    assert_eq!(
        ::std::mem::align_of::<FLAC__Subframe_Fixed>(),
        8usize,
        concat!("Alignment of ", stringify!(FLAC__Subframe_Fixed))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__Subframe_Fixed>())).entropy_coding_method as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__Subframe_Fixed),
            "::",
            stringify!(entropy_coding_method)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FLAC__Subframe_Fixed>())).order as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__Subframe_Fixed),
            "::",
            stringify!(order)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FLAC__Subframe_Fixed>())).warmup as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__Subframe_Fixed),
            "::",
            stringify!(warmup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FLAC__Subframe_Fixed>())).residual as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__Subframe_Fixed),
            "::",
            stringify!(residual)
        )
    );
}
/// LPC subframe.  (c.f. <A HREF="../format.html#subframe_lpc">format specification</A>)
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FLAC__Subframe_LPC {
    pub entropy_coding_method: FLAC__EntropyCodingMethod,
    pub order: ::std::os::raw::c_uint,
    pub qlp_coeff_precision: ::std::os::raw::c_uint,
    pub quantization_level: ::std::os::raw::c_int,
    pub qlp_coeff: [FLAC__int32; 32usize],
    pub warmup: [FLAC__int32; 32usize],
    pub residual: *const FLAC__int32,
}
#[test]
fn bindgen_test_layout_FLAC__Subframe_LPC() {
    assert_eq!(
        ::std::mem::size_of::<FLAC__Subframe_LPC>(),
        304usize,
        concat!("Size of: ", stringify!(FLAC__Subframe_LPC))
    );
    assert_eq!(
        ::std::mem::align_of::<FLAC__Subframe_LPC>(),
        8usize,
        concat!("Alignment of ", stringify!(FLAC__Subframe_LPC))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__Subframe_LPC>())).entropy_coding_method as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__Subframe_LPC),
            "::",
            stringify!(entropy_coding_method)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FLAC__Subframe_LPC>())).order as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__Subframe_LPC),
            "::",
            stringify!(order)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__Subframe_LPC>())).qlp_coeff_precision as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__Subframe_LPC),
            "::",
            stringify!(qlp_coeff_precision)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__Subframe_LPC>())).quantization_level as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__Subframe_LPC),
            "::",
            stringify!(quantization_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FLAC__Subframe_LPC>())).qlp_coeff as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__Subframe_LPC),
            "::",
            stringify!(qlp_coeff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FLAC__Subframe_LPC>())).warmup as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__Subframe_LPC),
            "::",
            stringify!(warmup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FLAC__Subframe_LPC>())).residual as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__Subframe_LPC),
            "::",
            stringify!(residual)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_FLAC__SUBFRAME_LPC_QLP_COEFF_PRECISION_LEN"]
    pub static mut FLAC__SUBFRAME_LPC_QLP_COEFF_PRECISION_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__SUBFRAME_LPC_QLP_SHIFT_LEN"]
    pub static mut FLAC__SUBFRAME_LPC_QLP_SHIFT_LEN: ::std::os::raw::c_uint;
}
/// FLAC subframe structure.  (c.f. <A HREF="../format.html#subframe">format specification</A>)
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FLAC__Subframe {
    pub type_: FLAC__SubframeType,
    pub data: FLAC__Subframe__bindgen_ty_1,
    pub wasted_bits: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FLAC__Subframe__bindgen_ty_1 {
    pub constant: FLAC__Subframe_Constant,
    pub fixed: FLAC__Subframe_Fixed,
    pub lpc: FLAC__Subframe_LPC,
    pub verbatim: FLAC__Subframe_Verbatim,
    _bindgen_union_align: [u64; 38usize],
}
#[test]
fn bindgen_test_layout_FLAC__Subframe__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<FLAC__Subframe__bindgen_ty_1>(),
        304usize,
        concat!("Size of: ", stringify!(FLAC__Subframe__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<FLAC__Subframe__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(FLAC__Subframe__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__Subframe__bindgen_ty_1>())).constant as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__Subframe__bindgen_ty_1),
            "::",
            stringify!(constant)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__Subframe__bindgen_ty_1>())).fixed as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__Subframe__bindgen_ty_1),
            "::",
            stringify!(fixed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__Subframe__bindgen_ty_1>())).lpc as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__Subframe__bindgen_ty_1),
            "::",
            stringify!(lpc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__Subframe__bindgen_ty_1>())).verbatim as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__Subframe__bindgen_ty_1),
            "::",
            stringify!(verbatim)
        )
    );
}
#[test]
fn bindgen_test_layout_FLAC__Subframe() {
    assert_eq!(
        ::std::mem::size_of::<FLAC__Subframe>(),
        320usize,
        concat!("Size of: ", stringify!(FLAC__Subframe))
    );
    assert_eq!(
        ::std::mem::align_of::<FLAC__Subframe>(),
        8usize,
        concat!("Alignment of ", stringify!(FLAC__Subframe))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FLAC__Subframe>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__Subframe),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FLAC__Subframe>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__Subframe),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FLAC__Subframe>())).wasted_bits as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__Subframe),
            "::",
            stringify!(wasted_bits)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_FLAC__SUBFRAME_ZERO_PAD_LEN"]
    pub static mut FLAC__SUBFRAME_ZERO_PAD_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__SUBFRAME_TYPE_LEN"]
    pub static mut FLAC__SUBFRAME_TYPE_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__SUBFRAME_WASTED_BITS_FLAG_LEN"]
    pub static mut FLAC__SUBFRAME_WASTED_BITS_FLAG_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__SUBFRAME_TYPE_CONSTANT_BYTE_ALIGNED_MASK"]
    pub static mut FLAC__SUBFRAME_TYPE_CONSTANT_BYTE_ALIGNED_MASK: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__SUBFRAME_TYPE_VERBATIM_BYTE_ALIGNED_MASK"]
    pub static mut FLAC__SUBFRAME_TYPE_VERBATIM_BYTE_ALIGNED_MASK: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__SUBFRAME_TYPE_FIXED_BYTE_ALIGNED_MASK"]
    pub static mut FLAC__SUBFRAME_TYPE_FIXED_BYTE_ALIGNED_MASK: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__SUBFRAME_TYPE_LPC_BYTE_ALIGNED_MASK"]
    pub static mut FLAC__SUBFRAME_TYPE_LPC_BYTE_ALIGNED_MASK: ::std::os::raw::c_uint;
}
pub const FLAC__ChannelAssignment_FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT: FLAC__ChannelAssignment = 0;
pub const FLAC__ChannelAssignment_FLAC__CHANNEL_ASSIGNMENT_LEFT_SIDE: FLAC__ChannelAssignment = 1;
pub const FLAC__ChannelAssignment_FLAC__CHANNEL_ASSIGNMENT_RIGHT_SIDE: FLAC__ChannelAssignment = 2;
pub const FLAC__ChannelAssignment_FLAC__CHANNEL_ASSIGNMENT_MID_SIDE: FLAC__ChannelAssignment = 3;
pub type FLAC__ChannelAssignment = u32;
extern "C" {
    #[link_name = "\u{1}_FLAC__ChannelAssignmentString"]
    pub static mut FLAC__ChannelAssignmentString: [*const ::std::os::raw::c_char; 0usize];
}
pub const FLAC__FrameNumberType_FLAC__FRAME_NUMBER_TYPE_FRAME_NUMBER: FLAC__FrameNumberType = 0;
pub const FLAC__FrameNumberType_FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER: FLAC__FrameNumberType = 1;
pub type FLAC__FrameNumberType = u32;
extern "C" {
    #[link_name = "\u{1}_FLAC__FrameNumberTypeString"]
    pub static mut FLAC__FrameNumberTypeString: [*const ::std::os::raw::c_char; 0usize];
}
/// FLAC frame header structure.  (c.f. <A HREF="../format.html#frame_header">format specification</A>)
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FLAC__FrameHeader {
    pub blocksize: ::std::os::raw::c_uint,
    pub sample_rate: ::std::os::raw::c_uint,
    pub channels: ::std::os::raw::c_uint,
    pub channel_assignment: FLAC__ChannelAssignment,
    pub bits_per_sample: ::std::os::raw::c_uint,
    pub number_type: FLAC__FrameNumberType,
    pub number: FLAC__FrameHeader__bindgen_ty_1,
    pub crc: FLAC__uint8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FLAC__FrameHeader__bindgen_ty_1 {
    pub frame_number: FLAC__uint32,
    pub sample_number: FLAC__uint64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_FLAC__FrameHeader__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<FLAC__FrameHeader__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(FLAC__FrameHeader__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<FLAC__FrameHeader__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(FLAC__FrameHeader__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__FrameHeader__bindgen_ty_1>())).frame_number as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__FrameHeader__bindgen_ty_1),
            "::",
            stringify!(frame_number)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__FrameHeader__bindgen_ty_1>())).sample_number as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__FrameHeader__bindgen_ty_1),
            "::",
            stringify!(sample_number)
        )
    );
}
#[test]
fn bindgen_test_layout_FLAC__FrameHeader() {
    assert_eq!(
        ::std::mem::size_of::<FLAC__FrameHeader>(),
        40usize,
        concat!("Size of: ", stringify!(FLAC__FrameHeader))
    );
    assert_eq!(
        ::std::mem::align_of::<FLAC__FrameHeader>(),
        8usize,
        concat!("Alignment of ", stringify!(FLAC__FrameHeader))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FLAC__FrameHeader>())).blocksize as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__FrameHeader),
            "::",
            stringify!(blocksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FLAC__FrameHeader>())).sample_rate as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__FrameHeader),
            "::",
            stringify!(sample_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FLAC__FrameHeader>())).channels as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__FrameHeader),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__FrameHeader>())).channel_assignment as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__FrameHeader),
            "::",
            stringify!(channel_assignment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__FrameHeader>())).bits_per_sample as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__FrameHeader),
            "::",
            stringify!(bits_per_sample)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FLAC__FrameHeader>())).number_type as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__FrameHeader),
            "::",
            stringify!(number_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FLAC__FrameHeader>())).number as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__FrameHeader),
            "::",
            stringify!(number)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FLAC__FrameHeader>())).crc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__FrameHeader),
            "::",
            stringify!(crc)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_FLAC__FRAME_HEADER_SYNC"]
    pub static mut FLAC__FRAME_HEADER_SYNC: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__FRAME_HEADER_SYNC_LEN"]
    pub static mut FLAC__FRAME_HEADER_SYNC_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__FRAME_HEADER_RESERVED_LEN"]
    pub static mut FLAC__FRAME_HEADER_RESERVED_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__FRAME_HEADER_BLOCKING_STRATEGY_LEN"]
    pub static mut FLAC__FRAME_HEADER_BLOCKING_STRATEGY_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__FRAME_HEADER_BLOCK_SIZE_LEN"]
    pub static mut FLAC__FRAME_HEADER_BLOCK_SIZE_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__FRAME_HEADER_SAMPLE_RATE_LEN"]
    pub static mut FLAC__FRAME_HEADER_SAMPLE_RATE_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__FRAME_HEADER_CHANNEL_ASSIGNMENT_LEN"]
    pub static mut FLAC__FRAME_HEADER_CHANNEL_ASSIGNMENT_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__FRAME_HEADER_BITS_PER_SAMPLE_LEN"]
    pub static mut FLAC__FRAME_HEADER_BITS_PER_SAMPLE_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__FRAME_HEADER_ZERO_PAD_LEN"]
    pub static mut FLAC__FRAME_HEADER_ZERO_PAD_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__FRAME_HEADER_CRC_LEN"]
    pub static mut FLAC__FRAME_HEADER_CRC_LEN: ::std::os::raw::c_uint;
}
/// FLAC frame footer structure.  (c.f. <A HREF="../format.html#frame_footer">format specification</A>)
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__FrameFooter {
    pub crc: FLAC__uint16,
}
#[test]
fn bindgen_test_layout_FLAC__FrameFooter() {
    assert_eq!(
        ::std::mem::size_of::<FLAC__FrameFooter>(),
        2usize,
        concat!("Size of: ", stringify!(FLAC__FrameFooter))
    );
    assert_eq!(
        ::std::mem::align_of::<FLAC__FrameFooter>(),
        2usize,
        concat!("Alignment of ", stringify!(FLAC__FrameFooter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FLAC__FrameFooter>())).crc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__FrameFooter),
            "::",
            stringify!(crc)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_FLAC__FRAME_FOOTER_CRC_LEN"]
    pub static mut FLAC__FRAME_FOOTER_CRC_LEN: ::std::os::raw::c_uint;
}
/// FLAC frame structure.  (c.f. <A HREF="../format.html#frame">format specification</A>)
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FLAC__Frame {
    pub header: FLAC__FrameHeader,
    pub subframes: [FLAC__Subframe; 8usize],
    pub footer: FLAC__FrameFooter,
}
#[test]
fn bindgen_test_layout_FLAC__Frame() {
    assert_eq!(
        ::std::mem::size_of::<FLAC__Frame>(),
        2608usize,
        concat!("Size of: ", stringify!(FLAC__Frame))
    );
    assert_eq!(
        ::std::mem::align_of::<FLAC__Frame>(),
        8usize,
        concat!("Alignment of ", stringify!(FLAC__Frame))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FLAC__Frame>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__Frame),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FLAC__Frame>())).subframes as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__Frame),
            "::",
            stringify!(subframes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FLAC__Frame>())).footer as *const _ as usize },
        2600usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__Frame),
            "::",
            stringify!(footer)
        )
    );
}
pub const FLAC__MetadataType_FLAC__METADATA_TYPE_STREAMINFO: FLAC__MetadataType = 0;
pub const FLAC__MetadataType_FLAC__METADATA_TYPE_PADDING: FLAC__MetadataType = 1;
pub const FLAC__MetadataType_FLAC__METADATA_TYPE_APPLICATION: FLAC__MetadataType = 2;
pub const FLAC__MetadataType_FLAC__METADATA_TYPE_SEEKTABLE: FLAC__MetadataType = 3;
pub const FLAC__MetadataType_FLAC__METADATA_TYPE_VORBIS_COMMENT: FLAC__MetadataType = 4;
pub const FLAC__MetadataType_FLAC__METADATA_TYPE_CUESHEET: FLAC__MetadataType = 5;
pub const FLAC__MetadataType_FLAC__METADATA_TYPE_PICTURE: FLAC__MetadataType = 6;
pub const FLAC__MetadataType_FLAC__METADATA_TYPE_UNDEFINED: FLAC__MetadataType = 7;
pub const FLAC__MetadataType_FLAC__MAX_METADATA_TYPE: FLAC__MetadataType = 126;
pub type FLAC__MetadataType = u32;
extern "C" {
    #[link_name = "\u{1}_FLAC__MetadataTypeString"]
    pub static mut FLAC__MetadataTypeString: [*const ::std::os::raw::c_char; 0usize];
}
/// FLAC STREAMINFO structure.  (c.f. <A HREF="../format.html#metadata_block_streaminfo">format specification</A>)
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamMetadata_StreamInfo {
    pub min_blocksize: ::std::os::raw::c_uint,
    pub max_blocksize: ::std::os::raw::c_uint,
    pub min_framesize: ::std::os::raw::c_uint,
    pub max_framesize: ::std::os::raw::c_uint,
    pub sample_rate: ::std::os::raw::c_uint,
    pub channels: ::std::os::raw::c_uint,
    pub bits_per_sample: ::std::os::raw::c_uint,
    pub total_samples: FLAC__uint64,
    pub md5sum: [FLAC__byte; 16usize],
}
#[test]
fn bindgen_test_layout_FLAC__StreamMetadata_StreamInfo() {
    assert_eq!(
        ::std::mem::size_of::<FLAC__StreamMetadata_StreamInfo>(),
        56usize,
        concat!("Size of: ", stringify!(FLAC__StreamMetadata_StreamInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<FLAC__StreamMetadata_StreamInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(FLAC__StreamMetadata_StreamInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata_StreamInfo>())).min_blocksize as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata_StreamInfo),
            "::",
            stringify!(min_blocksize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata_StreamInfo>())).max_blocksize as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata_StreamInfo),
            "::",
            stringify!(max_blocksize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata_StreamInfo>())).min_framesize as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata_StreamInfo),
            "::",
            stringify!(min_framesize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata_StreamInfo>())).max_framesize as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata_StreamInfo),
            "::",
            stringify!(max_framesize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata_StreamInfo>())).sample_rate as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata_StreamInfo),
            "::",
            stringify!(sample_rate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata_StreamInfo>())).channels as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata_StreamInfo),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata_StreamInfo>())).bits_per_sample as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata_StreamInfo),
            "::",
            stringify!(bits_per_sample)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata_StreamInfo>())).total_samples as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata_StreamInfo),
            "::",
            stringify!(total_samples)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata_StreamInfo>())).md5sum as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata_StreamInfo),
            "::",
            stringify!(md5sum)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN"]
    pub static mut FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN"]
    pub static mut FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN"]
    pub static mut FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN"]
    pub static mut FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN"]
    pub static mut FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN"]
    pub static mut FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN"]
    pub static mut FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN"]
    pub static mut FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN"]
    pub static mut FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN: ::std::os::raw::c_uint;
}
/// FLAC PADDING structure.  (c.f. <A HREF="../format.html#metadata_block_padding">format specification</A>)
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamMetadata_Padding {
    pub dummy: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_FLAC__StreamMetadata_Padding() {
    assert_eq!(
        ::std::mem::size_of::<FLAC__StreamMetadata_Padding>(),
        4usize,
        concat!("Size of: ", stringify!(FLAC__StreamMetadata_Padding))
    );
    assert_eq!(
        ::std::mem::align_of::<FLAC__StreamMetadata_Padding>(),
        4usize,
        concat!("Alignment of ", stringify!(FLAC__StreamMetadata_Padding))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata_Padding>())).dummy as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata_Padding),
            "::",
            stringify!(dummy)
        )
    );
}
/// FLAC APPLICATION structure.  (c.f. <A HREF="../format.html#metadata_block_application">format specification</A>)
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamMetadata_Application {
    pub id: [FLAC__byte; 4usize],
    pub data: *mut FLAC__byte,
}
#[test]
fn bindgen_test_layout_FLAC__StreamMetadata_Application() {
    assert_eq!(
        ::std::mem::size_of::<FLAC__StreamMetadata_Application>(),
        16usize,
        concat!("Size of: ", stringify!(FLAC__StreamMetadata_Application))
    );
    assert_eq!(
        ::std::mem::align_of::<FLAC__StreamMetadata_Application>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(FLAC__StreamMetadata_Application)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata_Application>())).id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata_Application),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata_Application>())).data as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata_Application),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_FLAC__STREAM_METADATA_APPLICATION_ID_LEN"]
    pub static mut FLAC__STREAM_METADATA_APPLICATION_ID_LEN: ::std::os::raw::c_uint;
}
/// SeekPoint structure used in SEEKTABLE blocks.  (c.f. <A HREF="../format.html#seekpoint">format specification</A>)
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamMetadata_SeekPoint {
    pub sample_number: FLAC__uint64,
    pub stream_offset: FLAC__uint64,
    pub frame_samples: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_FLAC__StreamMetadata_SeekPoint() {
    assert_eq!(
        ::std::mem::size_of::<FLAC__StreamMetadata_SeekPoint>(),
        24usize,
        concat!("Size of: ", stringify!(FLAC__StreamMetadata_SeekPoint))
    );
    assert_eq!(
        ::std::mem::align_of::<FLAC__StreamMetadata_SeekPoint>(),
        8usize,
        concat!("Alignment of ", stringify!(FLAC__StreamMetadata_SeekPoint))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata_SeekPoint>())).sample_number as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata_SeekPoint),
            "::",
            stringify!(sample_number)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata_SeekPoint>())).stream_offset as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata_SeekPoint),
            "::",
            stringify!(stream_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata_SeekPoint>())).frame_samples as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata_SeekPoint),
            "::",
            stringify!(frame_samples)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN"]
    pub static mut FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN"]
    pub static mut FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN"]
    pub static mut FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__STREAM_METADATA_SEEKPOINT_PLACEHOLDER"]
    pub static mut FLAC__STREAM_METADATA_SEEKPOINT_PLACEHOLDER: FLAC__uint64;
}
/// FLAC SEEKTABLE structure.  (c.f. <A HREF="../format.html#metadata_block_seektable">format specification</A>)
///
/// \note From the format specification:
/// - The seek points must be sorted by ascending sample number.
/// - Each seek point's sample number must be the first sample of the
/// target frame.
/// - Each seek point's sample number must be unique within the table.
/// - Existence of a SEEKTABLE block implies a correct setting of
/// total_samples in the stream_info block.
/// - Behavior is undefined when more than one SEEKTABLE block is
/// present in a stream.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamMetadata_SeekTable {
    pub num_points: ::std::os::raw::c_uint,
    pub points: *mut FLAC__StreamMetadata_SeekPoint,
}
#[test]
fn bindgen_test_layout_FLAC__StreamMetadata_SeekTable() {
    assert_eq!(
        ::std::mem::size_of::<FLAC__StreamMetadata_SeekTable>(),
        16usize,
        concat!("Size of: ", stringify!(FLAC__StreamMetadata_SeekTable))
    );
    assert_eq!(
        ::std::mem::align_of::<FLAC__StreamMetadata_SeekTable>(),
        8usize,
        concat!("Alignment of ", stringify!(FLAC__StreamMetadata_SeekTable))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata_SeekTable>())).num_points as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata_SeekTable),
            "::",
            stringify!(num_points)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata_SeekTable>())).points as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata_SeekTable),
            "::",
            stringify!(points)
        )
    );
}
/// Vorbis comment entry structure used in VORBIS_COMMENT blocks.  (c.f. <A HREF="../format.html#metadata_block_vorbis_comment">format specification</A>)
///
/// For convenience, the APIs maintain a trailing NUL character at the end of
/// \a entry which is not counted toward \a length, i.e.
/// \code strlen(entry) == length \endcode
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamMetadata_VorbisComment_Entry {
    pub length: FLAC__uint32,
    pub entry: *mut FLAC__byte,
}
#[test]
fn bindgen_test_layout_FLAC__StreamMetadata_VorbisComment_Entry() {
    assert_eq!(
        ::std::mem::size_of::<FLAC__StreamMetadata_VorbisComment_Entry>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(FLAC__StreamMetadata_VorbisComment_Entry)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FLAC__StreamMetadata_VorbisComment_Entry>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(FLAC__StreamMetadata_VorbisComment_Entry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata_VorbisComment_Entry>())).length as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata_VorbisComment_Entry),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata_VorbisComment_Entry>())).entry as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata_VorbisComment_Entry),
            "::",
            stringify!(entry)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_FLAC__STREAM_METADATA_VORBIS_COMMENT_ENTRY_LENGTH_LEN"]
    pub static mut FLAC__STREAM_METADATA_VORBIS_COMMENT_ENTRY_LENGTH_LEN: ::std::os::raw::c_uint;
}
/// FLAC VORBIS_COMMENT structure.  (c.f. <A HREF="../format.html#metadata_block_vorbis_comment">format specification</A>)
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamMetadata_VorbisComment {
    pub vendor_string: FLAC__StreamMetadata_VorbisComment_Entry,
    pub num_comments: FLAC__uint32,
    pub comments: *mut FLAC__StreamMetadata_VorbisComment_Entry,
}
#[test]
fn bindgen_test_layout_FLAC__StreamMetadata_VorbisComment() {
    assert_eq!(
        ::std::mem::size_of::<FLAC__StreamMetadata_VorbisComment>(),
        32usize,
        concat!("Size of: ", stringify!(FLAC__StreamMetadata_VorbisComment))
    );
    assert_eq!(
        ::std::mem::align_of::<FLAC__StreamMetadata_VorbisComment>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(FLAC__StreamMetadata_VorbisComment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata_VorbisComment>())).vendor_string as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata_VorbisComment),
            "::",
            stringify!(vendor_string)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata_VorbisComment>())).num_comments as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata_VorbisComment),
            "::",
            stringify!(num_comments)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata_VorbisComment>())).comments as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata_VorbisComment),
            "::",
            stringify!(comments)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_FLAC__STREAM_METADATA_VORBIS_COMMENT_NUM_COMMENTS_LEN"]
    pub static mut FLAC__STREAM_METADATA_VORBIS_COMMENT_NUM_COMMENTS_LEN: ::std::os::raw::c_uint;
}
/// FLAC CUESHEET track index structure.  (See the
/// <A HREF="../format.html#cuesheet_track_index">format specification</A> for
/// the full description of each field.)
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamMetadata_CueSheet_Index {
    pub offset: FLAC__uint64,
    pub number: FLAC__byte,
}
#[test]
fn bindgen_test_layout_FLAC__StreamMetadata_CueSheet_Index() {
    assert_eq!(
        ::std::mem::size_of::<FLAC__StreamMetadata_CueSheet_Index>(),
        16usize,
        concat!("Size of: ", stringify!(FLAC__StreamMetadata_CueSheet_Index))
    );
    assert_eq!(
        ::std::mem::align_of::<FLAC__StreamMetadata_CueSheet_Index>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(FLAC__StreamMetadata_CueSheet_Index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata_CueSheet_Index>())).offset as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata_CueSheet_Index),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata_CueSheet_Index>())).number as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata_CueSheet_Index),
            "::",
            stringify!(number)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_FLAC__STREAM_METADATA_CUESHEET_INDEX_OFFSET_LEN"]
    pub static mut FLAC__STREAM_METADATA_CUESHEET_INDEX_OFFSET_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__STREAM_METADATA_CUESHEET_INDEX_NUMBER_LEN"]
    pub static mut FLAC__STREAM_METADATA_CUESHEET_INDEX_NUMBER_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__STREAM_METADATA_CUESHEET_INDEX_RESERVED_LEN"]
    pub static mut FLAC__STREAM_METADATA_CUESHEET_INDEX_RESERVED_LEN: ::std::os::raw::c_uint;
}
/// FLAC CUESHEET track structure.  (See the
/// <A HREF="../format.html#cuesheet_track">format specification</A> for
/// the full description of each field.)
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamMetadata_CueSheet_Track {
    pub offset: FLAC__uint64,
    pub number: FLAC__byte,
    pub isrc: [::std::os::raw::c_char; 13usize],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub num_indices: FLAC__byte,
    pub indices: *mut FLAC__StreamMetadata_CueSheet_Index,
}
#[test]
fn bindgen_test_layout_FLAC__StreamMetadata_CueSheet_Track() {
    assert_eq!(
        ::std::mem::size_of::<FLAC__StreamMetadata_CueSheet_Track>(),
        32usize,
        concat!("Size of: ", stringify!(FLAC__StreamMetadata_CueSheet_Track))
    );
    assert_eq!(
        ::std::mem::align_of::<FLAC__StreamMetadata_CueSheet_Track>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(FLAC__StreamMetadata_CueSheet_Track)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata_CueSheet_Track>())).offset as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata_CueSheet_Track),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata_CueSheet_Track>())).number as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata_CueSheet_Track),
            "::",
            stringify!(number)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata_CueSheet_Track>())).isrc as *const _
                as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata_CueSheet_Track),
            "::",
            stringify!(isrc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata_CueSheet_Track>())).num_indices as *const _
                as usize
        },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata_CueSheet_Track),
            "::",
            stringify!(num_indices)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata_CueSheet_Track>())).indices as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata_CueSheet_Track),
            "::",
            stringify!(indices)
        )
    );
}
impl FLAC__StreamMetadata_CueSheet_Track {
    #[inline]
    pub fn type_(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pre_emphasis(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pre_emphasis(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        type_: ::std::os::raw::c_uint,
        pre_emphasis: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let pre_emphasis: u32 = unsafe { ::std::mem::transmute(pre_emphasis) };
            pre_emphasis as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[link_name = "\u{1}_FLAC__STREAM_METADATA_CUESHEET_TRACK_OFFSET_LEN"]
    pub static mut FLAC__STREAM_METADATA_CUESHEET_TRACK_OFFSET_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__STREAM_METADATA_CUESHEET_TRACK_NUMBER_LEN"]
    pub static mut FLAC__STREAM_METADATA_CUESHEET_TRACK_NUMBER_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__STREAM_METADATA_CUESHEET_TRACK_ISRC_LEN"]
    pub static mut FLAC__STREAM_METADATA_CUESHEET_TRACK_ISRC_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__STREAM_METADATA_CUESHEET_TRACK_TYPE_LEN"]
    pub static mut FLAC__STREAM_METADATA_CUESHEET_TRACK_TYPE_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__STREAM_METADATA_CUESHEET_TRACK_PRE_EMPHASIS_LEN"]
    pub static mut FLAC__STREAM_METADATA_CUESHEET_TRACK_PRE_EMPHASIS_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__STREAM_METADATA_CUESHEET_TRACK_RESERVED_LEN"]
    pub static mut FLAC__STREAM_METADATA_CUESHEET_TRACK_RESERVED_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__STREAM_METADATA_CUESHEET_TRACK_NUM_INDICES_LEN"]
    pub static mut FLAC__STREAM_METADATA_CUESHEET_TRACK_NUM_INDICES_LEN: ::std::os::raw::c_uint;
}
/// FLAC CUESHEET structure.  (See the
/// <A HREF="../format.html#metadata_block_cuesheet">format specification</A>
/// for the full description of each field.)
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FLAC__StreamMetadata_CueSheet {
    pub media_catalog_number: [::std::os::raw::c_char; 129usize],
    pub lead_in: FLAC__uint64,
    pub is_cd: FLAC__bool,
    pub num_tracks: ::std::os::raw::c_uint,
    pub tracks: *mut FLAC__StreamMetadata_CueSheet_Track,
}
#[test]
fn bindgen_test_layout_FLAC__StreamMetadata_CueSheet() {
    assert_eq!(
        ::std::mem::size_of::<FLAC__StreamMetadata_CueSheet>(),
        160usize,
        concat!("Size of: ", stringify!(FLAC__StreamMetadata_CueSheet))
    );
    assert_eq!(
        ::std::mem::align_of::<FLAC__StreamMetadata_CueSheet>(),
        8usize,
        concat!("Alignment of ", stringify!(FLAC__StreamMetadata_CueSheet))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata_CueSheet>())).media_catalog_number
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata_CueSheet),
            "::",
            stringify!(media_catalog_number)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata_CueSheet>())).lead_in as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata_CueSheet),
            "::",
            stringify!(lead_in)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata_CueSheet>())).is_cd as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata_CueSheet),
            "::",
            stringify!(is_cd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata_CueSheet>())).num_tracks as *const _
                as usize
        },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata_CueSheet),
            "::",
            stringify!(num_tracks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata_CueSheet>())).tracks as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata_CueSheet),
            "::",
            stringify!(tracks)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_FLAC__STREAM_METADATA_CUESHEET_MEDIA_CATALOG_NUMBER_LEN"]
    pub static mut FLAC__STREAM_METADATA_CUESHEET_MEDIA_CATALOG_NUMBER_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__STREAM_METADATA_CUESHEET_LEAD_IN_LEN"]
    pub static mut FLAC__STREAM_METADATA_CUESHEET_LEAD_IN_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__STREAM_METADATA_CUESHEET_IS_CD_LEN"]
    pub static mut FLAC__STREAM_METADATA_CUESHEET_IS_CD_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__STREAM_METADATA_CUESHEET_RESERVED_LEN"]
    pub static mut FLAC__STREAM_METADATA_CUESHEET_RESERVED_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__STREAM_METADATA_CUESHEET_NUM_TRACKS_LEN"]
    pub static mut FLAC__STREAM_METADATA_CUESHEET_NUM_TRACKS_LEN: ::std::os::raw::c_uint;
}
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_OTHER:
    FLAC__StreamMetadata_Picture_Type = 0;
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON_STANDARD : FLAC__StreamMetadata_Picture_Type = 1 ;
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON:
    FLAC__StreamMetadata_Picture_Type = 2;
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_FRONT_COVER:
    FLAC__StreamMetadata_Picture_Type = 3;
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_BACK_COVER:
    FLAC__StreamMetadata_Picture_Type = 4;
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_LEAFLET_PAGE:
    FLAC__StreamMetadata_Picture_Type = 5;
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_MEDIA:
    FLAC__StreamMetadata_Picture_Type = 6;
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_LEAD_ARTIST:
    FLAC__StreamMetadata_Picture_Type = 7;
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_ARTIST:
    FLAC__StreamMetadata_Picture_Type = 8;
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_CONDUCTOR:
    FLAC__StreamMetadata_Picture_Type = 9;
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_BAND:
    FLAC__StreamMetadata_Picture_Type = 10;
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_COMPOSER:
    FLAC__StreamMetadata_Picture_Type = 11;
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_LYRICIST:
    FLAC__StreamMetadata_Picture_Type = 12;
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_RECORDING_LOCATION : FLAC__StreamMetadata_Picture_Type = 13 ;
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_RECORDING:
    FLAC__StreamMetadata_Picture_Type = 14;
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_PERFORMANCE : FLAC__StreamMetadata_Picture_Type = 15 ;
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_VIDEO_SCREEN_CAPTURE : FLAC__StreamMetadata_Picture_Type = 16 ;
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_FISH:
    FLAC__StreamMetadata_Picture_Type = 17;
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_ILLUSTRATION:
    FLAC__StreamMetadata_Picture_Type = 18;
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_BAND_LOGOTYPE:
    FLAC__StreamMetadata_Picture_Type = 19;
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_PUBLISHER_LOGOTYPE : FLAC__StreamMetadata_Picture_Type = 20 ;
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_UNDEFINED:
    FLAC__StreamMetadata_Picture_Type = 21;
pub type FLAC__StreamMetadata_Picture_Type = u32;
extern "C" {
    #[link_name = "\u{1}_FLAC__StreamMetadata_Picture_TypeString"]
    pub static mut FLAC__StreamMetadata_Picture_TypeString: [*const ::std::os::raw::c_char; 0usize];
}
/// FLAC PICTURE structure.  (See the
/// <A HREF="../format.html#metadata_block_picture">format specification</A>
/// for the full description of each field.)
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamMetadata_Picture {
    pub type_: FLAC__StreamMetadata_Picture_Type,
    pub mime_type: *mut ::std::os::raw::c_char,
    pub description: *mut FLAC__byte,
    pub width: FLAC__uint32,
    pub height: FLAC__uint32,
    pub depth: FLAC__uint32,
    pub colors: FLAC__uint32,
    pub data_length: FLAC__uint32,
    pub data: *mut FLAC__byte,
}
#[test]
fn bindgen_test_layout_FLAC__StreamMetadata_Picture() {
    assert_eq!(
        ::std::mem::size_of::<FLAC__StreamMetadata_Picture>(),
        56usize,
        concat!("Size of: ", stringify!(FLAC__StreamMetadata_Picture))
    );
    assert_eq!(
        ::std::mem::align_of::<FLAC__StreamMetadata_Picture>(),
        8usize,
        concat!("Alignment of ", stringify!(FLAC__StreamMetadata_Picture))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata_Picture>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata_Picture),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata_Picture>())).mime_type as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata_Picture),
            "::",
            stringify!(mime_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata_Picture>())).description as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata_Picture),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata_Picture>())).width as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata_Picture),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata_Picture>())).height as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata_Picture),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata_Picture>())).depth as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata_Picture),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata_Picture>())).colors as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata_Picture),
            "::",
            stringify!(colors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata_Picture>())).data_length as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata_Picture),
            "::",
            stringify!(data_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata_Picture>())).data as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata_Picture),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_FLAC__STREAM_METADATA_PICTURE_TYPE_LEN"]
    pub static mut FLAC__STREAM_METADATA_PICTURE_TYPE_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__STREAM_METADATA_PICTURE_MIME_TYPE_LENGTH_LEN"]
    pub static mut FLAC__STREAM_METADATA_PICTURE_MIME_TYPE_LENGTH_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__STREAM_METADATA_PICTURE_DESCRIPTION_LENGTH_LEN"]
    pub static mut FLAC__STREAM_METADATA_PICTURE_DESCRIPTION_LENGTH_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__STREAM_METADATA_PICTURE_WIDTH_LEN"]
    pub static mut FLAC__STREAM_METADATA_PICTURE_WIDTH_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__STREAM_METADATA_PICTURE_HEIGHT_LEN"]
    pub static mut FLAC__STREAM_METADATA_PICTURE_HEIGHT_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__STREAM_METADATA_PICTURE_DEPTH_LEN"]
    pub static mut FLAC__STREAM_METADATA_PICTURE_DEPTH_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__STREAM_METADATA_PICTURE_COLORS_LEN"]
    pub static mut FLAC__STREAM_METADATA_PICTURE_COLORS_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__STREAM_METADATA_PICTURE_DATA_LENGTH_LEN"]
    pub static mut FLAC__STREAM_METADATA_PICTURE_DATA_LENGTH_LEN: ::std::os::raw::c_uint;
}
/// Structure that is used when a metadata block of unknown type is loaded.
/// The contents are opaque.  The structure is used only internally to
/// correctly handle unknown metadata.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamMetadata_Unknown {
    pub data: *mut FLAC__byte,
}
#[test]
fn bindgen_test_layout_FLAC__StreamMetadata_Unknown() {
    assert_eq!(
        ::std::mem::size_of::<FLAC__StreamMetadata_Unknown>(),
        8usize,
        concat!("Size of: ", stringify!(FLAC__StreamMetadata_Unknown))
    );
    assert_eq!(
        ::std::mem::align_of::<FLAC__StreamMetadata_Unknown>(),
        8usize,
        concat!("Alignment of ", stringify!(FLAC__StreamMetadata_Unknown))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata_Unknown>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata_Unknown),
            "::",
            stringify!(data)
        )
    );
}
/// FLAC metadata block structure.  (c.f. <A HREF="../format.html#metadata_block">format specification</A>)
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FLAC__StreamMetadata {
    pub type_: FLAC__MetadataType,
    pub is_last: FLAC__bool,
    pub length: ::std::os::raw::c_uint,
    pub data: FLAC__StreamMetadata__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FLAC__StreamMetadata__bindgen_ty_1 {
    pub stream_info: FLAC__StreamMetadata_StreamInfo,
    pub padding: FLAC__StreamMetadata_Padding,
    pub application: FLAC__StreamMetadata_Application,
    pub seek_table: FLAC__StreamMetadata_SeekTable,
    pub vorbis_comment: FLAC__StreamMetadata_VorbisComment,
    pub cue_sheet: FLAC__StreamMetadata_CueSheet,
    pub picture: FLAC__StreamMetadata_Picture,
    pub unknown: FLAC__StreamMetadata_Unknown,
    _bindgen_union_align: [u64; 20usize],
}
#[test]
fn bindgen_test_layout_FLAC__StreamMetadata__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<FLAC__StreamMetadata__bindgen_ty_1>(),
        160usize,
        concat!("Size of: ", stringify!(FLAC__StreamMetadata__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<FLAC__StreamMetadata__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(FLAC__StreamMetadata__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata__bindgen_ty_1>())).stream_info as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata__bindgen_ty_1),
            "::",
            stringify!(stream_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata__bindgen_ty_1>())).padding as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata__bindgen_ty_1),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata__bindgen_ty_1>())).application as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata__bindgen_ty_1),
            "::",
            stringify!(application)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata__bindgen_ty_1>())).seek_table as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata__bindgen_ty_1),
            "::",
            stringify!(seek_table)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata__bindgen_ty_1>())).vorbis_comment
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata__bindgen_ty_1),
            "::",
            stringify!(vorbis_comment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata__bindgen_ty_1>())).cue_sheet as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata__bindgen_ty_1),
            "::",
            stringify!(cue_sheet)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata__bindgen_ty_1>())).picture as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata__bindgen_ty_1),
            "::",
            stringify!(picture)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FLAC__StreamMetadata__bindgen_ty_1>())).unknown as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata__bindgen_ty_1),
            "::",
            stringify!(unknown)
        )
    );
}
#[test]
fn bindgen_test_layout_FLAC__StreamMetadata() {
    assert_eq!(
        ::std::mem::size_of::<FLAC__StreamMetadata>(),
        176usize,
        concat!("Size of: ", stringify!(FLAC__StreamMetadata))
    );
    assert_eq!(
        ::std::mem::align_of::<FLAC__StreamMetadata>(),
        8usize,
        concat!("Alignment of ", stringify!(FLAC__StreamMetadata))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FLAC__StreamMetadata>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FLAC__StreamMetadata>())).is_last as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata),
            "::",
            stringify!(is_last)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FLAC__StreamMetadata>())).length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FLAC__StreamMetadata>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamMetadata),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_FLAC__STREAM_METADATA_IS_LAST_LEN"]
    pub static mut FLAC__STREAM_METADATA_IS_LAST_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__STREAM_METADATA_TYPE_LEN"]
    pub static mut FLAC__STREAM_METADATA_TYPE_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_FLAC__STREAM_METADATA_LENGTH_LEN"]
    pub static mut FLAC__STREAM_METADATA_LENGTH_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    /// Tests that a sample rate is valid for FLAC.
    ///
    /// \param sample_rate  The sample rate to test for compliance.
    /// \retval FLAC__bool
    /// \c true if the given sample rate conforms to the specification, else
    /// \c false.
    #[link_name = "\u{1}_FLAC__format_sample_rate_is_valid"]
    pub fn FLAC__format_sample_rate_is_valid(sample_rate: ::std::os::raw::c_uint) -> FLAC__bool;
}
extern "C" {
    /// Tests that a blocksize at the given sample rate is valid for the FLAC
    /// subset.
    ///
    /// \param blocksize    The blocksize to test for compliance.
    /// \param sample_rate  The sample rate is needed, since the valid subset
    /// blocksize depends on the sample rate.
    /// \retval FLAC__bool
    /// \c true if the given blocksize conforms to the specification for the
    /// subset at the given sample rate, else \c false.
    #[link_name = "\u{1}_FLAC__format_blocksize_is_subset"]
    pub fn FLAC__format_blocksize_is_subset(
        blocksize: ::std::os::raw::c_uint,
        sample_rate: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    /// Tests that a sample rate is valid for the FLAC subset.  The subset rules
    /// for valid sample rates are slightly more complex since the rate has to
    /// be expressible completely in the frame header.
    ///
    /// \param sample_rate  The sample rate to test for compliance.
    /// \retval FLAC__bool
    /// \c true if the given sample rate conforms to the specification for the
    /// subset, else \c false.
    #[link_name = "\u{1}_FLAC__format_sample_rate_is_subset"]
    pub fn FLAC__format_sample_rate_is_subset(sample_rate: ::std::os::raw::c_uint) -> FLAC__bool;
}
extern "C" {
    /// Check a Vorbis comment entry name to see if it conforms to the Vorbis
    /// comment specification.
    ///
    /// Vorbis comment names must be composed only of characters from
    /// [0x20-0x3C,0x3E-0x7D].
    ///
    /// \param name       A NUL-terminated string to be checked.
    /// \assert
    /// \code name != NULL \endcode
    /// \retval FLAC__bool
    /// \c false if entry name is illegal, else \c true.
    #[link_name = "\u{1}_FLAC__format_vorbiscomment_entry_name_is_legal"]
    pub fn FLAC__format_vorbiscomment_entry_name_is_legal(
        name: *const ::std::os::raw::c_char,
    ) -> FLAC__bool;
}
extern "C" {
    /// Check a Vorbis comment entry value to see if it conforms to the Vorbis
    /// comment specification.
    ///
    /// Vorbis comment values must be valid UTF-8 sequences.
    ///
    /// \param value      A string to be checked.
    /// \param length     A the length of \a value in bytes.  May be
    /// \c (unsigned)(-1) to indicate that \a value is a plain
    /// UTF-8 NUL-terminated string.
    /// \assert
    /// \code value != NULL \endcode
    /// \retval FLAC__bool
    /// \c false if entry name is illegal, else \c true.
    #[link_name = "\u{1}_FLAC__format_vorbiscomment_entry_value_is_legal"]
    pub fn FLAC__format_vorbiscomment_entry_value_is_legal(
        value: *const FLAC__byte,
        length: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    /// Check a Vorbis comment entry to see if it conforms to the Vorbis
    /// comment specification.
    ///
    /// Vorbis comment entries must be of the form 'name=value', and 'name' and
    /// 'value' must be legal according to
    /// FLAC__format_vorbiscomment_entry_name_is_legal() and
    /// FLAC__format_vorbiscomment_entry_value_is_legal() respectively.
    ///
    /// \param entry      An entry to be checked.
    /// \param length     The length of \a entry in bytes.
    /// \assert
    /// \code value != NULL \endcode
    /// \retval FLAC__bool
    /// \c false if entry name is illegal, else \c true.
    #[link_name = "\u{1}_FLAC__format_vorbiscomment_entry_is_legal"]
    pub fn FLAC__format_vorbiscomment_entry_is_legal(
        entry: *const FLAC__byte,
        length: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    /// Check a seek table to see if it conforms to the FLAC specification.
    /// See the format specification for limits on the contents of the
    /// seek table.
    ///
    /// \param seek_table  A pointer to a seek table to be checked.
    /// \assert
    /// \code seek_table != NULL \endcode
    /// \retval FLAC__bool
    /// \c false if seek table is illegal, else \c true.
    #[link_name = "\u{1}_FLAC__format_seektable_is_legal"]
    pub fn FLAC__format_seektable_is_legal(
        seek_table: *const FLAC__StreamMetadata_SeekTable,
    ) -> FLAC__bool;
}
extern "C" {
    /// Sort a seek table's seek points according to the format specification.
    /// This includes a "unique-ification" step to remove duplicates, i.e.
    /// seek points with identical \a sample_number values.  Duplicate seek
    /// points are converted into placeholder points and sorted to the end of
    /// the table.
    ///
    /// \param seek_table  A pointer to a seek table to be sorted.
    /// \assert
    /// \code seek_table != NULL \endcode
    /// \retval unsigned
    /// The number of duplicate seek points converted into placeholders.
    #[link_name = "\u{1}_FLAC__format_seektable_sort"]
    pub fn FLAC__format_seektable_sort(
        seek_table: *mut FLAC__StreamMetadata_SeekTable,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    /// Check a cue sheet to see if it conforms to the FLAC specification.
    /// See the format specification for limits on the contents of the
    /// cue sheet.
    ///
    /// \param cue_sheet  A pointer to an existing cue sheet to be checked.
    /// \param check_cd_da_subset  If \c true, check CUESHEET against more
    /// stringent requirements for a CD-DA (audio) disc.
    /// \param violation  Address of a pointer to a string.  If there is a
    /// violation, a pointer to a string explanation of the
    /// violation will be returned here. \a violation may be
    /// \c NULL if you don't need the returned string.  Do not
    /// free the returned string; it will always point to static
    /// data.
    /// \assert
    /// \code cue_sheet != NULL \endcode
    /// \retval FLAC__bool
    /// \c false if cue sheet is illegal, else \c true.
    #[link_name = "\u{1}_FLAC__format_cuesheet_is_legal"]
    pub fn FLAC__format_cuesheet_is_legal(
        cue_sheet: *const FLAC__StreamMetadata_CueSheet,
        check_cd_da_subset: FLAC__bool,
        violation: *mut *const ::std::os::raw::c_char,
    ) -> FLAC__bool;
}
extern "C" {
    /// Check picture data to see if it conforms to the FLAC specification.
    /// See the format specification for limits on the contents of the
    /// PICTURE block.
    ///
    /// \param picture    A pointer to existing picture data to be checked.
    /// \param violation  Address of a pointer to a string.  If there is a
    /// violation, a pointer to a string explanation of the
    /// violation will be returned here. \a violation may be
    /// \c NULL if you don't need the returned string.  Do not
    /// free the returned string; it will always point to static
    /// data.
    /// \assert
    /// \code picture != NULL \endcode
    /// \retval FLAC__bool
    /// \c false if picture data is illegal, else \c true.
    #[link_name = "\u{1}_FLAC__format_picture_is_legal"]
    pub fn FLAC__format_picture_is_legal(
        picture: *const FLAC__StreamMetadata_Picture,
        violation: *mut *const ::std::os::raw::c_char,
    ) -> FLAC__bool;
}
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_quad_t = u_int64_t;
pub type quad_t = i64;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::std::os::raw::c_char;
pub type daddr_t = i32;
pub type fixpt_t = u_int32_t;
pub type blkcnt_t = __darwin_blkcnt_t;
pub type blksize_t = __darwin_blksize_t;
pub type gid_t = __darwin_gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type ino_t = __darwin_ino_t;
pub type ino64_t = __darwin_ino64_t;
pub type key_t = __int32_t;
pub type nlink_t = __uint16_t;
pub type off_t = __darwin_off_t;
pub type segsz_t = i32;
pub type swblk_t = i32;
pub type clock_t = __darwin_clock_t;
pub type time_t = __darwin_time_t;
pub type useconds_t = __darwin_useconds_t;
pub type suseconds_t = __darwin_suseconds_t;
pub type rsize_t = __darwin_size_t;
pub type errno_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [__int32_t; 32usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        4usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
pub type fd_mask = __int32_t;
pub type pthread_cond_t = __darwin_pthread_cond_t;
pub type pthread_condattr_t = __darwin_pthread_condattr_t;
pub type pthread_mutex_t = __darwin_pthread_mutex_t;
pub type pthread_mutexattr_t = __darwin_pthread_mutexattr_t;
pub type pthread_once_t = __darwin_pthread_once_t;
pub type pthread_rwlock_t = __darwin_pthread_rwlock_t;
pub type pthread_rwlockattr_t = __darwin_pthread_rwlockattr_t;
pub type pthread_t = __darwin_pthread_t;
pub type pthread_key_t = __darwin_pthread_key_t;
pub type fsblkcnt_t = __darwin_fsblkcnt_t;
pub type fsfilcnt_t = __darwin_fsfilcnt_t;
extern "C" {
    /// Read the STREAMINFO metadata block of the given FLAC file.  This function
    /// will try to skip any ID3v2 tag at the head of the file.
    ///
    /// \param filename    The path to the FLAC file to read.
    /// \param streaminfo  A pointer to space for the STREAMINFO block.  Since
    /// FLAC__StreamMetadata is a simple structure with no
    /// memory allocation involved, you pass the address of
    /// an existing structure.  It need not be initialized.
    /// \assert
    /// \code filename != NULL \endcode
    /// \code streaminfo != NULL \endcode
    /// \retval FLAC__bool
    /// \c true if a valid STREAMINFO block was read from \a filename.  Returns
    /// \c false if there was a memory allocation error, a file decoder error,
    /// or the file contained no STREAMINFO block.  (A memory allocation error
    /// is possible because this function must set up a file decoder.)
    #[link_name = "\u{1}_FLAC__metadata_get_streaminfo"]
    pub fn FLAC__metadata_get_streaminfo(
        filename: *const ::std::os::raw::c_char,
        streaminfo: *mut FLAC__StreamMetadata,
    ) -> FLAC__bool;
}
extern "C" {
    /// Read the VORBIS_COMMENT metadata block of the given FLAC file.  This
    /// function will try to skip any ID3v2 tag at the head of the file.
    ///
    /// \param filename    The path to the FLAC file to read.
    /// \param tags        The address where the returned pointer will be
    /// stored.  The \a tags object must be deleted by
    /// the caller using FLAC__metadata_object_delete().
    /// \assert
    /// \code filename != NULL \endcode
    /// \code tags != NULL \endcode
    /// \retval FLAC__bool
    /// \c true if a valid VORBIS_COMMENT block was read from \a filename,
    /// and \a *tags will be set to the address of the metadata structure.
    /// Returns \c false if there was a memory allocation error, a file
    /// decoder error, or the file contained no VORBIS_COMMENT block, and
    /// \a *tags will be set to \c NULL.
    #[link_name = "\u{1}_FLAC__metadata_get_tags"]
    pub fn FLAC__metadata_get_tags(
        filename: *const ::std::os::raw::c_char,
        tags: *mut *mut FLAC__StreamMetadata,
    ) -> FLAC__bool;
}
extern "C" {
    /// Read the CUESHEET metadata block of the given FLAC file.  This
    /// function will try to skip any ID3v2 tag at the head of the file.
    ///
    /// \param filename    The path to the FLAC file to read.
    /// \param cuesheet    The address where the returned pointer will be
    /// stored.  The \a cuesheet object must be deleted by
    /// the caller using FLAC__metadata_object_delete().
    /// \assert
    /// \code filename != NULL \endcode
    /// \code cuesheet != NULL \endcode
    /// \retval FLAC__bool
    /// \c true if a valid CUESHEET block was read from \a filename,
    /// and \a *cuesheet will be set to the address of the metadata
    /// structure.  Returns \c false if there was a memory allocation
    /// error, a file decoder error, or the file contained no CUESHEET
    /// block, and \a *cuesheet will be set to \c NULL.
    #[link_name = "\u{1}_FLAC__metadata_get_cuesheet"]
    pub fn FLAC__metadata_get_cuesheet(
        filename: *const ::std::os::raw::c_char,
        cuesheet: *mut *mut FLAC__StreamMetadata,
    ) -> FLAC__bool;
}
extern "C" {
    /// Read a PICTURE metadata block of the given FLAC file.  This
    /// function will try to skip any ID3v2 tag at the head of the file.
    /// Since there can be more than one PICTURE block in a file, this
    /// function takes a number of parameters that act as constraints to
    /// the search.  The PICTURE block with the largest area matching all
    /// the constraints will be returned, or \a *picture will be set to
    /// \c NULL if there was no such block.
    ///
    /// \param filename    The path to the FLAC file to read.
    /// \param picture     The address where the returned pointer will be
    /// stored.  The \a picture object must be deleted by
    /// the caller using FLAC__metadata_object_delete().
    /// \param type        The desired picture type.  Use \c -1 to mean
    /// "any type".
    /// \param mime_type   The desired MIME type, e.g. "image/jpeg".  The
    /// string will be matched exactly.  Use \c NULL to
    /// mean "any MIME type".
    /// \param description The desired description.  The string will be
    /// matched exactly.  Use \c NULL to mean "any
    /// description".
    /// \param max_width   The maximum width in pixels desired.  Use
    /// \c (unsigned)(-1) to mean "any width".
    /// \param max_height  The maximum height in pixels desired.  Use
    /// \c (unsigned)(-1) to mean "any height".
    /// \param max_depth   The maximum color depth in bits-per-pixel desired.
    /// Use \c (unsigned)(-1) to mean "any depth".
    /// \param max_colors  The maximum number of colors desired.  Use
    /// \c (unsigned)(-1) to mean "any number of colors".
    /// \assert
    /// \code filename != NULL \endcode
    /// \code picture != NULL \endcode
    /// \retval FLAC__bool
    /// \c true if a valid PICTURE block was read from \a filename,
    /// and \a *picture will be set to the address of the metadata
    /// structure.  Returns \c false if there was a memory allocation
    /// error, a file decoder error, or the file contained no PICTURE
    /// block, and \a *picture will be set to \c NULL.
    #[link_name = "\u{1}_FLAC__metadata_get_picture"]
    pub fn FLAC__metadata_get_picture(
        filename: *const ::std::os::raw::c_char,
        picture: *mut *mut FLAC__StreamMetadata,
        type_: FLAC__StreamMetadata_Picture_Type,
        mime_type: *const ::std::os::raw::c_char,
        description: *const FLAC__byte,
        max_width: ::std::os::raw::c_uint,
        max_height: ::std::os::raw::c_uint,
        max_depth: ::std::os::raw::c_uint,
        max_colors: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__Metadata_SimpleIterator {
    _unused: [u8; 0],
}
pub const FLAC__Metadata_SimpleIteratorStatus_FLAC__METADATA_SIMPLE_ITERATOR_STATUS_OK:
    FLAC__Metadata_SimpleIteratorStatus = 0;
pub const FLAC__Metadata_SimpleIteratorStatus_FLAC__METADATA_SIMPLE_ITERATOR_STATUS_ILLEGAL_INPUT : FLAC__Metadata_SimpleIteratorStatus = 1 ;
pub const FLAC__Metadata_SimpleIteratorStatus_FLAC__METADATA_SIMPLE_ITERATOR_STATUS_ERROR_OPENING_FILE : FLAC__Metadata_SimpleIteratorStatus = 2 ;
pub const FLAC__Metadata_SimpleIteratorStatus_FLAC__METADATA_SIMPLE_ITERATOR_STATUS_NOT_A_FLAC_FILE : FLAC__Metadata_SimpleIteratorStatus = 3 ;
pub const FLAC__Metadata_SimpleIteratorStatus_FLAC__METADATA_SIMPLE_ITERATOR_STATUS_NOT_WRITABLE:
    FLAC__Metadata_SimpleIteratorStatus = 4;
pub const FLAC__Metadata_SimpleIteratorStatus_FLAC__METADATA_SIMPLE_ITERATOR_STATUS_BAD_METADATA:
    FLAC__Metadata_SimpleIteratorStatus = 5;
pub const FLAC__Metadata_SimpleIteratorStatus_FLAC__METADATA_SIMPLE_ITERATOR_STATUS_READ_ERROR:
    FLAC__Metadata_SimpleIteratorStatus = 6;
pub const FLAC__Metadata_SimpleIteratorStatus_FLAC__METADATA_SIMPLE_ITERATOR_STATUS_SEEK_ERROR:
    FLAC__Metadata_SimpleIteratorStatus = 7;
pub const FLAC__Metadata_SimpleIteratorStatus_FLAC__METADATA_SIMPLE_ITERATOR_STATUS_WRITE_ERROR:
    FLAC__Metadata_SimpleIteratorStatus = 8;
pub const FLAC__Metadata_SimpleIteratorStatus_FLAC__METADATA_SIMPLE_ITERATOR_STATUS_RENAME_ERROR:
    FLAC__Metadata_SimpleIteratorStatus = 9;
pub const FLAC__Metadata_SimpleIteratorStatus_FLAC__METADATA_SIMPLE_ITERATOR_STATUS_UNLINK_ERROR:
    FLAC__Metadata_SimpleIteratorStatus = 10;
pub const FLAC__Metadata_SimpleIteratorStatus_FLAC__METADATA_SIMPLE_ITERATOR_STATUS_MEMORY_ALLOCATION_ERROR : FLAC__Metadata_SimpleIteratorStatus = 11 ;
pub const FLAC__Metadata_SimpleIteratorStatus_FLAC__METADATA_SIMPLE_ITERATOR_STATUS_INTERNAL_ERROR : FLAC__Metadata_SimpleIteratorStatus = 12 ;
pub type FLAC__Metadata_SimpleIteratorStatus = u32;
extern "C" {
    #[link_name = "\u{1}_FLAC__Metadata_SimpleIteratorStatusString"]
    pub static mut FLAC__Metadata_SimpleIteratorStatusString:
        [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    /// Create a new iterator instance.
    ///
    /// \retval FLAC__Metadata_SimpleIterator*
    /// \c NULL if there was an error allocating memory, else the new instance.
    #[link_name = "\u{1}_FLAC__metadata_simple_iterator_new"]
    pub fn FLAC__metadata_simple_iterator_new() -> *mut FLAC__Metadata_SimpleIterator;
}
extern "C" {
    /// Free an iterator instance.  Deletes the object pointed to by \a iterator.
    ///
    /// \param iterator  A pointer to an existing iterator.
    /// \assert
    /// \code iterator != NULL \endcode
    #[link_name = "\u{1}_FLAC__metadata_simple_iterator_delete"]
    pub fn FLAC__metadata_simple_iterator_delete(iterator: *mut FLAC__Metadata_SimpleIterator);
}
extern "C" {
    /// Get the current status of the iterator.  Call this after a function
    /// returns \c false to get the reason for the error.  Also resets the status
    /// to FLAC__METADATA_SIMPLE_ITERATOR_STATUS_OK.
    ///
    /// \param iterator  A pointer to an existing iterator.
    /// \assert
    /// \code iterator != NULL \endcode
    /// \retval FLAC__Metadata_SimpleIteratorStatus
    /// The current status of the iterator.
    #[link_name = "\u{1}_FLAC__metadata_simple_iterator_status"]
    pub fn FLAC__metadata_simple_iterator_status(
        iterator: *mut FLAC__Metadata_SimpleIterator,
    ) -> FLAC__Metadata_SimpleIteratorStatus;
}
extern "C" {
    /// Initialize the iterator to point to the first metadata block in the
    /// given FLAC file.
    ///
    /// \param iterator             A pointer to an existing iterator.
    /// \param filename             The path to the FLAC file.
    /// \param read_only            If \c true, the FLAC file will be opened
    /// in read-only mode; if \c false, the FLAC
    /// file will be opened for edit even if no
    /// edits are performed.
    /// \param preserve_file_stats  If \c true, the owner and modification
    /// time will be preserved even if the FLAC
    /// file is written to.
    /// \assert
    /// \code iterator != NULL \endcode
    /// \code filename != NULL \endcode
    /// \retval FLAC__bool
    /// \c false if a memory allocation error occurs, the file can't be
    /// opened, or another error occurs, else \c true.
    #[link_name = "\u{1}_FLAC__metadata_simple_iterator_init"]
    pub fn FLAC__metadata_simple_iterator_init(
        iterator: *mut FLAC__Metadata_SimpleIterator,
        filename: *const ::std::os::raw::c_char,
        read_only: FLAC__bool,
        preserve_file_stats: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    /// Returns \c true if the FLAC file is writable.  If \c false, calls to
    /// FLAC__metadata_simple_iterator_set_block() and
    /// FLAC__metadata_simple_iterator_insert_block_after() will fail.
    ///
    /// \param iterator             A pointer to an existing iterator.
    /// \assert
    /// \code iterator != NULL \endcode
    /// \retval FLAC__bool
    /// See above.
    #[link_name = "\u{1}_FLAC__metadata_simple_iterator_is_writable"]
    pub fn FLAC__metadata_simple_iterator_is_writable(
        iterator: *const FLAC__Metadata_SimpleIterator,
    ) -> FLAC__bool;
}
extern "C" {
    /// Moves the iterator forward one metadata block, returning \c false if
    /// already at the end.
    ///
    /// \param iterator  A pointer to an existing initialized iterator.
    /// \assert
    /// \code iterator != NULL \endcode
    /// \a iterator has been successfully initialized with
    /// FLAC__metadata_simple_iterator_init()
    /// \retval FLAC__bool
    /// \c false if already at the last metadata block of the chain, else
    /// \c true.
    #[link_name = "\u{1}_FLAC__metadata_simple_iterator_next"]
    pub fn FLAC__metadata_simple_iterator_next(
        iterator: *mut FLAC__Metadata_SimpleIterator,
    ) -> FLAC__bool;
}
extern "C" {
    /// Moves the iterator backward one metadata block, returning \c false if
    /// already at the beginning.
    ///
    /// \param iterator  A pointer to an existing initialized iterator.
    /// \assert
    /// \code iterator != NULL \endcode
    /// \a iterator has been successfully initialized with
    /// FLAC__metadata_simple_iterator_init()
    /// \retval FLAC__bool
    /// \c false if already at the first metadata block of the chain, else
    /// \c true.
    #[link_name = "\u{1}_FLAC__metadata_simple_iterator_prev"]
    pub fn FLAC__metadata_simple_iterator_prev(
        iterator: *mut FLAC__Metadata_SimpleIterator,
    ) -> FLAC__bool;
}
extern "C" {
    /// Returns a flag telling if the current metadata block is the last.
    ///
    /// \param iterator  A pointer to an existing initialized iterator.
    /// \assert
    /// \code iterator != NULL \endcode
    /// \a iterator has been successfully initialized with
    /// FLAC__metadata_simple_iterator_init()
    /// \retval FLAC__bool
    /// \c true if the current metadata block is the last in the file,
    /// else \c false.
    #[link_name = "\u{1}_FLAC__metadata_simple_iterator_is_last"]
    pub fn FLAC__metadata_simple_iterator_is_last(
        iterator: *const FLAC__Metadata_SimpleIterator,
    ) -> FLAC__bool;
}
extern "C" {
    /// Get the offset of the metadata block at the current position.  This
    /// avoids reading the actual block data which can save time for large
    /// blocks.
    ///
    /// \param iterator  A pointer to an existing initialized iterator.
    /// \assert
    /// \code iterator != NULL \endcode
    /// \a iterator has been successfully initialized with
    /// FLAC__metadata_simple_iterator_init()
    /// \retval off_t
    /// The offset of the metadata block at the current iterator position.
    /// This is the byte offset relative to the beginning of the file of
    /// the current metadata block's header.
    #[link_name = "\u{1}_FLAC__metadata_simple_iterator_get_block_offset"]
    pub fn FLAC__metadata_simple_iterator_get_block_offset(
        iterator: *const FLAC__Metadata_SimpleIterator,
    ) -> off_t;
}
extern "C" {
    /// Get the type of the metadata block at the current position.  This
    /// avoids reading the actual block data which can save time for large
    /// blocks.
    ///
    /// \param iterator  A pointer to an existing initialized iterator.
    /// \assert
    /// \code iterator != NULL \endcode
    /// \a iterator has been successfully initialized with
    /// FLAC__metadata_simple_iterator_init()
    /// \retval FLAC__MetadataType
    /// The type of the metadata block at the current iterator position.
    #[link_name = "\u{1}_FLAC__metadata_simple_iterator_get_block_type"]
    pub fn FLAC__metadata_simple_iterator_get_block_type(
        iterator: *const FLAC__Metadata_SimpleIterator,
    ) -> FLAC__MetadataType;
}
extern "C" {
    /// Get the length of the metadata block at the current position.  This
    /// avoids reading the actual block data which can save time for large
    /// blocks.
    ///
    /// \param iterator  A pointer to an existing initialized iterator.
    /// \assert
    /// \code iterator != NULL \endcode
    /// \a iterator has been successfully initialized with
    /// FLAC__metadata_simple_iterator_init()
    /// \retval unsigned
    /// The length of the metadata block at the current iterator position.
    /// The is same length as that in the
    /// <a href="http://xiph.org/flac/format.html#metadata_block_header">metadata block header</a>,
    /// i.e. the length of the metadata body that follows the header.
    #[link_name = "\u{1}_FLAC__metadata_simple_iterator_get_block_length"]
    pub fn FLAC__metadata_simple_iterator_get_block_length(
        iterator: *const FLAC__Metadata_SimpleIterator,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    /// Get the application ID of the \c APPLICATION block at the current
    /// position.  This avoids reading the actual block data which can save
    /// time for large blocks.
    ///
    /// \param iterator  A pointer to an existing initialized iterator.
    /// \param id        A pointer to a buffer of at least \c 4 bytes where
    /// the ID will be stored.
    /// \assert
    /// \code iterator != NULL \endcode
    /// \code id != NULL \endcode
    /// \a iterator has been successfully initialized with
    /// FLAC__metadata_simple_iterator_init()
    /// \retval FLAC__bool
    /// \c true if the ID was successfully read, else \c false, in which
    /// case you should check FLAC__metadata_simple_iterator_status() to
    /// find out why.  If the status is
    /// \c FLAC__METADATA_SIMPLE_ITERATOR_STATUS_ILLEGAL_INPUT, then the
    /// current metadata block is not an \c APPLICATION block.  Otherwise
    /// if the status is
    /// \c FLAC__METADATA_SIMPLE_ITERATOR_STATUS_READ_ERROR or
    /// \c FLAC__METADATA_SIMPLE_ITERATOR_STATUS_SEEK_ERROR, an I/O error
    /// occurred and the iterator can no longer be used.
    #[link_name = "\u{1}_FLAC__metadata_simple_iterator_get_application_id"]
    pub fn FLAC__metadata_simple_iterator_get_application_id(
        iterator: *mut FLAC__Metadata_SimpleIterator,
        id: *mut FLAC__byte,
    ) -> FLAC__bool;
}
extern "C" {
    /// Get the metadata block at the current position.  You can modify the
    /// block but must use FLAC__metadata_simple_iterator_set_block() to
    /// write it back to the FLAC file.
    ///
    /// You must call FLAC__metadata_object_delete() on the returned object
    /// when you are finished with it.
    ///
    /// \param iterator  A pointer to an existing initialized iterator.
    /// \assert
    /// \code iterator != NULL \endcode
    /// \a iterator has been successfully initialized with
    /// FLAC__metadata_simple_iterator_init()
    /// \retval FLAC__StreamMetadata*
    /// The current metadata block, or \c NULL if there was a memory
    /// allocation error.
    #[link_name = "\u{1}_FLAC__metadata_simple_iterator_get_block"]
    pub fn FLAC__metadata_simple_iterator_get_block(
        iterator: *mut FLAC__Metadata_SimpleIterator,
    ) -> *mut FLAC__StreamMetadata;
}
extern "C" {
    /// Write a block back to the FLAC file.  This function tries to be
    /// as efficient as possible; how the block is actually written is
    /// shown by the following:
    ///
    /// Existing block is a STREAMINFO block and the new block is a
    /// STREAMINFO block: the new block is written in place.  Make sure
    /// you know what you're doing when changing the values of a
    /// STREAMINFO block.
    ///
    /// Existing block is a STREAMINFO block and the new block is a
    /// not a STREAMINFO block: this is an error since the first block
    /// must be a STREAMINFO block.  Returns \c false without altering the
    /// file.
    ///
    /// Existing block is not a STREAMINFO block and the new block is a
    /// STREAMINFO block: this is an error since there may be only one
    /// STREAMINFO block.  Returns \c false without altering the file.
    ///
    /// Existing block and new block are the same length: the existing
    /// block will be replaced by the new block, written in place.
    ///
    /// Existing block is longer than new block: if use_padding is \c true,
    /// the existing block will be overwritten in place with the new
    /// block followed by a PADDING block, if possible, to make the total
    /// size the same as the existing block.  Remember that a padding
    /// block requires at least four bytes so if the difference in size
    /// between the new block and existing block is less than that, the
    /// entire file will have to be rewritten, using the new block's
    /// exact size.  If use_padding is \c false, the entire file will be
    /// rewritten, replacing the existing block by the new block.
    ///
    /// Existing block is shorter than new block: if use_padding is \c true,
    /// the function will try and expand the new block into the following
    /// PADDING block, if it exists and doing so won't shrink the PADDING
    /// block to less than 4 bytes.  If there is no following PADDING
    /// block, or it will shrink to less than 4 bytes, or use_padding is
    /// \c false, the entire file is rewritten, replacing the existing block
    /// with the new block.  Note that in this case any following PADDING
    /// block is preserved as is.
    ///
    /// After writing the block, the iterator will remain in the same
    /// place, i.e. pointing to the new block.
    ///
    /// \param iterator     A pointer to an existing initialized iterator.
    /// \param block        The block to set.
    /// \param use_padding  See above.
    /// \assert
    /// \code iterator != NULL \endcode
    /// \a iterator has been successfully initialized with
    /// FLAC__metadata_simple_iterator_init()
    /// \code block != NULL \endcode
    /// \retval FLAC__bool
    /// \c true if successful, else \c false.
    #[link_name = "\u{1}_FLAC__metadata_simple_iterator_set_block"]
    pub fn FLAC__metadata_simple_iterator_set_block(
        iterator: *mut FLAC__Metadata_SimpleIterator,
        block: *mut FLAC__StreamMetadata,
        use_padding: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    /// This is similar to FLAC__metadata_simple_iterator_set_block()
    /// except that instead of writing over an existing block, it appends
    /// a block after the existing block.  \a use_padding is again used to
    /// tell the function to try an expand into following padding in an
    /// attempt to avoid rewriting the entire file.
    ///
    /// This function will fail and return \c false if given a STREAMINFO
    /// block.
    ///
    /// After writing the block, the iterator will be pointing to the
    /// new block.
    ///
    /// \param iterator     A pointer to an existing initialized iterator.
    /// \param block        The block to set.
    /// \param use_padding  See above.
    /// \assert
    /// \code iterator != NULL \endcode
    /// \a iterator has been successfully initialized with
    /// FLAC__metadata_simple_iterator_init()
    /// \code block != NULL \endcode
    /// \retval FLAC__bool
    /// \c true if successful, else \c false.
    #[link_name = "\u{1}_FLAC__metadata_simple_iterator_insert_block_after"]
    pub fn FLAC__metadata_simple_iterator_insert_block_after(
        iterator: *mut FLAC__Metadata_SimpleIterator,
        block: *mut FLAC__StreamMetadata,
        use_padding: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    /// Deletes the block at the current position.  This will cause the
    /// entire FLAC file to be rewritten, unless \a use_padding is \c true,
    /// in which case the block will be replaced by an equal-sized PADDING
    /// block.  The iterator will be left pointing to the block before the
    /// one just deleted.
    ///
    /// You may not delete the STREAMINFO block.
    ///
    /// \param iterator     A pointer to an existing initialized iterator.
    /// \param use_padding  See above.
    /// \assert
    /// \code iterator != NULL \endcode
    /// \a iterator has been successfully initialized with
    /// FLAC__metadata_simple_iterator_init()
    /// \retval FLAC__bool
    /// \c true if successful, else \c false.
    #[link_name = "\u{1}_FLAC__metadata_simple_iterator_delete_block"]
    pub fn FLAC__metadata_simple_iterator_delete_block(
        iterator: *mut FLAC__Metadata_SimpleIterator,
        use_padding: FLAC__bool,
    ) -> FLAC__bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__Metadata_Chain {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__Metadata_Iterator {
    _unused: [u8; 0],
}
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_OK: FLAC__Metadata_ChainStatus = 0;
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_ILLEGAL_INPUT:
    FLAC__Metadata_ChainStatus = 1;
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_ERROR_OPENING_FILE:
    FLAC__Metadata_ChainStatus = 2;
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_NOT_A_FLAC_FILE:
    FLAC__Metadata_ChainStatus = 3;
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_NOT_WRITABLE:
    FLAC__Metadata_ChainStatus = 4;
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_BAD_METADATA:
    FLAC__Metadata_ChainStatus = 5;
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_READ_ERROR:
    FLAC__Metadata_ChainStatus = 6;
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_SEEK_ERROR:
    FLAC__Metadata_ChainStatus = 7;
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_WRITE_ERROR:
    FLAC__Metadata_ChainStatus = 8;
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_RENAME_ERROR:
    FLAC__Metadata_ChainStatus = 9;
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_UNLINK_ERROR:
    FLAC__Metadata_ChainStatus = 10;
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_MEMORY_ALLOCATION_ERROR:
    FLAC__Metadata_ChainStatus = 11;
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_INTERNAL_ERROR:
    FLAC__Metadata_ChainStatus = 12;
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_INVALID_CALLBACKS:
    FLAC__Metadata_ChainStatus = 13;
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_READ_WRITE_MISMATCH:
    FLAC__Metadata_ChainStatus = 14;
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_WRONG_WRITE_CALL:
    FLAC__Metadata_ChainStatus = 15;
pub type FLAC__Metadata_ChainStatus = u32;
extern "C" {
    #[link_name = "\u{1}_FLAC__Metadata_ChainStatusString"]
    pub static mut FLAC__Metadata_ChainStatusString: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    /// Create a new chain instance.
    ///
    /// \retval FLAC__Metadata_Chain*
    /// \c NULL if there was an error allocating memory, else the new instance.
    #[link_name = "\u{1}_FLAC__metadata_chain_new"]
    pub fn FLAC__metadata_chain_new() -> *mut FLAC__Metadata_Chain;
}
extern "C" {
    /// Free a chain instance.  Deletes the object pointed to by \a chain.
    ///
    /// \param chain  A pointer to an existing chain.
    /// \assert
    /// \code chain != NULL \endcode
    #[link_name = "\u{1}_FLAC__metadata_chain_delete"]
    pub fn FLAC__metadata_chain_delete(chain: *mut FLAC__Metadata_Chain);
}
extern "C" {
    /// Get the current status of the chain.  Call this after a function
    /// returns \c false to get the reason for the error.  Also resets the
    /// status to FLAC__METADATA_CHAIN_STATUS_OK.
    ///
    /// \param chain    A pointer to an existing chain.
    /// \assert
    /// \code chain != NULL \endcode
    /// \retval FLAC__Metadata_ChainStatus
    /// The current status of the chain.
    #[link_name = "\u{1}_FLAC__metadata_chain_status"]
    pub fn FLAC__metadata_chain_status(
        chain: *mut FLAC__Metadata_Chain,
    ) -> FLAC__Metadata_ChainStatus;
}
extern "C" {
    /// Read all metadata from a FLAC file into the chain.
    ///
    /// \param chain    A pointer to an existing chain.
    /// \param filename The path to the FLAC file to read.
    /// \assert
    /// \code chain != NULL \endcode
    /// \code filename != NULL \endcode
    /// \retval FLAC__bool
    /// \c true if a valid list of metadata blocks was read from
    /// \a filename, else \c false.  On failure, check the status with
    /// FLAC__metadata_chain_status().
    #[link_name = "\u{1}_FLAC__metadata_chain_read"]
    pub fn FLAC__metadata_chain_read(
        chain: *mut FLAC__Metadata_Chain,
        filename: *const ::std::os::raw::c_char,
    ) -> FLAC__bool;
}
extern "C" {
    /// Read all metadata from an Ogg FLAC file into the chain.
    ///
    /// \note Ogg FLAC metadata data writing is not supported yet and
    /// FLAC__metadata_chain_write() will fail.
    ///
    /// \param chain    A pointer to an existing chain.
    /// \param filename The path to the Ogg FLAC file to read.
    /// \assert
    /// \code chain != NULL \endcode
    /// \code filename != NULL \endcode
    /// \retval FLAC__bool
    /// \c true if a valid list of metadata blocks was read from
    /// \a filename, else \c false.  On failure, check the status with
    /// FLAC__metadata_chain_status().
    #[link_name = "\u{1}_FLAC__metadata_chain_read_ogg"]
    pub fn FLAC__metadata_chain_read_ogg(
        chain: *mut FLAC__Metadata_Chain,
        filename: *const ::std::os::raw::c_char,
    ) -> FLAC__bool;
}
extern "C" {
    /// Read all metadata from a FLAC stream into the chain via I/O callbacks.
    ///
    /// The \a handle need only be open for reading, but must be seekable.
    /// The equivalent minimum stdio fopen() file mode is \c "r" (or \c "rb"
    /// for Windows).
    ///
    /// \param chain    A pointer to an existing chain.
    /// \param handle   The I/O handle of the FLAC stream to read.  The
    /// handle will NOT be closed after the metadata is read;
    /// that is the duty of the caller.
    /// \param callbacks
    /// A set of callbacks to use for I/O.  The mandatory
    /// callbacks are \a read, \a seek, and \a tell.
    /// \assert
    /// \code chain != NULL \endcode
    /// \retval FLAC__bool
    /// \c true if a valid list of metadata blocks was read from
    /// \a handle, else \c false.  On failure, check the status with
    /// FLAC__metadata_chain_status().
    #[link_name = "\u{1}_FLAC__metadata_chain_read_with_callbacks"]
    pub fn FLAC__metadata_chain_read_with_callbacks(
        chain: *mut FLAC__Metadata_Chain,
        handle: FLAC__IOHandle,
        callbacks: FLAC__IOCallbacks,
    ) -> FLAC__bool;
}
extern "C" {
    /// Read all metadata from an Ogg FLAC stream into the chain via I/O callbacks.
    ///
    /// The \a handle need only be open for reading, but must be seekable.
    /// The equivalent minimum stdio fopen() file mode is \c "r" (or \c "rb"
    /// for Windows).
    ///
    /// \note Ogg FLAC metadata data writing is not supported yet and
    /// FLAC__metadata_chain_write() will fail.
    ///
    /// \param chain    A pointer to an existing chain.
    /// \param handle   The I/O handle of the Ogg FLAC stream to read.  The
    /// handle will NOT be closed after the metadata is read;
    /// that is the duty of the caller.
    /// \param callbacks
    /// A set of callbacks to use for I/O.  The mandatory
    /// callbacks are \a read, \a seek, and \a tell.
    /// \assert
    /// \code chain != NULL \endcode
    /// \retval FLAC__bool
    /// \c true if a valid list of metadata blocks was read from
    /// \a handle, else \c false.  On failure, check the status with
    /// FLAC__metadata_chain_status().
    #[link_name = "\u{1}_FLAC__metadata_chain_read_ogg_with_callbacks"]
    pub fn FLAC__metadata_chain_read_ogg_with_callbacks(
        chain: *mut FLAC__Metadata_Chain,
        handle: FLAC__IOHandle,
        callbacks: FLAC__IOCallbacks,
    ) -> FLAC__bool;
}
extern "C" {
    /// Checks if writing the given chain would require the use of a
    /// temporary file, or if it could be written in place.
    ///
    /// Under certain conditions, padding can be utilized so that writing
    /// edited metadata back to the FLAC file does not require rewriting the
    /// entire file.  If rewriting is required, then a temporary workfile is
    /// required.  When writing metadata using callbacks, you must check
    /// this function to know whether to call
    /// FLAC__metadata_chain_write_with_callbacks() or
    /// FLAC__metadata_chain_write_with_callbacks_and_tempfile().  When
    /// writing with FLAC__metadata_chain_write(), the temporary file is
    /// handled internally.
    ///
    /// \param chain    A pointer to an existing chain.
    /// \param use_padding
    /// Whether or not padding will be allowed to be used
    /// during the write.  The value of \a use_padding given
    /// here must match the value later passed to
    /// FLAC__metadata_chain_write_with_callbacks() or
    /// FLAC__metadata_chain_write_with_callbacks_with_tempfile().
    /// \assert
    /// \code chain != NULL \endcode
    /// \retval FLAC__bool
    /// \c true if writing the current chain would require a tempfile, or
    /// \c false if metadata can be written in place.
    #[link_name = "\u{1}_FLAC__metadata_chain_check_if_tempfile_needed"]
    pub fn FLAC__metadata_chain_check_if_tempfile_needed(
        chain: *mut FLAC__Metadata_Chain,
        use_padding: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    /// Write all metadata out to the FLAC file.  This function tries to be as
    /// efficient as possible; how the metadata is actually written is shown by
    /// the following:
    ///
    /// If the current chain is the same size as the existing metadata, the new
    /// data is written in place.
    ///
    /// If the current chain is longer than the existing metadata, and
    /// \a use_padding is \c true, and the last block is a PADDING block of
    /// sufficient length, the function will truncate the final padding block
    /// so that the overall size of the metadata is the same as the existing
    /// metadata, and then just rewrite the metadata.  Otherwise, if not all of
    /// the above conditions are met, the entire FLAC file must be rewritten.
    /// If you want to use padding this way it is a good idea to call
    /// FLAC__metadata_chain_sort_padding() first so that you have the maximum
    /// amount of padding to work with, unless you need to preserve ordering
    /// of the PADDING blocks for some reason.
    ///
    /// If the current chain is shorter than the existing metadata, and
    /// \a use_padding is \c true, and the final block is a PADDING block, the padding
    /// is extended to make the overall size the same as the existing data.  If
    /// \a use_padding is \c true and the last block is not a PADDING block, a new
    /// PADDING block is added to the end of the new data to make it the same
    /// size as the existing data (if possible, see the note to
    /// FLAC__metadata_simple_iterator_set_block() about the four byte limit)
    /// and the new data is written in place.  If none of the above apply or
    /// \a use_padding is \c false, the entire FLAC file is rewritten.
    ///
    /// If \a preserve_file_stats is \c true, the owner and modification time will
    /// be preserved even if the FLAC file is written.
    ///
    /// For this write function to be used, the chain must have been read with
    /// FLAC__metadata_chain_read()/FLAC__metadata_chain_read_ogg(), not
    /// FLAC__metadata_chain_read_with_callbacks()/FLAC__metadata_chain_read_ogg_with_callbacks().
    ///
    /// \param chain               A pointer to an existing chain.
    /// \param use_padding         See above.
    /// \param preserve_file_stats See above.
    /// \assert
    /// \code chain != NULL \endcode
    /// \retval FLAC__bool
    /// \c true if the write succeeded, else \c false.  On failure,
    /// check the status with FLAC__metadata_chain_status().
    #[link_name = "\u{1}_FLAC__metadata_chain_write"]
    pub fn FLAC__metadata_chain_write(
        chain: *mut FLAC__Metadata_Chain,
        use_padding: FLAC__bool,
        preserve_file_stats: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    /// Write all metadata out to a FLAC stream via callbacks.
    ///
    /// (See FLAC__metadata_chain_write() for the details on how padding is
    /// used to write metadata in place if possible.)
    ///
    /// The \a handle must be open for updating and be seekable.  The
    /// equivalent minimum stdio fopen() file mode is \c "r+" (or \c "r+b"
    /// for Windows).
    ///
    /// For this write function to be used, the chain must have been read with
    /// FLAC__metadata_chain_read_with_callbacks()/FLAC__metadata_chain_read_ogg_with_callbacks(),
    /// not FLAC__metadata_chain_read()/FLAC__metadata_chain_read_ogg().
    /// Also, FLAC__metadata_chain_check_if_tempfile_needed() must have returned
    /// \c false.
    ///
    /// \param chain        A pointer to an existing chain.
    /// \param use_padding  See FLAC__metadata_chain_write()
    /// \param handle       The I/O handle of the FLAC stream to write.  The
    /// handle will NOT be closed after the metadata is
    /// written; that is the duty of the caller.
    /// \param callbacks    A set of callbacks to use for I/O.  The mandatory
    /// callbacks are \a write and \a seek.
    /// \assert
    /// \code chain != NULL \endcode
    /// \retval FLAC__bool
    /// \c true if the write succeeded, else \c false.  On failure,
    /// check the status with FLAC__metadata_chain_status().
    #[link_name = "\u{1}_FLAC__metadata_chain_write_with_callbacks"]
    pub fn FLAC__metadata_chain_write_with_callbacks(
        chain: *mut FLAC__Metadata_Chain,
        use_padding: FLAC__bool,
        handle: FLAC__IOHandle,
        callbacks: FLAC__IOCallbacks,
    ) -> FLAC__bool;
}
extern "C" {
    /// Write all metadata out to a FLAC stream via callbacks.
    ///
    /// (See FLAC__metadata_chain_write() for the details on how padding is
    /// used to write metadata in place if possible.)
    ///
    /// This version of the write-with-callbacks function must be used when
    /// FLAC__metadata_chain_check_if_tempfile_needed() returns true.  In
    /// this function, you must supply an I/O handle corresponding to the
    /// FLAC file to edit, and a temporary handle to which the new FLAC
    /// file will be written.  It is the caller's job to move this temporary
    /// FLAC file on top of the original FLAC file to complete the metadata
    /// edit.
    ///
    /// The \a handle must be open for reading and be seekable.  The
    /// equivalent minimum stdio fopen() file mode is \c "r" (or \c "rb"
    /// for Windows).
    ///
    /// The \a temp_handle must be open for writing.  The
    /// equivalent minimum stdio fopen() file mode is \c "w" (or \c "wb"
    /// for Windows).  It should be an empty stream, or at least positioned
    /// at the start-of-file (in which case it is the caller's duty to
    /// truncate it on return).
    ///
    /// For this write function to be used, the chain must have been read with
    /// FLAC__metadata_chain_read_with_callbacks()/FLAC__metadata_chain_read_ogg_with_callbacks(),
    /// not FLAC__metadata_chain_read()/FLAC__metadata_chain_read_ogg().
    /// Also, FLAC__metadata_chain_check_if_tempfile_needed() must have returned
    /// \c true.
    ///
    /// \param chain        A pointer to an existing chain.
    /// \param use_padding  See FLAC__metadata_chain_write()
    /// \param handle       The I/O handle of the original FLAC stream to read.
    /// The handle will NOT be closed after the metadata is
    /// written; that is the duty of the caller.
    /// \param callbacks    A set of callbacks to use for I/O on \a handle.
    /// The mandatory callbacks are \a read, \a seek, and
    /// \a eof.
    /// \param temp_handle  The I/O handle of the FLAC stream to write.  The
    /// handle will NOT be closed after the metadata is
    /// written; that is the duty of the caller.
    /// \param temp_callbacks
    /// A set of callbacks to use for I/O on temp_handle.
    /// The only mandatory callback is \a write.
    /// \assert
    /// \code chain != NULL \endcode
    /// \retval FLAC__bool
    /// \c true if the write succeeded, else \c false.  On failure,
    /// check the status with FLAC__metadata_chain_status().
    #[link_name = "\u{1}_FLAC__metadata_chain_write_with_callbacks_and_tempfile"]
    pub fn FLAC__metadata_chain_write_with_callbacks_and_tempfile(
        chain: *mut FLAC__Metadata_Chain,
        use_padding: FLAC__bool,
        handle: FLAC__IOHandle,
        callbacks: FLAC__IOCallbacks,
        temp_handle: FLAC__IOHandle,
        temp_callbacks: FLAC__IOCallbacks,
    ) -> FLAC__bool;
}
extern "C" {
    /// Merge adjacent PADDING blocks into a single block.
    ///
    /// \note This function does not write to the FLAC file, it only
    /// modifies the chain.
    ///
    /// \warning Any iterator on the current chain will become invalid after this
    /// call.  You should delete the iterator and get a new one.
    ///
    /// \param chain               A pointer to an existing chain.
    /// \assert
    /// \code chain != NULL \endcode
    #[link_name = "\u{1}_FLAC__metadata_chain_merge_padding"]
    pub fn FLAC__metadata_chain_merge_padding(chain: *mut FLAC__Metadata_Chain);
}
extern "C" {
    /// This function will move all PADDING blocks to the end on the metadata,
    /// then merge them into a single block.
    ///
    /// \note This function does not write to the FLAC file, it only
    /// modifies the chain.
    ///
    /// \warning Any iterator on the current chain will become invalid after this
    /// call.  You should delete the iterator and get a new one.
    ///
    /// \param chain  A pointer to an existing chain.
    /// \assert
    /// \code chain != NULL \endcode
    #[link_name = "\u{1}_FLAC__metadata_chain_sort_padding"]
    pub fn FLAC__metadata_chain_sort_padding(chain: *mut FLAC__Metadata_Chain);
}
extern "C" {
    /// Create a new iterator instance.
    ///
    /// \retval FLAC__Metadata_Iterator*
    /// \c NULL if there was an error allocating memory, else the new instance.
    #[link_name = "\u{1}_FLAC__metadata_iterator_new"]
    pub fn FLAC__metadata_iterator_new() -> *mut FLAC__Metadata_Iterator;
}
extern "C" {
    /// Free an iterator instance.  Deletes the object pointed to by \a iterator.
    ///
    /// \param iterator  A pointer to an existing iterator.
    /// \assert
    /// \code iterator != NULL \endcode
    #[link_name = "\u{1}_FLAC__metadata_iterator_delete"]
    pub fn FLAC__metadata_iterator_delete(iterator: *mut FLAC__Metadata_Iterator);
}
extern "C" {
    /// Initialize the iterator to point to the first metadata block in the
    /// given chain.
    ///
    /// \param iterator  A pointer to an existing iterator.
    /// \param chain     A pointer to an existing and initialized (read) chain.
    /// \assert
    /// \code iterator != NULL \endcode
    /// \code chain != NULL \endcode
    #[link_name = "\u{1}_FLAC__metadata_iterator_init"]
    pub fn FLAC__metadata_iterator_init(
        iterator: *mut FLAC__Metadata_Iterator,
        chain: *mut FLAC__Metadata_Chain,
    );
}
extern "C" {
    /// Moves the iterator forward one metadata block, returning \c false if
    /// already at the end.
    ///
    /// \param iterator  A pointer to an existing initialized iterator.
    /// \assert
    /// \code iterator != NULL \endcode
    /// \a iterator has been successfully initialized with
    /// FLAC__metadata_iterator_init()
    /// \retval FLAC__bool
    /// \c false if already at the last metadata block of the chain, else
    /// \c true.
    #[link_name = "\u{1}_FLAC__metadata_iterator_next"]
    pub fn FLAC__metadata_iterator_next(iterator: *mut FLAC__Metadata_Iterator) -> FLAC__bool;
}
extern "C" {
    /// Moves the iterator backward one metadata block, returning \c false if
    /// already at the beginning.
    ///
    /// \param iterator  A pointer to an existing initialized iterator.
    /// \assert
    /// \code iterator != NULL \endcode
    /// \a iterator has been successfully initialized with
    /// FLAC__metadata_iterator_init()
    /// \retval FLAC__bool
    /// \c false if already at the first metadata block of the chain, else
    /// \c true.
    #[link_name = "\u{1}_FLAC__metadata_iterator_prev"]
    pub fn FLAC__metadata_iterator_prev(iterator: *mut FLAC__Metadata_Iterator) -> FLAC__bool;
}
extern "C" {
    /// Get the type of the metadata block at the current position.
    ///
    /// \param iterator  A pointer to an existing initialized iterator.
    /// \assert
    /// \code iterator != NULL \endcode
    /// \a iterator has been successfully initialized with
    /// FLAC__metadata_iterator_init()
    /// \retval FLAC__MetadataType
    /// The type of the metadata block at the current iterator position.
    #[link_name = "\u{1}_FLAC__metadata_iterator_get_block_type"]
    pub fn FLAC__metadata_iterator_get_block_type(
        iterator: *const FLAC__Metadata_Iterator,
    ) -> FLAC__MetadataType;
}
extern "C" {
    /// Get the metadata block at the current position.  You can modify
    /// the block in place but must write the chain before the changes
    /// are reflected to the FLAC file.  You do not need to call
    /// FLAC__metadata_iterator_set_block() to reflect the changes;
    /// the pointer returned by FLAC__metadata_iterator_get_block()
    /// points directly into the chain.
    ///
    /// \warning
    /// Do not call FLAC__metadata_object_delete() on the returned object;
    /// to delete a block use FLAC__metadata_iterator_delete_block().
    ///
    /// \param iterator  A pointer to an existing initialized iterator.
    /// \assert
    /// \code iterator != NULL \endcode
    /// \a iterator has been successfully initialized with
    /// FLAC__metadata_iterator_init()
    /// \retval FLAC__StreamMetadata*
    /// The current metadata block.
    #[link_name = "\u{1}_FLAC__metadata_iterator_get_block"]
    pub fn FLAC__metadata_iterator_get_block(
        iterator: *mut FLAC__Metadata_Iterator,
    ) -> *mut FLAC__StreamMetadata;
}
extern "C" {
    /// Set the metadata block at the current position, replacing the existing
    /// block.  The new block passed in becomes owned by the chain and it will be
    /// deleted when the chain is deleted.
    ///
    /// \param iterator  A pointer to an existing initialized iterator.
    /// \param block     A pointer to a metadata block.
    /// \assert
    /// \code iterator != NULL \endcode
    /// \a iterator has been successfully initialized with
    /// FLAC__metadata_iterator_init()
    /// \code block != NULL \endcode
    /// \retval FLAC__bool
    /// \c false if the conditions in the above description are not met, or
    /// a memory allocation error occurs, otherwise \c true.
    #[link_name = "\u{1}_FLAC__metadata_iterator_set_block"]
    pub fn FLAC__metadata_iterator_set_block(
        iterator: *mut FLAC__Metadata_Iterator,
        block: *mut FLAC__StreamMetadata,
    ) -> FLAC__bool;
}
extern "C" {
    /// Removes the current block from the chain.  If \a replace_with_padding is
    /// \c true, the block will instead be replaced with a padding block of equal
    /// size.  You can not delete the STREAMINFO block.  The iterator will be
    /// left pointing to the block before the one just "deleted", even if
    /// \a replace_with_padding is \c true.
    ///
    /// \param iterator              A pointer to an existing initialized iterator.
    /// \param replace_with_padding  See above.
    /// \assert
    /// \code iterator != NULL \endcode
    /// \a iterator has been successfully initialized with
    /// FLAC__metadata_iterator_init()
    /// \retval FLAC__bool
    /// \c false if the conditions in the above description are not met,
    /// otherwise \c true.
    #[link_name = "\u{1}_FLAC__metadata_iterator_delete_block"]
    pub fn FLAC__metadata_iterator_delete_block(
        iterator: *mut FLAC__Metadata_Iterator,
        replace_with_padding: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    /// Insert a new block before the current block.  You cannot insert a block
    /// before the first STREAMINFO block.  You cannot insert a STREAMINFO block
    /// as there can be only one, the one that already exists at the head when you
    /// read in a chain.  The chain takes ownership of the new block and it will be
    /// deleted when the chain is deleted.  The iterator will be left pointing to
    /// the new block.
    ///
    /// \param iterator  A pointer to an existing initialized iterator.
    /// \param block     A pointer to a metadata block to insert.
    /// \assert
    /// \code iterator != NULL \endcode
    /// \a iterator has been successfully initialized with
    /// FLAC__metadata_iterator_init()
    /// \retval FLAC__bool
    /// \c false if the conditions in the above description are not met, or
    /// a memory allocation error occurs, otherwise \c true.
    #[link_name = "\u{1}_FLAC__metadata_iterator_insert_block_before"]
    pub fn FLAC__metadata_iterator_insert_block_before(
        iterator: *mut FLAC__Metadata_Iterator,
        block: *mut FLAC__StreamMetadata,
    ) -> FLAC__bool;
}
extern "C" {
    /// Insert a new block after the current block.  You cannot insert a STREAMINFO
    /// block as there can be only one, the one that already exists at the head when
    /// you read in a chain.  The chain takes ownership of the new block and it will
    /// be deleted when the chain is deleted.  The iterator will be left pointing to
    /// the new block.
    ///
    /// \param iterator  A pointer to an existing initialized iterator.
    /// \param block     A pointer to a metadata block to insert.
    /// \assert
    /// \code iterator != NULL \endcode
    /// \a iterator has been successfully initialized with
    /// FLAC__metadata_iterator_init()
    /// \retval FLAC__bool
    /// \c false if the conditions in the above description are not met, or
    /// a memory allocation error occurs, otherwise \c true.
    #[link_name = "\u{1}_FLAC__metadata_iterator_insert_block_after"]
    pub fn FLAC__metadata_iterator_insert_block_after(
        iterator: *mut FLAC__Metadata_Iterator,
        block: *mut FLAC__StreamMetadata,
    ) -> FLAC__bool;
}
extern "C" {
    /// Create a new metadata object instance of the given type.
    ///
    /// The object will be "empty"; i.e. values and data pointers will be \c 0,
    /// with the exception of FLAC__METADATA_TYPE_VORBIS_COMMENT, which will have
    /// the vendor string set (but zero comments).
    ///
    /// Do not pass in a value greater than or equal to
    /// \a FLAC__METADATA_TYPE_UNDEFINED unless you really know what you're
    /// doing.
    ///
    /// \param type  Type of object to create
    /// \retval FLAC__StreamMetadata*
    /// \c NULL if there was an error allocating memory or the type code is
    /// greater than FLAC__MAX_METADATA_TYPE_CODE, else the new instance.
    #[link_name = "\u{1}_FLAC__metadata_object_new"]
    pub fn FLAC__metadata_object_new(type_: FLAC__MetadataType) -> *mut FLAC__StreamMetadata;
}
extern "C" {
    /// Create a copy of an existing metadata object.
    ///
    /// The copy is a "deep" copy, i.e. dynamically allocated data within the
    /// object is also copied.  The caller takes ownership of the new block and
    /// is responsible for freeing it with FLAC__metadata_object_delete().
    ///
    /// \param object  Pointer to object to copy.
    /// \assert
    /// \code object != NULL \endcode
    /// \retval FLAC__StreamMetadata*
    /// \c NULL if there was an error allocating memory, else the new instance.
    #[link_name = "\u{1}_FLAC__metadata_object_clone"]
    pub fn FLAC__metadata_object_clone(
        object: *const FLAC__StreamMetadata,
    ) -> *mut FLAC__StreamMetadata;
}
extern "C" {
    /// Free a metadata object.  Deletes the object pointed to by \a object.
    ///
    /// The delete is a "deep" delete, i.e. dynamically allocated data within the
    /// object is also deleted.
    ///
    /// \param object  A pointer to an existing object.
    /// \assert
    /// \code object != NULL \endcode
    #[link_name = "\u{1}_FLAC__metadata_object_delete"]
    pub fn FLAC__metadata_object_delete(object: *mut FLAC__StreamMetadata);
}
extern "C" {
    /// Compares two metadata objects.
    ///
    /// The compare is "deep", i.e. dynamically allocated data within the
    /// object is also compared.
    ///
    /// \param block1  A pointer to an existing object.
    /// \param block2  A pointer to an existing object.
    /// \assert
    /// \code block1 != NULL \endcode
    /// \code block2 != NULL \endcode
    /// \retval FLAC__bool
    /// \c true if objects are identical, else \c false.
    #[link_name = "\u{1}_FLAC__metadata_object_is_equal"]
    pub fn FLAC__metadata_object_is_equal(
        block1: *const FLAC__StreamMetadata,
        block2: *const FLAC__StreamMetadata,
    ) -> FLAC__bool;
}
extern "C" {
    /// Sets the application data of an APPLICATION block.
    ///
    /// If \a copy is \c true, a copy of the data is stored; otherwise, the object
    /// takes ownership of the pointer.  The existing data will be freed if this
    /// function is successful, otherwise the original data will remain if \a copy
    /// is \c true and malloc() fails.
    ///
    /// \note It is safe to pass a const pointer to \a data if \a copy is \c true.
    ///
    /// \param object  A pointer to an existing APPLICATION object.
    /// \param data    A pointer to the data to set.
    /// \param length  The length of \a data in bytes.
    /// \param copy    See above.
    /// \assert
    /// \code object != NULL \endcode
    /// \code object->type == FLAC__METADATA_TYPE_APPLICATION \endcode
    /// \code (data != NULL && length > 0) ||
    /// (data == NULL && length == 0 && copy == false) \endcode
    /// \retval FLAC__bool
    /// \c false if \a copy is \c true and malloc() fails, else \c true.
    #[link_name = "\u{1}_FLAC__metadata_object_application_set_data"]
    pub fn FLAC__metadata_object_application_set_data(
        object: *mut FLAC__StreamMetadata,
        data: *mut FLAC__byte,
        length: ::std::os::raw::c_uint,
        copy: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    /// Resize the seekpoint array.
    ///
    /// If the size shrinks, elements will truncated; if it grows, new placeholder
    /// points will be added to the end.
    ///
    /// \param object          A pointer to an existing SEEKTABLE object.
    /// \param new_num_points  The desired length of the array; may be \c 0.
    /// \assert
    /// \code object != NULL \endcode
    /// \code object->type == FLAC__METADATA_TYPE_SEEKTABLE \endcode
    /// \code (object->data.seek_table.points == NULL && object->data.seek_table.num_points == 0) ||
    /// (object->data.seek_table.points != NULL && object->data.seek_table.num_points > 0) \endcode
    /// \retval FLAC__bool
    /// \c false if memory allocation error, else \c true.
    #[link_name = "\u{1}_FLAC__metadata_object_seektable_resize_points"]
    pub fn FLAC__metadata_object_seektable_resize_points(
        object: *mut FLAC__StreamMetadata,
        new_num_points: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    /// Set a seekpoint in a seektable.
    ///
    /// \param object     A pointer to an existing SEEKTABLE object.
    /// \param point_num  Index into seekpoint array to set.
    /// \param point      The point to set.
    /// \assert
    /// \code object != NULL \endcode
    /// \code object->type == FLAC__METADATA_TYPE_SEEKTABLE \endcode
    /// \code object->data.seek_table.num_points > point_num \endcode
    #[link_name = "\u{1}_FLAC__metadata_object_seektable_set_point"]
    pub fn FLAC__metadata_object_seektable_set_point(
        object: *mut FLAC__StreamMetadata,
        point_num: ::std::os::raw::c_uint,
        point: FLAC__StreamMetadata_SeekPoint,
    );
}
extern "C" {
    /// Insert a seekpoint into a seektable.
    ///
    /// \param object     A pointer to an existing SEEKTABLE object.
    /// \param point_num  Index into seekpoint array to set.
    /// \param point      The point to set.
    /// \assert
    /// \code object != NULL \endcode
    /// \code object->type == FLAC__METADATA_TYPE_SEEKTABLE \endcode
    /// \code object->data.seek_table.num_points >= point_num \endcode
    /// \retval FLAC__bool
    /// \c false if memory allocation error, else \c true.
    #[link_name = "\u{1}_FLAC__metadata_object_seektable_insert_point"]
    pub fn FLAC__metadata_object_seektable_insert_point(
        object: *mut FLAC__StreamMetadata,
        point_num: ::std::os::raw::c_uint,
        point: FLAC__StreamMetadata_SeekPoint,
    ) -> FLAC__bool;
}
extern "C" {
    /// Delete a seekpoint from a seektable.
    ///
    /// \param object     A pointer to an existing SEEKTABLE object.
    /// \param point_num  Index into seekpoint array to set.
    /// \assert
    /// \code object != NULL \endcode
    /// \code object->type == FLAC__METADATA_TYPE_SEEKTABLE \endcode
    /// \code object->data.seek_table.num_points > point_num \endcode
    /// \retval FLAC__bool
    /// \c false if memory allocation error, else \c true.
    #[link_name = "\u{1}_FLAC__metadata_object_seektable_delete_point"]
    pub fn FLAC__metadata_object_seektable_delete_point(
        object: *mut FLAC__StreamMetadata,
        point_num: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    /// Check a seektable to see if it conforms to the FLAC specification.
    /// See the format specification for limits on the contents of the
    /// seektable.
    ///
    /// \param object  A pointer to an existing SEEKTABLE object.
    /// \assert
    /// \code object != NULL \endcode
    /// \code object->type == FLAC__METADATA_TYPE_SEEKTABLE \endcode
    /// \retval FLAC__bool
    /// \c false if seek table is illegal, else \c true.
    #[link_name = "\u{1}_FLAC__metadata_object_seektable_is_legal"]
    pub fn FLAC__metadata_object_seektable_is_legal(
        object: *const FLAC__StreamMetadata,
    ) -> FLAC__bool;
}
extern "C" {
    /// Append a number of placeholder points to the end of a seek table.
    ///
    /// \note
    /// As with the other ..._seektable_template_... functions, you should
    /// call FLAC__metadata_object_seektable_template_sort() when finished
    /// to make the seek table legal.
    ///
    /// \param object  A pointer to an existing SEEKTABLE object.
    /// \param num     The number of placeholder points to append.
    /// \assert
    /// \code object != NULL \endcode
    /// \code object->type == FLAC__METADATA_TYPE_SEEKTABLE \endcode
    /// \retval FLAC__bool
    /// \c false if memory allocation fails, else \c true.
    #[link_name = "\u{1}_FLAC__metadata_object_seektable_template_append_placeholders"]
    pub fn FLAC__metadata_object_seektable_template_append_placeholders(
        object: *mut FLAC__StreamMetadata,
        num: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    /// Append a specific seek point template to the end of a seek table.
    ///
    /// \note
    /// As with the other ..._seektable_template_... functions, you should
    /// call FLAC__metadata_object_seektable_template_sort() when finished
    /// to make the seek table legal.
    ///
    /// \param object  A pointer to an existing SEEKTABLE object.
    /// \param sample_number  The sample number of the seek point template.
    /// \assert
    /// \code object != NULL \endcode
    /// \code object->type == FLAC__METADATA_TYPE_SEEKTABLE \endcode
    /// \retval FLAC__bool
    /// \c false if memory allocation fails, else \c true.
    #[link_name = "\u{1}_FLAC__metadata_object_seektable_template_append_point"]
    pub fn FLAC__metadata_object_seektable_template_append_point(
        object: *mut FLAC__StreamMetadata,
        sample_number: FLAC__uint64,
    ) -> FLAC__bool;
}
extern "C" {
    /// Append specific seek point templates to the end of a seek table.
    ///
    /// \note
    /// As with the other ..._seektable_template_... functions, you should
    /// call FLAC__metadata_object_seektable_template_sort() when finished
    /// to make the seek table legal.
    ///
    /// \param object  A pointer to an existing SEEKTABLE object.
    /// \param sample_numbers  An array of sample numbers for the seek points.
    /// \param num     The number of seek point templates to append.
    /// \assert
    /// \code object != NULL \endcode
    /// \code object->type == FLAC__METADATA_TYPE_SEEKTABLE \endcode
    /// \retval FLAC__bool
    /// \c false if memory allocation fails, else \c true.
    #[link_name = "\u{1}_FLAC__metadata_object_seektable_template_append_points"]
    pub fn FLAC__metadata_object_seektable_template_append_points(
        object: *mut FLAC__StreamMetadata,
        sample_numbers: *mut FLAC__uint64,
        num: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    /// Append a set of evenly-spaced seek point templates to the end of a
    /// seek table.
    ///
    /// \note
    /// As with the other ..._seektable_template_... functions, you should
    /// call FLAC__metadata_object_seektable_template_sort() when finished
    /// to make the seek table legal.
    ///
    /// \param object  A pointer to an existing SEEKTABLE object.
    /// \param num     The number of placeholder points to append.
    /// \param total_samples  The total number of samples to be encoded;
    /// the seekpoints will be spaced approximately
    /// \a total_samples / \a num samples apart.
    /// \assert
    /// \code object != NULL \endcode
    /// \code object->type == FLAC__METADATA_TYPE_SEEKTABLE \endcode
    /// \code total_samples > 0 \endcode
    /// \retval FLAC__bool
    /// \c false if memory allocation fails, else \c true.
    #[link_name = "\u{1}_FLAC__metadata_object_seektable_template_append_spaced_points"]
    pub fn FLAC__metadata_object_seektable_template_append_spaced_points(
        object: *mut FLAC__StreamMetadata,
        num: ::std::os::raw::c_uint,
        total_samples: FLAC__uint64,
    ) -> FLAC__bool;
}
extern "C" {
    /// Append a set of evenly-spaced seek point templates to the end of a
    /// seek table.
    ///
    /// \note
    /// As with the other ..._seektable_template_... functions, you should
    /// call FLAC__metadata_object_seektable_template_sort() when finished
    /// to make the seek table legal.
    ///
    /// \param object  A pointer to an existing SEEKTABLE object.
    /// \param samples The number of samples apart to space the placeholder
    /// points.  The first point will be at sample \c 0, the
    /// second at sample \a samples, then 2*\a samples, and
    /// so on.  As long as \a samples and \a total_samples
    /// are greater than \c 0, there will always be at least
    /// one seekpoint at sample \c 0.
    /// \param total_samples  The total number of samples to be encoded;
    /// the seekpoints will be spaced
    /// \a samples samples apart.
    /// \assert
    /// \code object != NULL \endcode
    /// \code object->type == FLAC__METADATA_TYPE_SEEKTABLE \endcode
    /// \code samples > 0 \endcode
    /// \code total_samples > 0 \endcode
    /// \retval FLAC__bool
    /// \c false if memory allocation fails, else \c true.
    #[link_name = "\u{1}_FLAC__metadata_object_seektable_template_append_spaced_points_by_samples"]
    pub fn FLAC__metadata_object_seektable_template_append_spaced_points_by_samples(
        object: *mut FLAC__StreamMetadata,
        samples: ::std::os::raw::c_uint,
        total_samples: FLAC__uint64,
    ) -> FLAC__bool;
}
extern "C" {
    /// Sort a seek table's seek points according to the format specification,
    /// removing duplicates.
    ///
    /// \param object   A pointer to a seek table to be sorted.
    /// \param compact  If \c false, behaves like FLAC__format_seektable_sort().
    /// If \c true, duplicates are deleted and the seek table is
    /// shrunk appropriately; the number of placeholder points
    /// present in the seek table will be the same after the call
    /// as before.
    /// \assert
    /// \code object != NULL \endcode
    /// \code object->type == FLAC__METADATA_TYPE_SEEKTABLE \endcode
    /// \retval FLAC__bool
    /// \c false if realloc() fails, else \c true.
    #[link_name = "\u{1}_FLAC__metadata_object_seektable_template_sort"]
    pub fn FLAC__metadata_object_seektable_template_sort(
        object: *mut FLAC__StreamMetadata,
        compact: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    /// Sets the vendor string in a VORBIS_COMMENT block.
    ///
    /// For convenience, a trailing NUL is added to the entry if it doesn't have
    /// one already.
    ///
    /// If \a copy is \c true, a copy of the entry is stored; otherwise, the object
    /// takes ownership of the \c entry.entry pointer.
    ///
    /// \note If this function returns \c false, the caller still owns the
    /// pointer.
    ///
    /// \param object  A pointer to an existing VORBIS_COMMENT object.
    /// \param entry   The entry to set the vendor string to.
    /// \param copy    See above.
    /// \assert
    /// \code object != NULL \endcode
    /// \code object->type == FLAC__METADATA_TYPE_VORBIS_COMMENT \endcode
    /// \code (entry.entry != NULL && entry.length > 0) ||
    /// (entry.entry == NULL && entry.length == 0) \endcode
    /// \retval FLAC__bool
    /// \c false if memory allocation fails or \a entry does not comply with the
    /// Vorbis comment specification, else \c true.
    #[link_name = "\u{1}_FLAC__metadata_object_vorbiscomment_set_vendor_string"]
    pub fn FLAC__metadata_object_vorbiscomment_set_vendor_string(
        object: *mut FLAC__StreamMetadata,
        entry: FLAC__StreamMetadata_VorbisComment_Entry,
        copy: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    /// Resize the comment array.
    ///
    /// If the size shrinks, elements will truncated; if it grows, new empty
    /// fields will be added to the end.
    ///
    /// \param object            A pointer to an existing VORBIS_COMMENT object.
    /// \param new_num_comments  The desired length of the array; may be \c 0.
    /// \assert
    /// \code object != NULL \endcode
    /// \code object->type == FLAC__METADATA_TYPE_VORBIS_COMMENT \endcode
    /// \code (object->data.vorbis_comment.comments == NULL && object->data.vorbis_comment.num_comments == 0) ||
    /// (object->data.vorbis_comment.comments != NULL && object->data.vorbis_comment.num_comments > 0) \endcode
    /// \retval FLAC__bool
    /// \c false if memory allocation fails, else \c true.
    #[link_name = "\u{1}_FLAC__metadata_object_vorbiscomment_resize_comments"]
    pub fn FLAC__metadata_object_vorbiscomment_resize_comments(
        object: *mut FLAC__StreamMetadata,
        new_num_comments: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    /// Sets a comment in a VORBIS_COMMENT block.
    ///
    /// For convenience, a trailing NUL is added to the entry if it doesn't have
    /// one already.
    ///
    /// If \a copy is \c true, a copy of the entry is stored; otherwise, the object
    /// takes ownership of the \c entry.entry pointer.
    ///
    /// \note If this function returns \c false, the caller still owns the
    /// pointer.
    ///
    /// \param object       A pointer to an existing VORBIS_COMMENT object.
    /// \param comment_num  Index into comment array to set.
    /// \param entry        The entry to set the comment to.
    /// \param copy         See above.
    /// \assert
    /// \code object != NULL \endcode
    /// \code object->type == FLAC__METADATA_TYPE_VORBIS_COMMENT \endcode
    /// \code comment_num < object->data.vorbis_comment.num_comments \endcode
    /// \code (entry.entry != NULL && entry.length > 0) ||
    /// (entry.entry == NULL && entry.length == 0) \endcode
    /// \retval FLAC__bool
    /// \c false if memory allocation fails or \a entry does not comply with the
    /// Vorbis comment specification, else \c true.
    #[link_name = "\u{1}_FLAC__metadata_object_vorbiscomment_set_comment"]
    pub fn FLAC__metadata_object_vorbiscomment_set_comment(
        object: *mut FLAC__StreamMetadata,
        comment_num: ::std::os::raw::c_uint,
        entry: FLAC__StreamMetadata_VorbisComment_Entry,
        copy: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    /// Insert a comment in a VORBIS_COMMENT block at the given index.
    ///
    /// For convenience, a trailing NUL is added to the entry if it doesn't have
    /// one already.
    ///
    /// If \a copy is \c true, a copy of the entry is stored; otherwise, the object
    /// takes ownership of the \c entry.entry pointer.
    ///
    /// \note If this function returns \c false, the caller still owns the
    /// pointer.
    ///
    /// \param object       A pointer to an existing VORBIS_COMMENT object.
    /// \param comment_num  The index at which to insert the comment.  The comments
    /// at and after \a comment_num move right one position.
    /// To append a comment to the end, set \a comment_num to
    /// \c object->data.vorbis_comment.num_comments .
    /// \param entry        The comment to insert.
    /// \param copy         See above.
    /// \assert
    /// \code object != NULL \endcode
    /// \code object->type == FLAC__METADATA_TYPE_VORBIS_COMMENT \endcode
    /// \code object->data.vorbis_comment.num_comments >= comment_num \endcode
    /// \code (entry.entry != NULL && entry.length > 0) ||
    /// (entry.entry == NULL && entry.length == 0 && copy == false) \endcode
    /// \retval FLAC__bool
    /// \c false if memory allocation fails or \a entry does not comply with the
    /// Vorbis comment specification, else \c true.
    #[link_name = "\u{1}_FLAC__metadata_object_vorbiscomment_insert_comment"]
    pub fn FLAC__metadata_object_vorbiscomment_insert_comment(
        object: *mut FLAC__StreamMetadata,
        comment_num: ::std::os::raw::c_uint,
        entry: FLAC__StreamMetadata_VorbisComment_Entry,
        copy: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    /// Appends a comment to a VORBIS_COMMENT block.
    ///
    /// For convenience, a trailing NUL is added to the entry if it doesn't have
    /// one already.
    ///
    /// If \a copy is \c true, a copy of the entry is stored; otherwise, the object
    /// takes ownership of the \c entry.entry pointer.
    ///
    /// \note If this function returns \c false, the caller still owns the
    /// pointer.
    ///
    /// \param object       A pointer to an existing VORBIS_COMMENT object.
    /// \param entry        The comment to insert.
    /// \param copy         See above.
    /// \assert
    /// \code object != NULL \endcode
    /// \code object->type == FLAC__METADATA_TYPE_VORBIS_COMMENT \endcode
    /// \code (entry.entry != NULL && entry.length > 0) ||
    /// (entry.entry == NULL && entry.length == 0 && copy == false) \endcode
    /// \retval FLAC__bool
    /// \c false if memory allocation fails or \a entry does not comply with the
    /// Vorbis comment specification, else \c true.
    #[link_name = "\u{1}_FLAC__metadata_object_vorbiscomment_append_comment"]
    pub fn FLAC__metadata_object_vorbiscomment_append_comment(
        object: *mut FLAC__StreamMetadata,
        entry: FLAC__StreamMetadata_VorbisComment_Entry,
        copy: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    /// Replaces comments in a VORBIS_COMMENT block with a new one.
    ///
    /// For convenience, a trailing NUL is added to the entry if it doesn't have
    /// one already.
    ///
    /// Depending on the value of \a all, either all or just the first comment
    /// whose field name(s) match the given entry's name will be replaced by the
    /// given entry.  If no comments match, \a entry will simply be appended.
    ///
    /// If \a copy is \c true, a copy of the entry is stored; otherwise, the object
    /// takes ownership of the \c entry.entry pointer.
    ///
    /// \note If this function returns \c false, the caller still owns the
    /// pointer.
    ///
    /// \param object       A pointer to an existing VORBIS_COMMENT object.
    /// \param entry        The comment to insert.
    /// \param all          If \c true, all comments whose field name matches
    /// \a entry's field name will be removed, and \a entry will
    /// be inserted at the position of the first matching
    /// comment.  If \c false, only the first comment whose
    /// field name matches \a entry's field name will be
    /// replaced with \a entry.
    /// \param copy         See above.
    /// \assert
    /// \code object != NULL \endcode
    /// \code object->type == FLAC__METADATA_TYPE_VORBIS_COMMENT \endcode
    /// \code (entry.entry != NULL && entry.length > 0) ||
    /// (entry.entry == NULL && entry.length == 0 && copy == false) \endcode
    /// \retval FLAC__bool
    /// \c false if memory allocation fails or \a entry does not comply with the
    /// Vorbis comment specification, else \c true.
    #[link_name = "\u{1}_FLAC__metadata_object_vorbiscomment_replace_comment"]
    pub fn FLAC__metadata_object_vorbiscomment_replace_comment(
        object: *mut FLAC__StreamMetadata,
        entry: FLAC__StreamMetadata_VorbisComment_Entry,
        all: FLAC__bool,
        copy: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    /// Delete a comment in a VORBIS_COMMENT block at the given index.
    ///
    /// \param object       A pointer to an existing VORBIS_COMMENT object.
    /// \param comment_num  The index of the comment to delete.
    /// \assert
    /// \code object != NULL \endcode
    /// \code object->type == FLAC__METADATA_TYPE_VORBIS_COMMENT \endcode
    /// \code object->data.vorbis_comment.num_comments > comment_num \endcode
    /// \retval FLAC__bool
    /// \c false if realloc() fails, else \c true.
    #[link_name = "\u{1}_FLAC__metadata_object_vorbiscomment_delete_comment"]
    pub fn FLAC__metadata_object_vorbiscomment_delete_comment(
        object: *mut FLAC__StreamMetadata,
        comment_num: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    /// Creates a Vorbis comment entry from NUL-terminated name and value strings.
    ///
    /// On return, the filled-in \a entry->entry pointer will point to malloc()ed
    /// memory and shall be owned by the caller.  For convenience the entry will
    /// have a terminating NUL.
    ///
    /// \param entry              A pointer to a Vorbis comment entry.  The entry's
    /// \c entry pointer should not point to allocated
    /// memory as it will be overwritten.
    /// \param field_name         The field name in ASCII, \c NUL terminated.
    /// \param field_value        The field value in UTF-8, \c NUL terminated.
    /// \assert
    /// \code entry != NULL \endcode
    /// \code field_name != NULL \endcode
    /// \code field_value != NULL \endcode
    /// \retval FLAC__bool
    /// \c false if malloc() fails, or if \a field_name or \a field_value does
    /// not comply with the Vorbis comment specification, else \c true.
    #[link_name = "\u{1}_FLAC__metadata_object_vorbiscomment_entry_from_name_value_pair"]
    pub fn FLAC__metadata_object_vorbiscomment_entry_from_name_value_pair(
        entry: *mut FLAC__StreamMetadata_VorbisComment_Entry,
        field_name: *const ::std::os::raw::c_char,
        field_value: *const ::std::os::raw::c_char,
    ) -> FLAC__bool;
}
extern "C" {
    /// Splits a Vorbis comment entry into NUL-terminated name and value strings.
    ///
    /// The returned pointers to name and value will be allocated by malloc()
    /// and shall be owned by the caller.
    ///
    /// \param entry              An existing Vorbis comment entry.
    /// \param field_name         The address of where the returned pointer to the
    /// field name will be stored.
    /// \param field_value        The address of where the returned pointer to the
    /// field value will be stored.
    /// \assert
    /// \code (entry.entry != NULL && entry.length > 0) \endcode
    /// \code memchr(entry.entry, '=', entry.length) != NULL \endcode
    /// \code field_name != NULL \endcode
    /// \code field_value != NULL \endcode
    /// \retval FLAC__bool
    /// \c false if memory allocation fails or \a entry does not comply with the
    /// Vorbis comment specification, else \c true.
    #[link_name = "\u{1}_FLAC__metadata_object_vorbiscomment_entry_to_name_value_pair"]
    pub fn FLAC__metadata_object_vorbiscomment_entry_to_name_value_pair(
        entry: FLAC__StreamMetadata_VorbisComment_Entry,
        field_name: *mut *mut ::std::os::raw::c_char,
        field_value: *mut *mut ::std::os::raw::c_char,
    ) -> FLAC__bool;
}
extern "C" {
    /// Check if the given Vorbis comment entry's field name matches the given
    /// field name.
    ///
    /// \param entry              An existing Vorbis comment entry.
    /// \param field_name         The field name to check.
    /// \param field_name_length  The length of \a field_name, not including the
    /// terminating \c NUL.
    /// \assert
    /// \code (entry.entry != NULL && entry.length > 0) \endcode
    /// \retval FLAC__bool
    /// \c true if the field names match, else \c false
    #[link_name = "\u{1}_FLAC__metadata_object_vorbiscomment_entry_matches"]
    pub fn FLAC__metadata_object_vorbiscomment_entry_matches(
        entry: FLAC__StreamMetadata_VorbisComment_Entry,
        field_name: *const ::std::os::raw::c_char,
        field_name_length: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    /// Find a Vorbis comment with the given field name.
    ///
    /// The search begins at entry number \a offset; use an offset of 0 to
    /// search from the beginning of the comment array.
    ///
    /// \param object      A pointer to an existing VORBIS_COMMENT object.
    /// \param offset      The offset into the comment array from where to start
    /// the search.
    /// \param field_name  The field name of the comment to find.
    /// \assert
    /// \code object != NULL \endcode
    /// \code object->type == FLAC__METADATA_TYPE_VORBIS_COMMENT \endcode
    /// \code field_name != NULL \endcode
    /// \retval int
    /// The offset in the comment array of the first comment whose field
    /// name matches \a field_name, or \c -1 if no match was found.
    #[link_name = "\u{1}_FLAC__metadata_object_vorbiscomment_find_entry_from"]
    pub fn FLAC__metadata_object_vorbiscomment_find_entry_from(
        object: *const FLAC__StreamMetadata,
        offset: ::std::os::raw::c_uint,
        field_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Remove first Vorbis comment matching the given field name.
    ///
    /// \param object      A pointer to an existing VORBIS_COMMENT object.
    /// \param field_name  The field name of comment to delete.
    /// \assert
    /// \code object != NULL \endcode
    /// \code object->type == FLAC__METADATA_TYPE_VORBIS_COMMENT \endcode
    /// \retval int
    /// \c -1 for memory allocation error, \c 0 for no matching entries,
    /// \c 1 for one matching entry deleted.
    #[link_name = "\u{1}_FLAC__metadata_object_vorbiscomment_remove_entry_matching"]
    pub fn FLAC__metadata_object_vorbiscomment_remove_entry_matching(
        object: *mut FLAC__StreamMetadata,
        field_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Remove all Vorbis comments matching the given field name.
    ///
    /// \param object      A pointer to an existing VORBIS_COMMENT object.
    /// \param field_name  The field name of comments to delete.
    /// \assert
    /// \code object != NULL \endcode
    /// \code object->type == FLAC__METADATA_TYPE_VORBIS_COMMENT \endcode
    /// \retval int
    /// \c -1 for memory allocation error, \c 0 for no matching entries,
    /// else the number of matching entries deleted.
    #[link_name = "\u{1}_FLAC__metadata_object_vorbiscomment_remove_entries_matching"]
    pub fn FLAC__metadata_object_vorbiscomment_remove_entries_matching(
        object: *mut FLAC__StreamMetadata,
        field_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Create a new CUESHEET track instance.
    ///
    /// The object will be "empty"; i.e. values and data pointers will be \c 0.
    ///
    /// \retval FLAC__StreamMetadata_CueSheet_Track*
    /// \c NULL if there was an error allocating memory, else the new instance.
    #[link_name = "\u{1}_FLAC__metadata_object_cuesheet_track_new"]
    pub fn FLAC__metadata_object_cuesheet_track_new() -> *mut FLAC__StreamMetadata_CueSheet_Track;
}
extern "C" {
    /// Create a copy of an existing CUESHEET track object.
    ///
    /// The copy is a "deep" copy, i.e. dynamically allocated data within the
    /// object is also copied.  The caller takes ownership of the new object and
    /// is responsible for freeing it with
    /// FLAC__metadata_object_cuesheet_track_delete().
    ///
    /// \param object  Pointer to object to copy.
    /// \assert
    /// \code object != NULL \endcode
    /// \retval FLAC__StreamMetadata_CueSheet_Track*
    /// \c NULL if there was an error allocating memory, else the new instance.
    #[link_name = "\u{1}_FLAC__metadata_object_cuesheet_track_clone"]
    pub fn FLAC__metadata_object_cuesheet_track_clone(
        object: *const FLAC__StreamMetadata_CueSheet_Track,
    ) -> *mut FLAC__StreamMetadata_CueSheet_Track;
}
extern "C" {
    /// Delete a CUESHEET track object
    ///
    /// \param object       A pointer to an existing CUESHEET track object.
    /// \assert
    /// \code object != NULL \endcode
    #[link_name = "\u{1}_FLAC__metadata_object_cuesheet_track_delete"]
    pub fn FLAC__metadata_object_cuesheet_track_delete(
        object: *mut FLAC__StreamMetadata_CueSheet_Track,
    );
}
extern "C" {
    /// Resize a track's index point array.
    ///
    /// If the size shrinks, elements will truncated; if it grows, new blank
    /// indices will be added to the end.
    ///
    /// \param object           A pointer to an existing CUESHEET object.
    /// \param track_num        The index of the track to modify.  NOTE: this is not
    /// necessarily the same as the track's \a number field.
    /// \param new_num_indices  The desired length of the array; may be \c 0.
    /// \assert
    /// \code object != NULL \endcode
    /// \code object->type == FLAC__METADATA_TYPE_CUESHEET \endcode
    /// \code object->data.cue_sheet.num_tracks > track_num \endcode
    /// \code (object->data.cue_sheet.tracks[track_num].indices == NULL && object->data.cue_sheet.tracks[track_num].num_indices == 0) ||
    /// (object->data.cue_sheet.tracks[track_num].indices != NULL && object->data.cue_sheet.tracks[track_num].num_indices > 0) \endcode
    /// \retval FLAC__bool
    /// \c false if memory allocation error, else \c true.
    #[link_name = "\u{1}_FLAC__metadata_object_cuesheet_track_resize_indices"]
    pub fn FLAC__metadata_object_cuesheet_track_resize_indices(
        object: *mut FLAC__StreamMetadata,
        track_num: ::std::os::raw::c_uint,
        new_num_indices: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    /// Insert an index point in a CUESHEET track at the given index.
    ///
    /// \param object       A pointer to an existing CUESHEET object.
    /// \param track_num    The index of the track to modify.  NOTE: this is not
    /// necessarily the same as the track's \a number field.
    /// \param index_num    The index into the track's index array at which to
    /// insert the index point.  NOTE: this is not necessarily
    /// the same as the index point's \a number field.  The
    /// indices at and after \a index_num move right one
    /// position.  To append an index point to the end, set
    /// \a index_num to
    /// \c object->data.cue_sheet.tracks[track_num].num_indices .
    /// \param index        The index point to insert.
    /// \assert
    /// \code object != NULL \endcode
    /// \code object->type == FLAC__METADATA_TYPE_CUESHEET \endcode
    /// \code object->data.cue_sheet.num_tracks > track_num \endcode
    /// \code object->data.cue_sheet.tracks[track_num].num_indices >= index_num \endcode
    /// \retval FLAC__bool
    /// \c false if realloc() fails, else \c true.
    #[link_name = "\u{1}_FLAC__metadata_object_cuesheet_track_insert_index"]
    pub fn FLAC__metadata_object_cuesheet_track_insert_index(
        object: *mut FLAC__StreamMetadata,
        track_num: ::std::os::raw::c_uint,
        index_num: ::std::os::raw::c_uint,
        index: FLAC__StreamMetadata_CueSheet_Index,
    ) -> FLAC__bool;
}
extern "C" {
    /// Insert a blank index point in a CUESHEET track at the given index.
    ///
    /// A blank index point is one in which all field values are zero.
    ///
    /// \param object       A pointer to an existing CUESHEET object.
    /// \param track_num    The index of the track to modify.  NOTE: this is not
    /// necessarily the same as the track's \a number field.
    /// \param index_num    The index into the track's index array at which to
    /// insert the index point.  NOTE: this is not necessarily
    /// the same as the index point's \a number field.  The
    /// indices at and after \a index_num move right one
    /// position.  To append an index point to the end, set
    /// \a index_num to
    /// \c object->data.cue_sheet.tracks[track_num].num_indices .
    /// \assert
    /// \code object != NULL \endcode
    /// \code object->type == FLAC__METADATA_TYPE_CUESHEET \endcode
    /// \code object->data.cue_sheet.num_tracks > track_num \endcode
    /// \code object->data.cue_sheet.tracks[track_num].num_indices >= index_num \endcode
    /// \retval FLAC__bool
    /// \c false if realloc() fails, else \c true.
    #[link_name = "\u{1}_FLAC__metadata_object_cuesheet_track_insert_blank_index"]
    pub fn FLAC__metadata_object_cuesheet_track_insert_blank_index(
        object: *mut FLAC__StreamMetadata,
        track_num: ::std::os::raw::c_uint,
        index_num: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    /// Delete an index point in a CUESHEET track at the given index.
    ///
    /// \param object       A pointer to an existing CUESHEET object.
    /// \param track_num    The index into the track array of the track to
    /// modify.  NOTE: this is not necessarily the same
    /// as the track's \a number field.
    /// \param index_num    The index into the track's index array of the index
    /// to delete.  NOTE: this is not necessarily the same
    /// as the index's \a number field.
    /// \assert
    /// \code object != NULL \endcode
    /// \code object->type == FLAC__METADATA_TYPE_CUESHEET \endcode
    /// \code object->data.cue_sheet.num_tracks > track_num \endcode
    /// \code object->data.cue_sheet.tracks[track_num].num_indices > index_num \endcode
    /// \retval FLAC__bool
    /// \c false if realloc() fails, else \c true.
    #[link_name = "\u{1}_FLAC__metadata_object_cuesheet_track_delete_index"]
    pub fn FLAC__metadata_object_cuesheet_track_delete_index(
        object: *mut FLAC__StreamMetadata,
        track_num: ::std::os::raw::c_uint,
        index_num: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    /// Resize the track array.
    ///
    /// If the size shrinks, elements will truncated; if it grows, new blank
    /// tracks will be added to the end.
    ///
    /// \param object            A pointer to an existing CUESHEET object.
    /// \param new_num_tracks    The desired length of the array; may be \c 0.
    /// \assert
    /// \code object != NULL \endcode
    /// \code object->type == FLAC__METADATA_TYPE_CUESHEET \endcode
    /// \code (object->data.cue_sheet.tracks == NULL && object->data.cue_sheet.num_tracks == 0) ||
    /// (object->data.cue_sheet.tracks != NULL && object->data.cue_sheet.num_tracks > 0) \endcode
    /// \retval FLAC__bool
    /// \c false if memory allocation error, else \c true.
    #[link_name = "\u{1}_FLAC__metadata_object_cuesheet_resize_tracks"]
    pub fn FLAC__metadata_object_cuesheet_resize_tracks(
        object: *mut FLAC__StreamMetadata,
        new_num_tracks: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    /// Sets a track in a CUESHEET block.
    ///
    /// If \a copy is \c true, a copy of the track is stored; otherwise, the object
    /// takes ownership of the \a track pointer.
    ///
    /// \param object       A pointer to an existing CUESHEET object.
    /// \param track_num    Index into track array to set.  NOTE: this is not
    /// necessarily the same as the track's \a number field.
    /// \param track        The track to set the track to.  You may safely pass in
    /// a const pointer if \a copy is \c true.
    /// \param copy         See above.
    /// \assert
    /// \code object != NULL \endcode
    /// \code object->type == FLAC__METADATA_TYPE_CUESHEET \endcode
    /// \code track_num < object->data.cue_sheet.num_tracks \endcode
    /// \code (track->indices != NULL && track->num_indices > 0) ||
    /// (track->indices == NULL && track->num_indices == 0) \endcode
    /// \retval FLAC__bool
    /// \c false if \a copy is \c true and malloc() fails, else \c true.
    #[link_name = "\u{1}_FLAC__metadata_object_cuesheet_set_track"]
    pub fn FLAC__metadata_object_cuesheet_set_track(
        object: *mut FLAC__StreamMetadata,
        track_num: ::std::os::raw::c_uint,
        track: *mut FLAC__StreamMetadata_CueSheet_Track,
        copy: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    /// Insert a track in a CUESHEET block at the given index.
    ///
    /// If \a copy is \c true, a copy of the track is stored; otherwise, the object
    /// takes ownership of the \a track pointer.
    ///
    /// \param object       A pointer to an existing CUESHEET object.
    /// \param track_num    The index at which to insert the track.  NOTE: this
    /// is not necessarily the same as the track's \a number
    /// field.  The tracks at and after \a track_num move right
    /// one position.  To append a track to the end, set
    /// \a track_num to \c object->data.cue_sheet.num_tracks .
    /// \param track        The track to insert.  You may safely pass in a const
    /// pointer if \a copy is \c true.
    /// \param copy         See above.
    /// \assert
    /// \code object != NULL \endcode
    /// \code object->type == FLAC__METADATA_TYPE_CUESHEET \endcode
    /// \code object->data.cue_sheet.num_tracks >= track_num \endcode
    /// \retval FLAC__bool
    /// \c false if \a copy is \c true and malloc() fails, else \c true.
    #[link_name = "\u{1}_FLAC__metadata_object_cuesheet_insert_track"]
    pub fn FLAC__metadata_object_cuesheet_insert_track(
        object: *mut FLAC__StreamMetadata,
        track_num: ::std::os::raw::c_uint,
        track: *mut FLAC__StreamMetadata_CueSheet_Track,
        copy: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    /// Insert a blank track in a CUESHEET block at the given index.
    ///
    /// A blank track is one in which all field values are zero.
    ///
    /// \param object       A pointer to an existing CUESHEET object.
    /// \param track_num    The index at which to insert the track.  NOTE: this
    /// is not necessarily the same as the track's \a number
    /// field.  The tracks at and after \a track_num move right
    /// one position.  To append a track to the end, set
    /// \a track_num to \c object->data.cue_sheet.num_tracks .
    /// \assert
    /// \code object != NULL \endcode
    /// \code object->type == FLAC__METADATA_TYPE_CUESHEET \endcode
    /// \code object->data.cue_sheet.num_tracks >= track_num \endcode
    /// \retval FLAC__bool
    /// \c false if \a copy is \c true and malloc() fails, else \c true.
    #[link_name = "\u{1}_FLAC__metadata_object_cuesheet_insert_blank_track"]
    pub fn FLAC__metadata_object_cuesheet_insert_blank_track(
        object: *mut FLAC__StreamMetadata,
        track_num: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    /// Delete a track in a CUESHEET block at the given index.
    ///
    /// \param object       A pointer to an existing CUESHEET object.
    /// \param track_num    The index into the track array of the track to
    /// delete.  NOTE: this is not necessarily the same
    /// as the track's \a number field.
    /// \assert
    /// \code object != NULL \endcode
    /// \code object->type == FLAC__METADATA_TYPE_CUESHEET \endcode
    /// \code object->data.cue_sheet.num_tracks > track_num \endcode
    /// \retval FLAC__bool
    /// \c false if realloc() fails, else \c true.
    #[link_name = "\u{1}_FLAC__metadata_object_cuesheet_delete_track"]
    pub fn FLAC__metadata_object_cuesheet_delete_track(
        object: *mut FLAC__StreamMetadata,
        track_num: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    /// Check a cue sheet to see if it conforms to the FLAC specification.
    /// See the format specification for limits on the contents of the
    /// cue sheet.
    ///
    /// \param object     A pointer to an existing CUESHEET object.
    /// \param check_cd_da_subset  If \c true, check CUESHEET against more
    /// stringent requirements for a CD-DA (audio) disc.
    /// \param violation  Address of a pointer to a string.  If there is a
    /// violation, a pointer to a string explanation of the
    /// violation will be returned here. \a violation may be
    /// \c NULL if you don't need the returned string.  Do not
    /// free the returned string; it will always point to static
    /// data.
    /// \assert
    /// \code object != NULL \endcode
    /// \code object->type == FLAC__METADATA_TYPE_CUESHEET \endcode
    /// \retval FLAC__bool
    /// \c false if cue sheet is illegal, else \c true.
    #[link_name = "\u{1}_FLAC__metadata_object_cuesheet_is_legal"]
    pub fn FLAC__metadata_object_cuesheet_is_legal(
        object: *const FLAC__StreamMetadata,
        check_cd_da_subset: FLAC__bool,
        violation: *mut *const ::std::os::raw::c_char,
    ) -> FLAC__bool;
}
extern "C" {
    /// Calculate and return the CDDB/freedb ID for a cue sheet.  The function
    /// assumes the cue sheet corresponds to a CD; the result is undefined
    /// if the cuesheet's is_cd bit is not set.
    ///
    /// \param object     A pointer to an existing CUESHEET object.
    /// \assert
    /// \code object != NULL \endcode
    /// \code object->type == FLAC__METADATA_TYPE_CUESHEET \endcode
    /// \retval FLAC__uint32
    /// The unsigned integer representation of the CDDB/freedb ID
    #[link_name = "\u{1}_FLAC__metadata_object_cuesheet_calculate_cddb_id"]
    pub fn FLAC__metadata_object_cuesheet_calculate_cddb_id(
        object: *const FLAC__StreamMetadata,
    ) -> FLAC__uint32;
}
extern "C" {
    /// Sets the MIME type of a PICTURE block.
    ///
    /// If \a copy is \c true, a copy of the string is stored; otherwise, the object
    /// takes ownership of the pointer.  The existing string will be freed if this
    /// function is successful, otherwise the original string will remain if \a copy
    /// is \c true and malloc() fails.
    ///
    /// \note It is safe to pass a const pointer to \a mime_type if \a copy is \c true.
    ///
    /// \param object      A pointer to an existing PICTURE object.
    /// \param mime_type   A pointer to the MIME type string.  The string must be
    /// ASCII characters 0x20-0x7e, NUL-terminated.  No validation
    /// is done.
    /// \param copy        See above.
    /// \assert
    /// \code object != NULL \endcode
    /// \code object->type == FLAC__METADATA_TYPE_PICTURE \endcode
    /// \code (mime_type != NULL) \endcode
    /// \retval FLAC__bool
    /// \c false if \a copy is \c true and malloc() fails, else \c true.
    #[link_name = "\u{1}_FLAC__metadata_object_picture_set_mime_type"]
    pub fn FLAC__metadata_object_picture_set_mime_type(
        object: *mut FLAC__StreamMetadata,
        mime_type: *mut ::std::os::raw::c_char,
        copy: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    /// Sets the description of a PICTURE block.
    ///
    /// If \a copy is \c true, a copy of the string is stored; otherwise, the object
    /// takes ownership of the pointer.  The existing string will be freed if this
    /// function is successful, otherwise the original string will remain if \a copy
    /// is \c true and malloc() fails.
    ///
    /// \note It is safe to pass a const pointer to \a description if \a copy is \c true.
    ///
    /// \param object      A pointer to an existing PICTURE object.
    /// \param description A pointer to the description string.  The string must be
    /// valid UTF-8, NUL-terminated.  No validation is done.
    /// \param copy        See above.
    /// \assert
    /// \code object != NULL \endcode
    /// \code object->type == FLAC__METADATA_TYPE_PICTURE \endcode
    /// \code (description != NULL) \endcode
    /// \retval FLAC__bool
    /// \c false if \a copy is \c true and malloc() fails, else \c true.
    #[link_name = "\u{1}_FLAC__metadata_object_picture_set_description"]
    pub fn FLAC__metadata_object_picture_set_description(
        object: *mut FLAC__StreamMetadata,
        description: *mut FLAC__byte,
        copy: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    /// Sets the picture data of a PICTURE block.
    ///
    /// If \a copy is \c true, a copy of the data is stored; otherwise, the object
    /// takes ownership of the pointer.  Also sets the \a data_length field of the
    /// metadata object to what is passed in as the \a length parameter.  The
    /// existing data will be freed if this function is successful, otherwise the
    /// original data and data_length will remain if \a copy is \c true and
    /// malloc() fails.
    ///
    /// \note It is safe to pass a const pointer to \a data if \a copy is \c true.
    ///
    /// \param object  A pointer to an existing PICTURE object.
    /// \param data    A pointer to the data to set.
    /// \param length  The length of \a data in bytes.
    /// \param copy    See above.
    /// \assert
    /// \code object != NULL \endcode
    /// \code object->type == FLAC__METADATA_TYPE_PICTURE \endcode
    /// \code (data != NULL && length > 0) ||
    /// (data == NULL && length == 0 && copy == false) \endcode
    /// \retval FLAC__bool
    /// \c false if \a copy is \c true and malloc() fails, else \c true.
    #[link_name = "\u{1}_FLAC__metadata_object_picture_set_data"]
    pub fn FLAC__metadata_object_picture_set_data(
        object: *mut FLAC__StreamMetadata,
        data: *mut FLAC__byte,
        length: FLAC__uint32,
        copy: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    /// Check a PICTURE block to see if it conforms to the FLAC specification.
    /// See the format specification for limits on the contents of the
    /// PICTURE block.
    ///
    /// \param object     A pointer to existing PICTURE block to be checked.
    /// \param violation  Address of a pointer to a string.  If there is a
    /// violation, a pointer to a string explanation of the
    /// violation will be returned here. \a violation may be
    /// \c NULL if you don't need the returned string.  Do not
    /// free the returned string; it will always point to static
    /// data.
    /// \assert
    /// \code object != NULL \endcode
    /// \code object->type == FLAC__METADATA_TYPE_PICTURE \endcode
    /// \retval FLAC__bool
    /// \c false if PICTURE block is illegal, else \c true.
    #[link_name = "\u{1}_FLAC__metadata_object_picture_is_legal"]
    pub fn FLAC__metadata_object_picture_is_legal(
        object: *const FLAC__StreamMetadata,
        violation: *mut *const ::std::os::raw::c_char,
    ) -> FLAC__bool;
}
pub type va_list = __darwin_va_list;
extern "C" {
    #[link_name = "\u{1}_renameat"]
    pub fn renameat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_renamex_np"]
    pub fn renamex_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_renameatx_np"]
    pub fn renameatx_np(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    assert_eq!(
        ::std::mem::size_of::<__sbuf>(),
        16usize,
        concat!("Size of: ", stringify!(__sbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<__sbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(__sbuf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sbuf>()))._base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sbuf>()))._size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _close: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub _read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: fpos_t,
            arg3: ::std::os::raw::c_int,
        ) -> fpos_t,
    >,
    pub _write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: fpos_t,
}
#[test]
fn bindgen_test_layout___sFILE() {
    assert_eq!(
        ::std::mem::size_of::<__sFILE>(),
        152usize,
        concat!("Size of: ", stringify!(__sFILE))
    );
    assert_eq!(
        ::std::mem::align_of::<__sFILE>(),
        8usize,
        concat!("Alignment of ", stringify!(__sFILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._r as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._w as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._file as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._bf as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_bf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._lbfsize as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lbfsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._cookie as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_cookie)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._close as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_close)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._read as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._seek as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._write as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._ub as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ub)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._extra as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_extra)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._ur as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ur)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._ubuf as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ubuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._nbuf as *const _ as usize },
        119usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_nbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._lb as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._blksize as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_offset)
        )
    );
}
pub type FILE = __sFILE;
extern "C" {
    #[link_name = "\u{1}___stdinp"]
    pub static mut __stdinp: *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}___stdoutp"]
    pub static mut __stdoutp: *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}___stderrp"]
    pub static mut __stderrp: *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}_clearerr"]
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    #[link_name = "\u{1}_fclose"]
    pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_feof"]
    pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ferror"]
    pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fflush"]
    pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fgetc"]
    pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fgetpos"]
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fgets"]
    pub fn fgets(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_fopen"]
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}_fprintf"]
    pub fn fprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fputc"]
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fputs"]
    pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fread"]
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __nitems: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_freopen"]
    pub fn freopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}_fscanf"]
    pub fn fscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fseek"]
    pub fn fseek(
        arg1: *mut FILE,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fsetpos"]
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ftell"]
    pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_fwrite"]
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __nitems: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_getc"]
    pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getchar"]
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_gets"]
    pub fn gets(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_perror"]
    pub fn perror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_printf"]
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_putc"]
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_putchar"]
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_puts"]
    pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_remove"]
    pub fn remove(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_rename"]
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_rewind"]
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    #[link_name = "\u{1}_scanf"]
    pub fn scanf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_setbuf"]
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_setvbuf"]
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sprintf"]
    pub fn sprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sscanf"]
    pub fn sscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_tmpfile"]
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}_tmpnam"]
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ungetc"]
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vfprintf"]
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vprintf"]
    pub fn vprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vsprintf"]
    pub fn vsprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ctermid"]
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_fdopen"]
    pub fn fdopen(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}_fileno"]
    pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pclose"]
    pub fn pclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_popen"]
    pub fn popen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}___srget"]
    pub fn __srget(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}___svfscanf"]
    pub fn __svfscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}___swbuf"]
    pub fn __swbuf(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_flockfile"]
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    #[link_name = "\u{1}_ftrylockfile"]
    pub fn ftrylockfile(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_funlockfile"]
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    #[link_name = "\u{1}_getc_unlocked"]
    pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getchar_unlocked"]
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_putc_unlocked"]
    pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_putchar_unlocked"]
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getw"]
    pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_putw"]
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_tempnam"]
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __prefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_fseeko"]
    pub fn fseeko(
        __stream: *mut FILE,
        __offset: off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ftello"]
    pub fn ftello(__stream: *mut FILE) -> off_t;
}
extern "C" {
    #[link_name = "\u{1}_snprintf"]
    pub fn snprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vfscanf"]
    pub fn vfscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        arg1: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vscanf"]
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        arg1: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vsnprintf"]
    pub fn vsnprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        arg1: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vsscanf"]
    pub fn vsscanf(
        __str: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        arg1: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_dprintf"]
    pub fn dprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vdprintf"]
    pub fn vdprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getdelim"]
    pub fn getdelim(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> isize;
}
extern "C" {
    #[link_name = "\u{1}_getline"]
    pub fn getline(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut usize,
        __stream: *mut FILE,
    ) -> isize;
}
extern "C" {
    #[link_name = "\u{1}_fmemopen"]
    pub fn fmemopen(
        __buf: *mut ::std::os::raw::c_void,
        __size: usize,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}_open_memstream"]
    pub fn open_memstream(
        __bufp: *mut *mut ::std::os::raw::c_char,
        __sizep: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}_sys_nerr"]
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sys_errlist"]
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "\u{1}_asprintf"]
    pub fn asprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ctermid_r"]
    pub fn ctermid_r(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_fgetln"]
    pub fn fgetln(arg1: *mut FILE, arg2: *mut usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_fmtcheck"]
    pub fn fmtcheck(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_fpurge"]
    pub fn fpurge(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_setbuffer"]
    pub fn setbuffer(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_setlinebuf"]
    pub fn setlinebuf(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vasprintf"]
    pub fn vasprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_zopen"]
    pub fn zopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}_funopen"]
    pub fn funopen(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: fpos_t,
                arg3: ::std::os::raw::c_int,
            ) -> fpos_t,
        >,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
    ) -> *mut FILE;
}
pub const FLAC__StreamDecoderState_FLAC__STREAM_DECODER_SEARCH_FOR_METADATA:
    FLAC__StreamDecoderState = 0;
pub const FLAC__StreamDecoderState_FLAC__STREAM_DECODER_READ_METADATA: FLAC__StreamDecoderState = 1;
pub const FLAC__StreamDecoderState_FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC:
    FLAC__StreamDecoderState = 2;
pub const FLAC__StreamDecoderState_FLAC__STREAM_DECODER_READ_FRAME: FLAC__StreamDecoderState = 3;
pub const FLAC__StreamDecoderState_FLAC__STREAM_DECODER_END_OF_STREAM: FLAC__StreamDecoderState = 4;
pub const FLAC__StreamDecoderState_FLAC__STREAM_DECODER_OGG_ERROR: FLAC__StreamDecoderState = 5;
pub const FLAC__StreamDecoderState_FLAC__STREAM_DECODER_SEEK_ERROR: FLAC__StreamDecoderState = 6;
pub const FLAC__StreamDecoderState_FLAC__STREAM_DECODER_ABORTED: FLAC__StreamDecoderState = 7;
pub const FLAC__StreamDecoderState_FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR:
    FLAC__StreamDecoderState = 8;
pub const FLAC__StreamDecoderState_FLAC__STREAM_DECODER_UNINITIALIZED: FLAC__StreamDecoderState = 9;
pub type FLAC__StreamDecoderState = u32;
extern "C" {
    #[link_name = "\u{1}_FLAC__StreamDecoderStateString"]
    pub static mut FLAC__StreamDecoderStateString: [*const ::std::os::raw::c_char; 0usize];
}
pub const FLAC__StreamDecoderInitStatus_FLAC__STREAM_DECODER_INIT_STATUS_OK:
    FLAC__StreamDecoderInitStatus = 0;
pub const FLAC__StreamDecoderInitStatus_FLAC__STREAM_DECODER_INIT_STATUS_UNSUPPORTED_CONTAINER:
    FLAC__StreamDecoderInitStatus = 1;
pub const FLAC__StreamDecoderInitStatus_FLAC__STREAM_DECODER_INIT_STATUS_INVALID_CALLBACKS:
    FLAC__StreamDecoderInitStatus = 2;
pub const FLAC__StreamDecoderInitStatus_FLAC__STREAM_DECODER_INIT_STATUS_MEMORY_ALLOCATION_ERROR:
    FLAC__StreamDecoderInitStatus = 3;
pub const FLAC__StreamDecoderInitStatus_FLAC__STREAM_DECODER_INIT_STATUS_ERROR_OPENING_FILE:
    FLAC__StreamDecoderInitStatus = 4;
pub const FLAC__StreamDecoderInitStatus_FLAC__STREAM_DECODER_INIT_STATUS_ALREADY_INITIALIZED:
    FLAC__StreamDecoderInitStatus = 5;
pub type FLAC__StreamDecoderInitStatus = u32;
extern "C" {
    #[link_name = "\u{1}_FLAC__StreamDecoderInitStatusString"]
    pub static mut FLAC__StreamDecoderInitStatusString: [*const ::std::os::raw::c_char; 0usize];
}
pub const FLAC__StreamDecoderReadStatus_FLAC__STREAM_DECODER_READ_STATUS_CONTINUE:
    FLAC__StreamDecoderReadStatus = 0;
pub const FLAC__StreamDecoderReadStatus_FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM:
    FLAC__StreamDecoderReadStatus = 1;
pub const FLAC__StreamDecoderReadStatus_FLAC__STREAM_DECODER_READ_STATUS_ABORT:
    FLAC__StreamDecoderReadStatus = 2;
pub type FLAC__StreamDecoderReadStatus = u32;
extern "C" {
    #[link_name = "\u{1}_FLAC__StreamDecoderReadStatusString"]
    pub static mut FLAC__StreamDecoderReadStatusString: [*const ::std::os::raw::c_char; 0usize];
}
pub const FLAC__StreamDecoderSeekStatus_FLAC__STREAM_DECODER_SEEK_STATUS_OK:
    FLAC__StreamDecoderSeekStatus = 0;
pub const FLAC__StreamDecoderSeekStatus_FLAC__STREAM_DECODER_SEEK_STATUS_ERROR:
    FLAC__StreamDecoderSeekStatus = 1;
pub const FLAC__StreamDecoderSeekStatus_FLAC__STREAM_DECODER_SEEK_STATUS_UNSUPPORTED:
    FLAC__StreamDecoderSeekStatus = 2;
pub type FLAC__StreamDecoderSeekStatus = u32;
extern "C" {
    #[link_name = "\u{1}_FLAC__StreamDecoderSeekStatusString"]
    pub static mut FLAC__StreamDecoderSeekStatusString: [*const ::std::os::raw::c_char; 0usize];
}
pub const FLAC__StreamDecoderTellStatus_FLAC__STREAM_DECODER_TELL_STATUS_OK:
    FLAC__StreamDecoderTellStatus = 0;
pub const FLAC__StreamDecoderTellStatus_FLAC__STREAM_DECODER_TELL_STATUS_ERROR:
    FLAC__StreamDecoderTellStatus = 1;
pub const FLAC__StreamDecoderTellStatus_FLAC__STREAM_DECODER_TELL_STATUS_UNSUPPORTED:
    FLAC__StreamDecoderTellStatus = 2;
pub type FLAC__StreamDecoderTellStatus = u32;
extern "C" {
    #[link_name = "\u{1}_FLAC__StreamDecoderTellStatusString"]
    pub static mut FLAC__StreamDecoderTellStatusString: [*const ::std::os::raw::c_char; 0usize];
}
pub const FLAC__StreamDecoderLengthStatus_FLAC__STREAM_DECODER_LENGTH_STATUS_OK:
    FLAC__StreamDecoderLengthStatus = 0;
pub const FLAC__StreamDecoderLengthStatus_FLAC__STREAM_DECODER_LENGTH_STATUS_ERROR:
    FLAC__StreamDecoderLengthStatus = 1;
pub const FLAC__StreamDecoderLengthStatus_FLAC__STREAM_DECODER_LENGTH_STATUS_UNSUPPORTED:
    FLAC__StreamDecoderLengthStatus = 2;
pub type FLAC__StreamDecoderLengthStatus = u32;
extern "C" {
    #[link_name = "\u{1}_FLAC__StreamDecoderLengthStatusString"]
    pub static mut FLAC__StreamDecoderLengthStatusString: [*const ::std::os::raw::c_char; 0usize];
}
pub const FLAC__StreamDecoderWriteStatus_FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE:
    FLAC__StreamDecoderWriteStatus = 0;
pub const FLAC__StreamDecoderWriteStatus_FLAC__STREAM_DECODER_WRITE_STATUS_ABORT:
    FLAC__StreamDecoderWriteStatus = 1;
pub type FLAC__StreamDecoderWriteStatus = u32;
extern "C" {
    #[link_name = "\u{1}_FLAC__StreamDecoderWriteStatusString"]
    pub static mut FLAC__StreamDecoderWriteStatusString: [*const ::std::os::raw::c_char; 0usize];
}
pub const FLAC__StreamDecoderErrorStatus_FLAC__STREAM_DECODER_ERROR_STATUS_LOST_SYNC:
    FLAC__StreamDecoderErrorStatus = 0;
pub const FLAC__StreamDecoderErrorStatus_FLAC__STREAM_DECODER_ERROR_STATUS_BAD_HEADER:
    FLAC__StreamDecoderErrorStatus = 1;
pub const FLAC__StreamDecoderErrorStatus_FLAC__STREAM_DECODER_ERROR_STATUS_FRAME_CRC_MISMATCH:
    FLAC__StreamDecoderErrorStatus = 2;
pub const FLAC__StreamDecoderErrorStatus_FLAC__STREAM_DECODER_ERROR_STATUS_UNPARSEABLE_STREAM:
    FLAC__StreamDecoderErrorStatus = 3;
pub type FLAC__StreamDecoderErrorStatus = u32;
extern "C" {
    #[link_name = "\u{1}_FLAC__StreamDecoderErrorStatusString"]
    pub static mut FLAC__StreamDecoderErrorStatusString: [*const ::std::os::raw::c_char; 0usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamDecoderProtected {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamDecoderPrivate {
    _unused: [u8; 0],
}
/// The opaque structure definition for the stream decoder type.
/// See the \link flac_stream_decoder stream decoder module \endlink
/// for a detailed description.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamDecoder {
    pub protected_: *mut FLAC__StreamDecoderProtected,
    pub private_: *mut FLAC__StreamDecoderPrivate,
}
#[test]
fn bindgen_test_layout_FLAC__StreamDecoder() {
    assert_eq!(
        ::std::mem::size_of::<FLAC__StreamDecoder>(),
        16usize,
        concat!("Size of: ", stringify!(FLAC__StreamDecoder))
    );
    assert_eq!(
        ::std::mem::align_of::<FLAC__StreamDecoder>(),
        8usize,
        concat!("Alignment of ", stringify!(FLAC__StreamDecoder))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FLAC__StreamDecoder>())).protected_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamDecoder),
            "::",
            stringify!(protected_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FLAC__StreamDecoder>())).private_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamDecoder),
            "::",
            stringify!(private_)
        )
    );
}
/// Signature for the read callback.
///
/// A function pointer matching this signature must be passed to
/// FLAC__stream_decoder_init*_stream(). The supplied function will be
/// called when the decoder needs more input data.  The address of the
/// buffer to be filled is supplied, along with the number of bytes the
/// buffer can hold.  The callback may choose to supply less data and
/// modify the byte count but must be careful not to overflow the buffer.
/// The callback then returns a status code chosen from
/// FLAC__StreamDecoderReadStatus.
///
/// Here is an example of a read callback for stdio streams:
/// \code
/// FLAC__StreamDecoderReadStatus read_cb(const FLAC__StreamDecoder *decoder, FLAC__byte buffer[], size_t *bytes, void *client_data)
/// {
/// FILE *file = ((MyClientData*)client_data)->file;
/// if(*bytes > 0) {
/// *bytes = fread(buffer, sizeof(FLAC__byte), *bytes, file);
/// if(ferror(file))
/// return FLAC__STREAM_DECODER_READ_STATUS_ABORT;
/// else if(*bytes == 0)
/// return FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM;
/// else
/// return FLAC__STREAM_DECODER_READ_STATUS_CONTINUE;
/// }
/// else
/// return FLAC__STREAM_DECODER_READ_STATUS_ABORT;
/// }
/// \endcode
///
/// \note In general, FLAC__StreamDecoder functions which change the
/// state should not be called on the \a decoder while in the callback.
///
/// \param  decoder  The decoder instance calling the callback.
/// \param  buffer   A pointer to a location for the callee to store
/// data to be decoded.
/// \param  bytes    A pointer to the size of the buffer.  On entry
/// to the callback, it contains the maximum number
/// of bytes that may be stored in \a buffer.  The
/// callee must set it to the actual number of bytes
/// stored (0 in case of error or end-of-stream) before
/// returning.
/// \param  client_data  The callee's client data set through
/// FLAC__stream_decoder_init_*().
/// \retval FLAC__StreamDecoderReadStatus
/// The callee's return status.  Note that the callback should return
/// \c FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM if and only if
/// zero bytes were read and there is no more data to be read.
pub type FLAC__StreamDecoderReadCallback = ::std::option::Option<
    unsafe extern "C" fn(
        decoder: *const FLAC__StreamDecoder,
        buffer: *mut FLAC__byte,
        bytes: *mut usize,
        client_data: *mut ::std::os::raw::c_void,
    ) -> FLAC__StreamDecoderReadStatus,
>;
/// Signature for the seek callback.
///
/// A function pointer matching this signature may be passed to
/// FLAC__stream_decoder_init*_stream().  The supplied function will be
/// called when the decoder needs to seek the input stream.  The decoder
/// will pass the absolute byte offset to seek to, 0 meaning the
/// beginning of the stream.
///
/// Here is an example of a seek callback for stdio streams:
/// \code
/// FLAC__StreamDecoderSeekStatus seek_cb(const FLAC__StreamDecoder *decoder, FLAC__uint64 absolute_byte_offset, void *client_data)
/// {
/// FILE *file = ((MyClientData*)client_data)->file;
/// if(file == stdin)
/// return FLAC__STREAM_DECODER_SEEK_STATUS_UNSUPPORTED;
/// else if(fseeko(file, (off_t)absolute_byte_offset, SEEK_SET) < 0)
/// return FLAC__STREAM_DECODER_SEEK_STATUS_ERROR;
/// else
/// return FLAC__STREAM_DECODER_SEEK_STATUS_OK;
/// }
/// \endcode
///
/// \note In general, FLAC__StreamDecoder functions which change the
/// state should not be called on the \a decoder while in the callback.
///
/// \param  decoder  The decoder instance calling the callback.
/// \param  absolute_byte_offset  The offset from the beginning of the stream
/// to seek to.
/// \param  client_data  The callee's client data set through
/// FLAC__stream_decoder_init_*().
/// \retval FLAC__StreamDecoderSeekStatus
/// The callee's return status.
pub type FLAC__StreamDecoderSeekCallback = ::std::option::Option<
    unsafe extern "C" fn(
        decoder: *const FLAC__StreamDecoder,
        absolute_byte_offset: FLAC__uint64,
        client_data: *mut ::std::os::raw::c_void,
    ) -> FLAC__StreamDecoderSeekStatus,
>;
/// Signature for the tell callback.
///
/// A function pointer matching this signature may be passed to
/// FLAC__stream_decoder_init*_stream().  The supplied function will be
/// called when the decoder wants to know the current position of the
/// stream.  The callback should return the byte offset from the
/// beginning of the stream.
///
/// Here is an example of a tell callback for stdio streams:
/// \code
/// FLAC__StreamDecoderTellStatus tell_cb(const FLAC__StreamDecoder *decoder, FLAC__uint64 *absolute_byte_offset, void *client_data)
/// {
/// FILE *file = ((MyClientData*)client_data)->file;
/// off_t pos;
/// if(file == stdin)
/// return FLAC__STREAM_DECODER_TELL_STATUS_UNSUPPORTED;
/// else if((pos = ftello(file)) < 0)
/// return FLAC__STREAM_DECODER_TELL_STATUS_ERROR;
/// else {
/// *absolute_byte_offset = (FLAC__uint64)pos;
/// return FLAC__STREAM_DECODER_TELL_STATUS_OK;
/// }
/// }
/// \endcode
///
/// \note In general, FLAC__StreamDecoder functions which change the
/// state should not be called on the \a decoder while in the callback.
///
/// \param  decoder  The decoder instance calling the callback.
/// \param  absolute_byte_offset  A pointer to storage for the current offset
/// from the beginning of the stream.
/// \param  client_data  The callee's client data set through
/// FLAC__stream_decoder_init_*().
/// \retval FLAC__StreamDecoderTellStatus
/// The callee's return status.
pub type FLAC__StreamDecoderTellCallback = ::std::option::Option<
    unsafe extern "C" fn(
        decoder: *const FLAC__StreamDecoder,
        absolute_byte_offset: *mut FLAC__uint64,
        client_data: *mut ::std::os::raw::c_void,
    ) -> FLAC__StreamDecoderTellStatus,
>;
/// Signature for the length callback.
///
/// A function pointer matching this signature may be passed to
/// FLAC__stream_decoder_init*_stream().  The supplied function will be
/// called when the decoder wants to know the total length of the stream
/// in bytes.
///
/// Here is an example of a length callback for stdio streams:
/// \code
/// FLAC__StreamDecoderLengthStatus length_cb(const FLAC__StreamDecoder *decoder, FLAC__uint64 *stream_length, void *client_data)
/// {
/// FILE *file = ((MyClientData*)client_data)->file;
/// struct stat filestats;
///
/// if(file == stdin)
/// return FLAC__STREAM_DECODER_LENGTH_STATUS_UNSUPPORTED;
/// else if(fstat(fileno(file), &filestats) != 0)
/// return FLAC__STREAM_DECODER_LENGTH_STATUS_ERROR;
/// else {
/// *stream_length = (FLAC__uint64)filestats.st_size;
/// return FLAC__STREAM_DECODER_LENGTH_STATUS_OK;
/// }
/// }
/// \endcode
///
/// \note In general, FLAC__StreamDecoder functions which change the
/// state should not be called on the \a decoder while in the callback.
///
/// \param  decoder  The decoder instance calling the callback.
/// \param  stream_length  A pointer to storage for the length of the stream
/// in bytes.
/// \param  client_data  The callee's client data set through
/// FLAC__stream_decoder_init_*().
/// \retval FLAC__StreamDecoderLengthStatus
/// The callee's return status.
pub type FLAC__StreamDecoderLengthCallback = ::std::option::Option<
    unsafe extern "C" fn(
        decoder: *const FLAC__StreamDecoder,
        stream_length: *mut FLAC__uint64,
        client_data: *mut ::std::os::raw::c_void,
    ) -> FLAC__StreamDecoderLengthStatus,
>;
/// Signature for the EOF callback.
///
/// A function pointer matching this signature may be passed to
/// FLAC__stream_decoder_init*_stream().  The supplied function will be
/// called when the decoder needs to know if the end of the stream has
/// been reached.
///
/// Here is an example of a EOF callback for stdio streams:
/// FLAC__bool eof_cb(const FLAC__StreamDecoder *decoder, void *client_data)
/// \code
/// {
/// FILE *file = ((MyClientData*)client_data)->file;
/// return feof(file)? true : false;
/// }
/// \endcode
///
/// \note In general, FLAC__StreamDecoder functions which change the
/// state should not be called on the \a decoder while in the callback.
///
/// \param  decoder  The decoder instance calling the callback.
/// \param  client_data  The callee's client data set through
/// FLAC__stream_decoder_init_*().
/// \retval FLAC__bool
/// \c true if the currently at the end of the stream, else \c false.
pub type FLAC__StreamDecoderEofCallback = ::std::option::Option<
    unsafe extern "C" fn(
        decoder: *const FLAC__StreamDecoder,
        client_data: *mut ::std::os::raw::c_void,
    ) -> FLAC__bool,
>;
/// Signature for the write callback.
///
/// A function pointer matching this signature must be passed to one of
/// the FLAC__stream_decoder_init_*() functions.
/// The supplied function will be called when the decoder has decoded a
/// single audio frame.  The decoder will pass the frame metadata as well
/// as an array of pointers (one for each channel) pointing to the
/// decoded audio.
///
/// \note In general, FLAC__StreamDecoder functions which change the
/// state should not be called on the \a decoder while in the callback.
///
/// \param  decoder  The decoder instance calling the callback.
/// \param  frame    The description of the decoded frame.  See
/// FLAC__Frame.
/// \param  buffer   An array of pointers to decoded channels of data.
/// Each pointer will point to an array of signed
/// samples of length \a frame->header.blocksize.
/// Channels will be ordered according to the FLAC
/// specification; see the documentation for the
/// <A HREF="../format.html#frame_header">frame header</A>.
/// \param  client_data  The callee's client data set through
/// FLAC__stream_decoder_init_*().
/// \retval FLAC__StreamDecoderWriteStatus
/// The callee's return status.
pub type FLAC__StreamDecoderWriteCallback = ::std::option::Option<
    unsafe extern "C" fn(
        decoder: *const FLAC__StreamDecoder,
        frame: *const FLAC__Frame,
        buffer: *const *const FLAC__int32,
        client_data: *mut ::std::os::raw::c_void,
    ) -> FLAC__StreamDecoderWriteStatus,
>;
/// Signature for the metadata callback.
///
/// A function pointer matching this signature must be passed to one of
/// the FLAC__stream_decoder_init_*() functions.
/// The supplied function will be called when the decoder has decoded a
/// metadata block.  In a valid FLAC file there will always be one
/// \c STREAMINFO block, followed by zero or more other metadata blocks.
/// These will be supplied by the decoder in the same order as they
/// appear in the stream and always before the first audio frame (i.e.
/// write callback).  The metadata block that is passed in must not be
/// modified, and it doesn't live beyond the callback, so you should make
/// a copy of it with FLAC__metadata_object_clone() if you will need it
/// elsewhere.  Since metadata blocks can potentially be large, by
/// default the decoder only calls the metadata callback for the
/// \c STREAMINFO block; you can instruct the decoder to pass or filter
/// other blocks with FLAC__stream_decoder_set_metadata_*() calls.
///
/// \note In general, FLAC__StreamDecoder functions which change the
/// state should not be called on the \a decoder while in the callback.
///
/// \param  decoder  The decoder instance calling the callback.
/// \param  metadata The decoded metadata block.
/// \param  client_data  The callee's client data set through
/// FLAC__stream_decoder_init_*().
pub type FLAC__StreamDecoderMetadataCallback = ::std::option::Option<
    unsafe extern "C" fn(
        decoder: *const FLAC__StreamDecoder,
        metadata: *const FLAC__StreamMetadata,
        client_data: *mut ::std::os::raw::c_void,
    ),
>;
/// Signature for the error callback.
///
/// A function pointer matching this signature must be passed to one of
/// the FLAC__stream_decoder_init_*() functions.
/// The supplied function will be called whenever an error occurs during
/// decoding.
///
/// \note In general, FLAC__StreamDecoder functions which change the
/// state should not be called on the \a decoder while in the callback.
///
/// \param  decoder  The decoder instance calling the callback.
/// \param  status   The error encountered by the decoder.
/// \param  client_data  The callee's client data set through
/// FLAC__stream_decoder_init_*().
pub type FLAC__StreamDecoderErrorCallback = ::std::option::Option<
    unsafe extern "C" fn(
        decoder: *const FLAC__StreamDecoder,
        status: FLAC__StreamDecoderErrorStatus,
        client_data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    /// Create a new stream decoder instance.  The instance is created with
    /// default settings; see the individual FLAC__stream_decoder_set_*()
    /// functions for each setting's default.
    ///
    /// \retval FLAC__StreamDecoder*
    /// \c NULL if there was an error allocating memory, else the new instance.
    #[link_name = "\u{1}_FLAC__stream_decoder_new"]
    pub fn FLAC__stream_decoder_new() -> *mut FLAC__StreamDecoder;
}
extern "C" {
    /// Free a decoder instance.  Deletes the object pointed to by \a decoder.
    ///
    /// \param decoder  A pointer to an existing decoder.
    /// \assert
    /// \code decoder != NULL \endcode
    #[link_name = "\u{1}_FLAC__stream_decoder_delete"]
    pub fn FLAC__stream_decoder_delete(decoder: *mut FLAC__StreamDecoder);
}
extern "C" {
    /// Set the serial number for the FLAC stream within the Ogg container.
    /// The default behavior is to use the serial number of the first Ogg
    /// page.  Setting a serial number here will explicitly specify which
    /// stream is to be decoded.
    ///
    /// \note
    /// This does not need to be set for native FLAC decoding.
    ///
    /// \default \c use serial number of first page
    /// \param  decoder        A decoder instance to set.
    /// \param  serial_number  See above.
    /// \assert
    /// \code decoder != NULL \endcode
    /// \retval FLAC__bool
    /// \c false if the decoder is already initialized, else \c true.
    #[link_name = "\u{1}_FLAC__stream_decoder_set_ogg_serial_number"]
    pub fn FLAC__stream_decoder_set_ogg_serial_number(
        decoder: *mut FLAC__StreamDecoder,
        serial_number: ::std::os::raw::c_long,
    ) -> FLAC__bool;
}
extern "C" {
    /// Set the "MD5 signature checking" flag.  If \c true, the decoder will
    /// compute the MD5 signature of the unencoded audio data while decoding
    /// and compare it to the signature from the STREAMINFO block, if it
    /// exists, during FLAC__stream_decoder_finish().
    ///
    /// MD5 signature checking will be turned off (until the next
    /// FLAC__stream_decoder_reset()) if there is no signature in the
    /// STREAMINFO block or when a seek is attempted.
    ///
    /// Clients that do not use the MD5 check should leave this off to speed
    /// up decoding.
    ///
    /// \default \c false
    /// \param  decoder  A decoder instance to set.
    /// \param  value    Flag value (see above).
    /// \assert
    /// \code decoder != NULL \endcode
    /// \retval FLAC__bool
    /// \c false if the decoder is already initialized, else \c true.
    #[link_name = "\u{1}_FLAC__stream_decoder_set_md5_checking"]
    pub fn FLAC__stream_decoder_set_md5_checking(
        decoder: *mut FLAC__StreamDecoder,
        value: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    /// Direct the decoder to pass on all metadata blocks of type \a type.
    ///
    /// \default By default, only the \c STREAMINFO block is returned via the
    /// metadata callback.
    /// \param  decoder  A decoder instance to set.
    /// \param  type     See above.
    /// \assert
    /// \code decoder != NULL \endcode
    /// \a type is valid
    /// \retval FLAC__bool
    /// \c false if the decoder is already initialized, else \c true.
    #[link_name = "\u{1}_FLAC__stream_decoder_set_metadata_respond"]
    pub fn FLAC__stream_decoder_set_metadata_respond(
        decoder: *mut FLAC__StreamDecoder,
        type_: FLAC__MetadataType,
    ) -> FLAC__bool;
}
extern "C" {
    /// Direct the decoder to pass on all APPLICATION metadata blocks of the
    /// given \a id.
    ///
    /// \default By default, only the \c STREAMINFO block is returned via the
    /// metadata callback.
    /// \param  decoder  A decoder instance to set.
    /// \param  id       See above.
    /// \assert
    /// \code decoder != NULL \endcode
    /// \code id != NULL \endcode
    /// \retval FLAC__bool
    /// \c false if the decoder is already initialized, else \c true.
    #[link_name = "\u{1}_FLAC__stream_decoder_set_metadata_respond_application"]
    pub fn FLAC__stream_decoder_set_metadata_respond_application(
        decoder: *mut FLAC__StreamDecoder,
        id: *const FLAC__byte,
    ) -> FLAC__bool;
}
extern "C" {
    /// Direct the decoder to pass on all metadata blocks of any type.
    ///
    /// \default By default, only the \c STREAMINFO block is returned via the
    /// metadata callback.
    /// \param  decoder  A decoder instance to set.
    /// \assert
    /// \code decoder != NULL \endcode
    /// \retval FLAC__bool
    /// \c false if the decoder is already initialized, else \c true.
    #[link_name = "\u{1}_FLAC__stream_decoder_set_metadata_respond_all"]
    pub fn FLAC__stream_decoder_set_metadata_respond_all(
        decoder: *mut FLAC__StreamDecoder,
    ) -> FLAC__bool;
}
extern "C" {
    /// Direct the decoder to filter out all metadata blocks of type \a type.
    ///
    /// \default By default, only the \c STREAMINFO block is returned via the
    /// metadata callback.
    /// \param  decoder  A decoder instance to set.
    /// \param  type     See above.
    /// \assert
    /// \code decoder != NULL \endcode
    /// \a type is valid
    /// \retval FLAC__bool
    /// \c false if the decoder is already initialized, else \c true.
    #[link_name = "\u{1}_FLAC__stream_decoder_set_metadata_ignore"]
    pub fn FLAC__stream_decoder_set_metadata_ignore(
        decoder: *mut FLAC__StreamDecoder,
        type_: FLAC__MetadataType,
    ) -> FLAC__bool;
}
extern "C" {
    /// Direct the decoder to filter out all APPLICATION metadata blocks of
    /// the given \a id.
    ///
    /// \default By default, only the \c STREAMINFO block is returned via the
    /// metadata callback.
    /// \param  decoder  A decoder instance to set.
    /// \param  id       See above.
    /// \assert
    /// \code decoder != NULL \endcode
    /// \code id != NULL \endcode
    /// \retval FLAC__bool
    /// \c false if the decoder is already initialized, else \c true.
    #[link_name = "\u{1}_FLAC__stream_decoder_set_metadata_ignore_application"]
    pub fn FLAC__stream_decoder_set_metadata_ignore_application(
        decoder: *mut FLAC__StreamDecoder,
        id: *const FLAC__byte,
    ) -> FLAC__bool;
}
extern "C" {
    /// Direct the decoder to filter out all metadata blocks of any type.
    ///
    /// \default By default, only the \c STREAMINFO block is returned via the
    /// metadata callback.
    /// \param  decoder  A decoder instance to set.
    /// \assert
    /// \code decoder != NULL \endcode
    /// \retval FLAC__bool
    /// \c false if the decoder is already initialized, else \c true.
    #[link_name = "\u{1}_FLAC__stream_decoder_set_metadata_ignore_all"]
    pub fn FLAC__stream_decoder_set_metadata_ignore_all(
        decoder: *mut FLAC__StreamDecoder,
    ) -> FLAC__bool;
}
extern "C" {
    /// Get the current decoder state.
    ///
    /// \param  decoder  A decoder instance to query.
    /// \assert
    /// \code decoder != NULL \endcode
    /// \retval FLAC__StreamDecoderState
    /// The current decoder state.
    #[link_name = "\u{1}_FLAC__stream_decoder_get_state"]
    pub fn FLAC__stream_decoder_get_state(
        decoder: *const FLAC__StreamDecoder,
    ) -> FLAC__StreamDecoderState;
}
extern "C" {
    /// Get the current decoder state as a C string.
    ///
    /// \param  decoder  A decoder instance to query.
    /// \assert
    /// \code decoder != NULL \endcode
    /// \retval const char *
    /// The decoder state as a C string.  Do not modify the contents.
    #[link_name = "\u{1}_FLAC__stream_decoder_get_resolved_state_string"]
    pub fn FLAC__stream_decoder_get_resolved_state_string(
        decoder: *const FLAC__StreamDecoder,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Get the "MD5 signature checking" flag.
    /// This is the value of the setting, not whether or not the decoder is
    /// currently checking the MD5 (remember, it can be turned off automatically
    /// by a seek).  When the decoder is reset the flag will be restored to the
    /// value returned by this function.
    ///
    /// \param  decoder  A decoder instance to query.
    /// \assert
    /// \code decoder != NULL \endcode
    /// \retval FLAC__bool
    /// See above.
    #[link_name = "\u{1}_FLAC__stream_decoder_get_md5_checking"]
    pub fn FLAC__stream_decoder_get_md5_checking(decoder: *const FLAC__StreamDecoder)
        -> FLAC__bool;
}
extern "C" {
    /// Get the total number of samples in the stream being decoded.
    /// Will only be valid after decoding has started and will contain the
    /// value from the \c STREAMINFO block.  A value of \c 0 means "unknown".
    ///
    /// \param  decoder  A decoder instance to query.
    /// \assert
    /// \code decoder != NULL \endcode
    /// \retval unsigned
    /// See above.
    #[link_name = "\u{1}_FLAC__stream_decoder_get_total_samples"]
    pub fn FLAC__stream_decoder_get_total_samples(
        decoder: *const FLAC__StreamDecoder,
    ) -> FLAC__uint64;
}
extern "C" {
    /// Get the current number of channels in the stream being decoded.
    /// Will only be valid after decoding has started and will contain the
    /// value from the most recently decoded frame header.
    ///
    /// \param  decoder  A decoder instance to query.
    /// \assert
    /// \code decoder != NULL \endcode
    /// \retval unsigned
    /// See above.
    #[link_name = "\u{1}_FLAC__stream_decoder_get_channels"]
    pub fn FLAC__stream_decoder_get_channels(
        decoder: *const FLAC__StreamDecoder,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    /// Get the current channel assignment in the stream being decoded.
    /// Will only be valid after decoding has started and will contain the
    /// value from the most recently decoded frame header.
    ///
    /// \param  decoder  A decoder instance to query.
    /// \assert
    /// \code decoder != NULL \endcode
    /// \retval FLAC__ChannelAssignment
    /// See above.
    #[link_name = "\u{1}_FLAC__stream_decoder_get_channel_assignment"]
    pub fn FLAC__stream_decoder_get_channel_assignment(
        decoder: *const FLAC__StreamDecoder,
    ) -> FLAC__ChannelAssignment;
}
extern "C" {
    /// Get the current sample resolution in the stream being decoded.
    /// Will only be valid after decoding has started and will contain the
    /// value from the most recently decoded frame header.
    ///
    /// \param  decoder  A decoder instance to query.
    /// \assert
    /// \code decoder != NULL \endcode
    /// \retval unsigned
    /// See above.
    #[link_name = "\u{1}_FLAC__stream_decoder_get_bits_per_sample"]
    pub fn FLAC__stream_decoder_get_bits_per_sample(
        decoder: *const FLAC__StreamDecoder,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    /// Get the current sample rate in Hz of the stream being decoded.
    /// Will only be valid after decoding has started and will contain the
    /// value from the most recently decoded frame header.
    ///
    /// \param  decoder  A decoder instance to query.
    /// \assert
    /// \code decoder != NULL \endcode
    /// \retval unsigned
    /// See above.
    #[link_name = "\u{1}_FLAC__stream_decoder_get_sample_rate"]
    pub fn FLAC__stream_decoder_get_sample_rate(
        decoder: *const FLAC__StreamDecoder,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    /// Get the current blocksize of the stream being decoded.
    /// Will only be valid after decoding has started and will contain the
    /// value from the most recently decoded frame header.
    ///
    /// \param  decoder  A decoder instance to query.
    /// \assert
    /// \code decoder != NULL \endcode
    /// \retval unsigned
    /// See above.
    #[link_name = "\u{1}_FLAC__stream_decoder_get_blocksize"]
    pub fn FLAC__stream_decoder_get_blocksize(
        decoder: *const FLAC__StreamDecoder,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    /// Returns the decoder's current read position within the stream.
    /// The position is the byte offset from the start of the stream.
    /// Bytes before this position have been fully decoded.  Note that
    /// there may still be undecoded bytes in the decoder's read FIFO.
    /// The returned position is correct even after a seek.
    ///
    /// \warning This function currently only works for native FLAC,
    /// not Ogg FLAC streams.
    ///
    /// \param  decoder   A decoder instance to query.
    /// \param  position  Address at which to return the desired position.
    /// \assert
    /// \code decoder != NULL \endcode
    /// \code position != NULL \endcode
    /// \retval FLAC__bool
    /// \c true if successful, \c false if the stream is not native FLAC,
    /// or there was an error from the 'tell' callback or it returned
    /// \c FLAC__STREAM_DECODER_TELL_STATUS_UNSUPPORTED.
    #[link_name = "\u{1}_FLAC__stream_decoder_get_decode_position"]
    pub fn FLAC__stream_decoder_get_decode_position(
        decoder: *const FLAC__StreamDecoder,
        position: *mut FLAC__uint64,
    ) -> FLAC__bool;
}
extern "C" {
    /// Initialize the decoder instance to decode native FLAC streams.
    ///
    /// This flavor of initialization sets up the decoder to decode from a
    /// native FLAC stream. I/O is performed via callbacks to the client.
    /// For decoding from a plain file via filename or open FILE*,
    /// FLAC__stream_decoder_init_file() and FLAC__stream_decoder_init_FILE()
    /// provide a simpler interface.
    ///
    /// This function should be called after FLAC__stream_decoder_new() and
    /// FLAC__stream_decoder_set_*() but before any of the
    /// FLAC__stream_decoder_process_*() functions.  Will set and return the
    /// decoder state, which will be FLAC__STREAM_DECODER_SEARCH_FOR_METADATA
    /// if initialization succeeded.
    ///
    /// \param  decoder            An uninitialized decoder instance.
    /// \param  read_callback      See FLAC__StreamDecoderReadCallback.  This
    /// pointer must not be \c NULL.
    /// \param  seek_callback      See FLAC__StreamDecoderSeekCallback.  This
    /// pointer may be \c NULL if seeking is not
    /// supported.  If \a seek_callback is not \c NULL then a
    /// \a tell_callback, \a length_callback, and \a eof_callback must also be supplied.
    /// Alternatively, a dummy seek callback that just
    /// returns \c FLAC__STREAM_DECODER_SEEK_STATUS_UNSUPPORTED
    /// may also be supplied, all though this is slightly
    /// less efficient for the decoder.
    /// \param  tell_callback      See FLAC__StreamDecoderTellCallback.  This
    /// pointer may be \c NULL if not supported by the client.  If
    /// \a seek_callback is not \c NULL then a
    /// \a tell_callback must also be supplied.
    /// Alternatively, a dummy tell callback that just
    /// returns \c FLAC__STREAM_DECODER_TELL_STATUS_UNSUPPORTED
    /// may also be supplied, all though this is slightly
    /// less efficient for the decoder.
    /// \param  length_callback    See FLAC__StreamDecoderLengthCallback.  This
    /// pointer may be \c NULL if not supported by the client.  If
    /// \a seek_callback is not \c NULL then a
    /// \a length_callback must also be supplied.
    /// Alternatively, a dummy length callback that just
    /// returns \c FLAC__STREAM_DECODER_LENGTH_STATUS_UNSUPPORTED
    /// may also be supplied, all though this is slightly
    /// less efficient for the decoder.
    /// \param  eof_callback       See FLAC__StreamDecoderEofCallback.  This
    /// pointer may be \c NULL if not supported by the client.  If
    /// \a seek_callback is not \c NULL then a
    /// \a eof_callback must also be supplied.
    /// Alternatively, a dummy length callback that just
    /// returns \c false
    /// may also be supplied, all though this is slightly
    /// less efficient for the decoder.
    /// \param  write_callback     See FLAC__StreamDecoderWriteCallback.  This
    /// pointer must not be \c NULL.
    /// \param  metadata_callback  See FLAC__StreamDecoderMetadataCallback.  This
    /// pointer may be \c NULL if the callback is not
    /// desired.
    /// \param  error_callback     See FLAC__StreamDecoderErrorCallback.  This
    /// pointer must not be \c NULL.
    /// \param  client_data        This value will be supplied to callbacks in their
    /// \a client_data argument.
    /// \assert
    /// \code decoder != NULL \endcode
    /// \retval FLAC__StreamDecoderInitStatus
    /// \c FLAC__STREAM_DECODER_INIT_STATUS_OK if initialization was successful;
    /// see FLAC__StreamDecoderInitStatus for the meanings of other return values.
    #[link_name = "\u{1}_FLAC__stream_decoder_init_stream"]
    pub fn FLAC__stream_decoder_init_stream(
        decoder: *mut FLAC__StreamDecoder,
        read_callback: FLAC__StreamDecoderReadCallback,
        seek_callback: FLAC__StreamDecoderSeekCallback,
        tell_callback: FLAC__StreamDecoderTellCallback,
        length_callback: FLAC__StreamDecoderLengthCallback,
        eof_callback: FLAC__StreamDecoderEofCallback,
        write_callback: FLAC__StreamDecoderWriteCallback,
        metadata_callback: FLAC__StreamDecoderMetadataCallback,
        error_callback: FLAC__StreamDecoderErrorCallback,
        client_data: *mut ::std::os::raw::c_void,
    ) -> FLAC__StreamDecoderInitStatus;
}
extern "C" {
    /// Initialize the decoder instance to decode Ogg FLAC streams.
    ///
    /// This flavor of initialization sets up the decoder to decode from a
    /// FLAC stream in an Ogg container. I/O is performed via callbacks to the
    /// client.  For decoding from a plain file via filename or open FILE*,
    /// FLAC__stream_decoder_init_ogg_file() and FLAC__stream_decoder_init_ogg_FILE()
    /// provide a simpler interface.
    ///
    /// This function should be called after FLAC__stream_decoder_new() and
    /// FLAC__stream_decoder_set_*() but before any of the
    /// FLAC__stream_decoder_process_*() functions.  Will set and return the
    /// decoder state, which will be FLAC__STREAM_DECODER_SEARCH_FOR_METADATA
    /// if initialization succeeded.
    ///
    /// \note Support for Ogg FLAC in the library is optional.  If this
    /// library has been built without support for Ogg FLAC, this function
    /// will return \c FLAC__STREAM_DECODER_INIT_STATUS_UNSUPPORTED_CONTAINER.
    ///
    /// \param  decoder            An uninitialized decoder instance.
    /// \param  read_callback      See FLAC__StreamDecoderReadCallback.  This
    /// pointer must not be \c NULL.
    /// \param  seek_callback      See FLAC__StreamDecoderSeekCallback.  This
    /// pointer may be \c NULL if seeking is not
    /// supported.  If \a seek_callback is not \c NULL then a
    /// \a tell_callback, \a length_callback, and \a eof_callback must also be supplied.
    /// Alternatively, a dummy seek callback that just
    /// returns \c FLAC__STREAM_DECODER_SEEK_STATUS_UNSUPPORTED
    /// may also be supplied, all though this is slightly
    /// less efficient for the decoder.
    /// \param  tell_callback      See FLAC__StreamDecoderTellCallback.  This
    /// pointer may be \c NULL if not supported by the client.  If
    /// \a seek_callback is not \c NULL then a
    /// \a tell_callback must also be supplied.
    /// Alternatively, a dummy tell callback that just
    /// returns \c FLAC__STREAM_DECODER_TELL_STATUS_UNSUPPORTED
    /// may also be supplied, all though this is slightly
    /// less efficient for the decoder.
    /// \param  length_callback    See FLAC__StreamDecoderLengthCallback.  This
    /// pointer may be \c NULL if not supported by the client.  If
    /// \a seek_callback is not \c NULL then a
    /// \a length_callback must also be supplied.
    /// Alternatively, a dummy length callback that just
    /// returns \c FLAC__STREAM_DECODER_LENGTH_STATUS_UNSUPPORTED
    /// may also be supplied, all though this is slightly
    /// less efficient for the decoder.
    /// \param  eof_callback       See FLAC__StreamDecoderEofCallback.  This
    /// pointer may be \c NULL if not supported by the client.  If
    /// \a seek_callback is not \c NULL then a
    /// \a eof_callback must also be supplied.
    /// Alternatively, a dummy length callback that just
    /// returns \c false
    /// may also be supplied, all though this is slightly
    /// less efficient for the decoder.
    /// \param  write_callback     See FLAC__StreamDecoderWriteCallback.  This
    /// pointer must not be \c NULL.
    /// \param  metadata_callback  See FLAC__StreamDecoderMetadataCallback.  This
    /// pointer may be \c NULL if the callback is not
    /// desired.
    /// \param  error_callback     See FLAC__StreamDecoderErrorCallback.  This
    /// pointer must not be \c NULL.
    /// \param  client_data        This value will be supplied to callbacks in their
    /// \a client_data argument.
    /// \assert
    /// \code decoder != NULL \endcode
    /// \retval FLAC__StreamDecoderInitStatus
    /// \c FLAC__STREAM_DECODER_INIT_STATUS_OK if initialization was successful;
    /// see FLAC__StreamDecoderInitStatus for the meanings of other return values.
    #[link_name = "\u{1}_FLAC__stream_decoder_init_ogg_stream"]
    pub fn FLAC__stream_decoder_init_ogg_stream(
        decoder: *mut FLAC__StreamDecoder,
        read_callback: FLAC__StreamDecoderReadCallback,
        seek_callback: FLAC__StreamDecoderSeekCallback,
        tell_callback: FLAC__StreamDecoderTellCallback,
        length_callback: FLAC__StreamDecoderLengthCallback,
        eof_callback: FLAC__StreamDecoderEofCallback,
        write_callback: FLAC__StreamDecoderWriteCallback,
        metadata_callback: FLAC__StreamDecoderMetadataCallback,
        error_callback: FLAC__StreamDecoderErrorCallback,
        client_data: *mut ::std::os::raw::c_void,
    ) -> FLAC__StreamDecoderInitStatus;
}
extern "C" {
    /// Initialize the decoder instance to decode native FLAC files.
    ///
    /// This flavor of initialization sets up the decoder to decode from a
    /// plain native FLAC file.  For non-stdio streams, you must use
    /// FLAC__stream_decoder_init_stream() and provide callbacks for the I/O.
    ///
    /// This function should be called after FLAC__stream_decoder_new() and
    /// FLAC__stream_decoder_set_*() but before any of the
    /// FLAC__stream_decoder_process_*() functions.  Will set and return the
    /// decoder state, which will be FLAC__STREAM_DECODER_SEARCH_FOR_METADATA
    /// if initialization succeeded.
    ///
    /// \param  decoder            An uninitialized decoder instance.
    /// \param  file               An open FLAC file.  The file should have been
    /// opened with mode \c "rb" and rewound.  The file
    /// becomes owned by the decoder and should not be
    /// manipulated by the client while decoding.
    /// Unless \a file is \c stdin, it will be closed
    /// when FLAC__stream_decoder_finish() is called.
    /// Note however that seeking will not work when
    /// decoding from \c stdout since it is not seekable.
    /// \param  write_callback     See FLAC__StreamDecoderWriteCallback.  This
    /// pointer must not be \c NULL.
    /// \param  metadata_callback  See FLAC__StreamDecoderMetadataCallback.  This
    /// pointer may be \c NULL if the callback is not
    /// desired.
    /// \param  error_callback     See FLAC__StreamDecoderErrorCallback.  This
    /// pointer must not be \c NULL.
    /// \param  client_data        This value will be supplied to callbacks in their
    /// \a client_data argument.
    /// \assert
    /// \code decoder != NULL \endcode
    /// \code file != NULL \endcode
    /// \retval FLAC__StreamDecoderInitStatus
    /// \c FLAC__STREAM_DECODER_INIT_STATUS_OK if initialization was successful;
    /// see FLAC__StreamDecoderInitStatus for the meanings of other return values.
    #[link_name = "\u{1}_FLAC__stream_decoder_init_FILE"]
    pub fn FLAC__stream_decoder_init_FILE(
        decoder: *mut FLAC__StreamDecoder,
        file: *mut FILE,
        write_callback: FLAC__StreamDecoderWriteCallback,
        metadata_callback: FLAC__StreamDecoderMetadataCallback,
        error_callback: FLAC__StreamDecoderErrorCallback,
        client_data: *mut ::std::os::raw::c_void,
    ) -> FLAC__StreamDecoderInitStatus;
}
extern "C" {
    /// Initialize the decoder instance to decode Ogg FLAC files.
    ///
    /// This flavor of initialization sets up the decoder to decode from a
    /// plain Ogg FLAC file.  For non-stdio streams, you must use
    /// FLAC__stream_decoder_init_ogg_stream() and provide callbacks for the I/O.
    ///
    /// This function should be called after FLAC__stream_decoder_new() and
    /// FLAC__stream_decoder_set_*() but before any of the
    /// FLAC__stream_decoder_process_*() functions.  Will set and return the
    /// decoder state, which will be FLAC__STREAM_DECODER_SEARCH_FOR_METADATA
    /// if initialization succeeded.
    ///
    /// \note Support for Ogg FLAC in the library is optional.  If this
    /// library has been built without support for Ogg FLAC, this function
    /// will return \c FLAC__STREAM_DECODER_INIT_STATUS_UNSUPPORTED_CONTAINER.
    ///
    /// \param  decoder            An uninitialized decoder instance.
    /// \param  file               An open FLAC file.  The file should have been
    /// opened with mode \c "rb" and rewound.  The file
    /// becomes owned by the decoder and should not be
    /// manipulated by the client while decoding.
    /// Unless \a file is \c stdin, it will be closed
    /// when FLAC__stream_decoder_finish() is called.
    /// Note however that seeking will not work when
    /// decoding from \c stdout since it is not seekable.
    /// \param  write_callback     See FLAC__StreamDecoderWriteCallback.  This
    /// pointer must not be \c NULL.
    /// \param  metadata_callback  See FLAC__StreamDecoderMetadataCallback.  This
    /// pointer may be \c NULL if the callback is not
    /// desired.
    /// \param  error_callback     See FLAC__StreamDecoderErrorCallback.  This
    /// pointer must not be \c NULL.
    /// \param  client_data        This value will be supplied to callbacks in their
    /// \a client_data argument.
    /// \assert
    /// \code decoder != NULL \endcode
    /// \code file != NULL \endcode
    /// \retval FLAC__StreamDecoderInitStatus
    /// \c FLAC__STREAM_DECODER_INIT_STATUS_OK if initialization was successful;
    /// see FLAC__StreamDecoderInitStatus for the meanings of other return values.
    #[link_name = "\u{1}_FLAC__stream_decoder_init_ogg_FILE"]
    pub fn FLAC__stream_decoder_init_ogg_FILE(
        decoder: *mut FLAC__StreamDecoder,
        file: *mut FILE,
        write_callback: FLAC__StreamDecoderWriteCallback,
        metadata_callback: FLAC__StreamDecoderMetadataCallback,
        error_callback: FLAC__StreamDecoderErrorCallback,
        client_data: *mut ::std::os::raw::c_void,
    ) -> FLAC__StreamDecoderInitStatus;
}
extern "C" {
    /// Initialize the decoder instance to decode native FLAC files.
    ///
    /// This flavor of initialization sets up the decoder to decode from a plain
    /// native FLAC file.  If POSIX fopen() semantics are not sufficient, (for
    /// example, with Unicode filenames on Windows), you must use
    /// FLAC__stream_decoder_init_FILE(), or FLAC__stream_decoder_init_stream()
    /// and provide callbacks for the I/O.
    ///
    /// This function should be called after FLAC__stream_decoder_new() and
    /// FLAC__stream_decoder_set_*() but before any of the
    /// FLAC__stream_decoder_process_*() functions.  Will set and return the
    /// decoder state, which will be FLAC__STREAM_DECODER_SEARCH_FOR_METADATA
    /// if initialization succeeded.
    ///
    /// \param  decoder            An uninitialized decoder instance.
    /// \param  filename           The name of the file to decode from.  The file will
    /// be opened with fopen().  Use \c NULL to decode from
    /// \c stdin.  Note that \c stdin is not seekable.
    /// \param  write_callback     See FLAC__StreamDecoderWriteCallback.  This
    /// pointer must not be \c NULL.
    /// \param  metadata_callback  See FLAC__StreamDecoderMetadataCallback.  This
    /// pointer may be \c NULL if the callback is not
    /// desired.
    /// \param  error_callback     See FLAC__StreamDecoderErrorCallback.  This
    /// pointer must not be \c NULL.
    /// \param  client_data        This value will be supplied to callbacks in their
    /// \a client_data argument.
    /// \assert
    /// \code decoder != NULL \endcode
    /// \retval FLAC__StreamDecoderInitStatus
    /// \c FLAC__STREAM_DECODER_INIT_STATUS_OK if initialization was successful;
    /// see FLAC__StreamDecoderInitStatus for the meanings of other return values.
    #[link_name = "\u{1}_FLAC__stream_decoder_init_file"]
    pub fn FLAC__stream_decoder_init_file(
        decoder: *mut FLAC__StreamDecoder,
        filename: *const ::std::os::raw::c_char,
        write_callback: FLAC__StreamDecoderWriteCallback,
        metadata_callback: FLAC__StreamDecoderMetadataCallback,
        error_callback: FLAC__StreamDecoderErrorCallback,
        client_data: *mut ::std::os::raw::c_void,
    ) -> FLAC__StreamDecoderInitStatus;
}
extern "C" {
    /// Initialize the decoder instance to decode Ogg FLAC files.
    ///
    /// This flavor of initialization sets up the decoder to decode from a plain
    /// Ogg FLAC file.  If POSIX fopen() semantics are not sufficient, (for
    /// example, with Unicode filenames on Windows), you must use
    /// FLAC__stream_decoder_init_ogg_FILE(), or FLAC__stream_decoder_init_ogg_stream()
    /// and provide callbacks for the I/O.
    ///
    /// This function should be called after FLAC__stream_decoder_new() and
    /// FLAC__stream_decoder_set_*() but before any of the
    /// FLAC__stream_decoder_process_*() functions.  Will set and return the
    /// decoder state, which will be FLAC__STREAM_DECODER_SEARCH_FOR_METADATA
    /// if initialization succeeded.
    ///
    /// \note Support for Ogg FLAC in the library is optional.  If this
    /// library has been built without support for Ogg FLAC, this function
    /// will return \c FLAC__STREAM_DECODER_INIT_STATUS_UNSUPPORTED_CONTAINER.
    ///
    /// \param  decoder            An uninitialized decoder instance.
    /// \param  filename           The name of the file to decode from.  The file will
    /// be opened with fopen().  Use \c NULL to decode from
    /// \c stdin.  Note that \c stdin is not seekable.
    /// \param  write_callback     See FLAC__StreamDecoderWriteCallback.  This
    /// pointer must not be \c NULL.
    /// \param  metadata_callback  See FLAC__StreamDecoderMetadataCallback.  This
    /// pointer may be \c NULL if the callback is not
    /// desired.
    /// \param  error_callback     See FLAC__StreamDecoderErrorCallback.  This
    /// pointer must not be \c NULL.
    /// \param  client_data        This value will be supplied to callbacks in their
    /// \a client_data argument.
    /// \assert
    /// \code decoder != NULL \endcode
    /// \retval FLAC__StreamDecoderInitStatus
    /// \c FLAC__STREAM_DECODER_INIT_STATUS_OK if initialization was successful;
    /// see FLAC__StreamDecoderInitStatus for the meanings of other return values.
    #[link_name = "\u{1}_FLAC__stream_decoder_init_ogg_file"]
    pub fn FLAC__stream_decoder_init_ogg_file(
        decoder: *mut FLAC__StreamDecoder,
        filename: *const ::std::os::raw::c_char,
        write_callback: FLAC__StreamDecoderWriteCallback,
        metadata_callback: FLAC__StreamDecoderMetadataCallback,
        error_callback: FLAC__StreamDecoderErrorCallback,
        client_data: *mut ::std::os::raw::c_void,
    ) -> FLAC__StreamDecoderInitStatus;
}
extern "C" {
    /// Finish the decoding process.
    /// Flushes the decoding buffer, releases resources, resets the decoder
    /// settings to their defaults, and returns the decoder state to
    /// FLAC__STREAM_DECODER_UNINITIALIZED.
    ///
    /// In the event of a prematurely-terminated decode, it is not strictly
    /// necessary to call this immediately before FLAC__stream_decoder_delete()
    /// but it is good practice to match every FLAC__stream_decoder_init_*()
    /// with a FLAC__stream_decoder_finish().
    ///
    /// \param  decoder  An uninitialized decoder instance.
    /// \assert
    /// \code decoder != NULL \endcode
    /// \retval FLAC__bool
    /// \c false if MD5 checking is on AND a STREAMINFO block was available
    /// AND the MD5 signature in the STREAMINFO block was non-zero AND the
    /// signature does not match the one computed by the decoder; else
    /// \c true.
    #[link_name = "\u{1}_FLAC__stream_decoder_finish"]
    pub fn FLAC__stream_decoder_finish(decoder: *mut FLAC__StreamDecoder) -> FLAC__bool;
}
extern "C" {
    /// Flush the stream input.
    /// The decoder's input buffer will be cleared and the state set to
    /// \c FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC.  This will also turn
    /// off MD5 checking.
    ///
    /// \param  decoder  A decoder instance.
    /// \assert
    /// \code decoder != NULL \endcode
    /// \retval FLAC__bool
    /// \c true if successful, else \c false if a memory allocation
    /// error occurs (in which case the state will be set to
    /// \c FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR).
    #[link_name = "\u{1}_FLAC__stream_decoder_flush"]
    pub fn FLAC__stream_decoder_flush(decoder: *mut FLAC__StreamDecoder) -> FLAC__bool;
}
extern "C" {
    /// Reset the decoding process.
    /// The decoder's input buffer will be cleared and the state set to
    /// \c FLAC__STREAM_DECODER_SEARCH_FOR_METADATA.  This is similar to
    /// FLAC__stream_decoder_finish() except that the settings are
    /// preserved; there is no need to call FLAC__stream_decoder_init_*()
    /// before decoding again.  MD5 checking will be restored to its original
    /// setting.
    ///
    /// If the decoder is seekable, or was initialized with
    /// FLAC__stream_decoder_init*_FILE() or FLAC__stream_decoder_init*_file(),
    /// the decoder will also attempt to seek to the beginning of the file.
    /// If this rewind fails, this function will return \c false.  It follows
    /// that FLAC__stream_decoder_reset() cannot be used when decoding from
    /// \c stdin.
    ///
    /// If the decoder was initialized with FLAC__stream_encoder_init*_stream()
    /// and is not seekable (i.e. no seek callback was provided or the seek
    /// callback returns \c FLAC__STREAM_DECODER_SEEK_STATUS_UNSUPPORTED), it
    /// is the duty of the client to start feeding data from the beginning of
    /// the stream on the next FLAC__stream_decoder_process() or
    /// FLAC__stream_decoder_process_interleaved() call.
    ///
    /// \param  decoder  A decoder instance.
    /// \assert
    /// \code decoder != NULL \endcode
    /// \retval FLAC__bool
    /// \c true if successful, else \c false if a memory allocation occurs
    /// (in which case the state will be set to
    /// \c FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR) or a seek error
    /// occurs (the state will be unchanged).
    #[link_name = "\u{1}_FLAC__stream_decoder_reset"]
    pub fn FLAC__stream_decoder_reset(decoder: *mut FLAC__StreamDecoder) -> FLAC__bool;
}
extern "C" {
    /// Decode one metadata block or audio frame.
    /// This version instructs the decoder to decode a either a single metadata
    /// block or a single frame and stop, unless the callbacks return a fatal
    /// error or the read callback returns
    /// \c FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM.
    ///
    /// As the decoder needs more input it will call the read callback.
    /// Depending on what was decoded, the metadata or write callback will be
    /// called with the decoded metadata block or audio frame.
    ///
    /// Unless there is a fatal read error or end of stream, this function
    /// will return once one whole frame is decoded.  In other words, if the
    /// stream is not synchronized or points to a corrupt frame header, the
    /// decoder will continue to try and resync until it gets to a valid
    /// frame, then decode one frame, then return.  If the decoder points to
    /// a frame whose frame CRC in the frame footer does not match the
    /// computed frame CRC, this function will issue a
    /// FLAC__STREAM_DECODER_ERROR_STATUS_FRAME_CRC_MISMATCH error to the
    /// error callback, and return, having decoded one complete, although
    /// corrupt, frame.  (Such corrupted frames are sent as silence of the
    /// correct length to the write callback.)
    ///
    /// \param  decoder  An initialized decoder instance.
    /// \assert
    /// \code decoder != NULL \endcode
    /// \retval FLAC__bool
    /// \c false if any fatal read, write, or memory allocation error
    /// occurred (meaning decoding must stop), else \c true; for more
    /// information about the decoder, check the decoder state with
    /// FLAC__stream_decoder_get_state().
    #[link_name = "\u{1}_FLAC__stream_decoder_process_single"]
    pub fn FLAC__stream_decoder_process_single(decoder: *mut FLAC__StreamDecoder) -> FLAC__bool;
}
extern "C" {
    /// Decode until the end of the metadata.
    /// This version instructs the decoder to decode from the current position
    /// and continue until all the metadata has been read, or until the
    /// callbacks return a fatal error or the read callback returns
    /// \c FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM.
    ///
    /// As the decoder needs more input it will call the read callback.
    /// As each metadata block is decoded, the metadata callback will be called
    /// with the decoded metadata.
    ///
    /// \param  decoder  An initialized decoder instance.
    /// \assert
    /// \code decoder != NULL \endcode
    /// \retval FLAC__bool
    /// \c false if any fatal read, write, or memory allocation error
    /// occurred (meaning decoding must stop), else \c true; for more
    /// information about the decoder, check the decoder state with
    /// FLAC__stream_decoder_get_state().
    #[link_name = "\u{1}_FLAC__stream_decoder_process_until_end_of_metadata"]
    pub fn FLAC__stream_decoder_process_until_end_of_metadata(
        decoder: *mut FLAC__StreamDecoder,
    ) -> FLAC__bool;
}
extern "C" {
    /// Decode until the end of the stream.
    /// This version instructs the decoder to decode from the current position
    /// and continue until the end of stream (the read callback returns
    /// \c FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM), or until the
    /// callbacks return a fatal error.
    ///
    /// As the decoder needs more input it will call the read callback.
    /// As each metadata block and frame is decoded, the metadata or write
    /// callback will be called with the decoded metadata or frame.
    ///
    /// \param  decoder  An initialized decoder instance.
    /// \assert
    /// \code decoder != NULL \endcode
    /// \retval FLAC__bool
    /// \c false if any fatal read, write, or memory allocation error
    /// occurred (meaning decoding must stop), else \c true; for more
    /// information about the decoder, check the decoder state with
    /// FLAC__stream_decoder_get_state().
    #[link_name = "\u{1}_FLAC__stream_decoder_process_until_end_of_stream"]
    pub fn FLAC__stream_decoder_process_until_end_of_stream(
        decoder: *mut FLAC__StreamDecoder,
    ) -> FLAC__bool;
}
extern "C" {
    /// Skip one audio frame.
    /// This version instructs the decoder to 'skip' a single frame and stop,
    /// unless the callbacks return a fatal error or the read callback returns
    /// \c FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM.
    ///
    /// The decoding flow is the same as what occurs when
    /// FLAC__stream_decoder_process_single() is called to process an audio
    /// frame, except that this function does not decode the parsed data into
    /// PCM or call the write callback.  The integrity of the frame is still
    /// checked the same way as in the other process functions.
    ///
    /// This function will return once one whole frame is skipped, in the
    /// same way that FLAC__stream_decoder_process_single() will return once
    /// one whole frame is decoded.
    ///
    /// This function can be used in more quickly determining FLAC frame
    /// boundaries when decoding of the actual data is not needed, for
    /// example when an application is separating a FLAC stream into frames
    /// for editing or storing in a container.  To do this, the application
    /// can use FLAC__stream_decoder_skip_single_frame() to quickly advance
    /// to the next frame, then use
    /// FLAC__stream_decoder_get_decode_position() to find the new frame
    /// boundary.
    ///
    /// This function should only be called when the stream has advanced
    /// past all the metadata, otherwise it will return \c false.
    ///
    /// \param  decoder  An initialized decoder instance not in a metadata
    /// state.
    /// \assert
    /// \code decoder != NULL \endcode
    /// \retval FLAC__bool
    /// \c false if any fatal read, write, or memory allocation error
    /// occurred (meaning decoding must stop), or if the decoder
    /// is in the FLAC__STREAM_DECODER_SEARCH_FOR_METADATA or
    /// FLAC__STREAM_DECODER_READ_METADATA state, else \c true; for more
    /// information about the decoder, check the decoder state with
    /// FLAC__stream_decoder_get_state().
    #[link_name = "\u{1}_FLAC__stream_decoder_skip_single_frame"]
    pub fn FLAC__stream_decoder_skip_single_frame(decoder: *mut FLAC__StreamDecoder) -> FLAC__bool;
}
extern "C" {
    /// Flush the input and seek to an absolute sample.
    /// Decoding will resume at the given sample.  Note that because of
    /// this, the next write callback may contain a partial block.  The
    /// client must support seeking the input or this function will fail
    /// and return \c false.  Furthermore, if the decoder state is
    /// \c FLAC__STREAM_DECODER_SEEK_ERROR, then the decoder must be flushed
    /// with FLAC__stream_decoder_flush() or reset with
    /// FLAC__stream_decoder_reset() before decoding can continue.
    ///
    /// \param  decoder  A decoder instance.
    /// \param  sample   The target sample number to seek to.
    /// \assert
    /// \code decoder != NULL \endcode
    /// \retval FLAC__bool
    /// \c true if successful, else \c false.
    #[link_name = "\u{1}_FLAC__stream_decoder_seek_absolute"]
    pub fn FLAC__stream_decoder_seek_absolute(
        decoder: *mut FLAC__StreamDecoder,
        sample: FLAC__uint64,
    ) -> FLAC__bool;
}
pub const FLAC__StreamEncoderState_FLAC__STREAM_ENCODER_OK: FLAC__StreamEncoderState = 0;
pub const FLAC__StreamEncoderState_FLAC__STREAM_ENCODER_UNINITIALIZED: FLAC__StreamEncoderState = 1;
pub const FLAC__StreamEncoderState_FLAC__STREAM_ENCODER_OGG_ERROR: FLAC__StreamEncoderState = 2;
pub const FLAC__StreamEncoderState_FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR:
    FLAC__StreamEncoderState = 3;
pub const FLAC__StreamEncoderState_FLAC__STREAM_ENCODER_VERIFY_MISMATCH_IN_AUDIO_DATA:
    FLAC__StreamEncoderState = 4;
pub const FLAC__StreamEncoderState_FLAC__STREAM_ENCODER_CLIENT_ERROR: FLAC__StreamEncoderState = 5;
pub const FLAC__StreamEncoderState_FLAC__STREAM_ENCODER_IO_ERROR: FLAC__StreamEncoderState = 6;
pub const FLAC__StreamEncoderState_FLAC__STREAM_ENCODER_FRAMING_ERROR: FLAC__StreamEncoderState = 7;
pub const FLAC__StreamEncoderState_FLAC__STREAM_ENCODER_MEMORY_ALLOCATION_ERROR:
    FLAC__StreamEncoderState = 8;
pub type FLAC__StreamEncoderState = u32;
extern "C" {
    #[link_name = "\u{1}_FLAC__StreamEncoderStateString"]
    pub static mut FLAC__StreamEncoderStateString: [*const ::std::os::raw::c_char; 0usize];
}
pub const FLAC__StreamEncoderInitStatus_FLAC__STREAM_ENCODER_INIT_STATUS_OK:
    FLAC__StreamEncoderInitStatus = 0;
pub const FLAC__StreamEncoderInitStatus_FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR:
    FLAC__StreamEncoderInitStatus = 1;
pub const FLAC__StreamEncoderInitStatus_FLAC__STREAM_ENCODER_INIT_STATUS_UNSUPPORTED_CONTAINER:
    FLAC__StreamEncoderInitStatus = 2;
pub const FLAC__StreamEncoderInitStatus_FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_CALLBACKS:
    FLAC__StreamEncoderInitStatus = 3;
pub const FLAC__StreamEncoderInitStatus_FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_NUMBER_OF_CHANNELS : FLAC__StreamEncoderInitStatus = 4 ;
pub const FLAC__StreamEncoderInitStatus_FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_BITS_PER_SAMPLE:
    FLAC__StreamEncoderInitStatus = 5;
pub const FLAC__StreamEncoderInitStatus_FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_SAMPLE_RATE:
    FLAC__StreamEncoderInitStatus = 6;
pub const FLAC__StreamEncoderInitStatus_FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_BLOCK_SIZE:
    FLAC__StreamEncoderInitStatus = 7;
pub const FLAC__StreamEncoderInitStatus_FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_MAX_LPC_ORDER:
    FLAC__StreamEncoderInitStatus = 8;
pub const FLAC__StreamEncoderInitStatus_FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_QLP_COEFF_PRECISION : FLAC__StreamEncoderInitStatus = 9 ;
pub const FLAC__StreamEncoderInitStatus_FLAC__STREAM_ENCODER_INIT_STATUS_BLOCK_SIZE_TOO_SMALL_FOR_LPC_ORDER : FLAC__StreamEncoderInitStatus = 10 ;
pub const FLAC__StreamEncoderInitStatus_FLAC__STREAM_ENCODER_INIT_STATUS_NOT_STREAMABLE:
    FLAC__StreamEncoderInitStatus = 11;
pub const FLAC__StreamEncoderInitStatus_FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA:
    FLAC__StreamEncoderInitStatus = 12;
pub const FLAC__StreamEncoderInitStatus_FLAC__STREAM_ENCODER_INIT_STATUS_ALREADY_INITIALIZED:
    FLAC__StreamEncoderInitStatus = 13;
pub type FLAC__StreamEncoderInitStatus = u32;
extern "C" {
    #[link_name = "\u{1}_FLAC__StreamEncoderInitStatusString"]
    pub static mut FLAC__StreamEncoderInitStatusString: [*const ::std::os::raw::c_char; 0usize];
}
pub const FLAC__StreamEncoderReadStatus_FLAC__STREAM_ENCODER_READ_STATUS_CONTINUE:
    FLAC__StreamEncoderReadStatus = 0;
pub const FLAC__StreamEncoderReadStatus_FLAC__STREAM_ENCODER_READ_STATUS_END_OF_STREAM:
    FLAC__StreamEncoderReadStatus = 1;
pub const FLAC__StreamEncoderReadStatus_FLAC__STREAM_ENCODER_READ_STATUS_ABORT:
    FLAC__StreamEncoderReadStatus = 2;
pub const FLAC__StreamEncoderReadStatus_FLAC__STREAM_ENCODER_READ_STATUS_UNSUPPORTED:
    FLAC__StreamEncoderReadStatus = 3;
pub type FLAC__StreamEncoderReadStatus = u32;
extern "C" {
    #[link_name = "\u{1}_FLAC__StreamEncoderReadStatusString"]
    pub static mut FLAC__StreamEncoderReadStatusString: [*const ::std::os::raw::c_char; 0usize];
}
pub const FLAC__StreamEncoderWriteStatus_FLAC__STREAM_ENCODER_WRITE_STATUS_OK:
    FLAC__StreamEncoderWriteStatus = 0;
pub const FLAC__StreamEncoderWriteStatus_FLAC__STREAM_ENCODER_WRITE_STATUS_FATAL_ERROR:
    FLAC__StreamEncoderWriteStatus = 1;
pub type FLAC__StreamEncoderWriteStatus = u32;
extern "C" {
    #[link_name = "\u{1}_FLAC__StreamEncoderWriteStatusString"]
    pub static mut FLAC__StreamEncoderWriteStatusString: [*const ::std::os::raw::c_char; 0usize];
}
pub const FLAC__StreamEncoderSeekStatus_FLAC__STREAM_ENCODER_SEEK_STATUS_OK:
    FLAC__StreamEncoderSeekStatus = 0;
pub const FLAC__StreamEncoderSeekStatus_FLAC__STREAM_ENCODER_SEEK_STATUS_ERROR:
    FLAC__StreamEncoderSeekStatus = 1;
pub const FLAC__StreamEncoderSeekStatus_FLAC__STREAM_ENCODER_SEEK_STATUS_UNSUPPORTED:
    FLAC__StreamEncoderSeekStatus = 2;
pub type FLAC__StreamEncoderSeekStatus = u32;
extern "C" {
    #[link_name = "\u{1}_FLAC__StreamEncoderSeekStatusString"]
    pub static mut FLAC__StreamEncoderSeekStatusString: [*const ::std::os::raw::c_char; 0usize];
}
pub const FLAC__StreamEncoderTellStatus_FLAC__STREAM_ENCODER_TELL_STATUS_OK:
    FLAC__StreamEncoderTellStatus = 0;
pub const FLAC__StreamEncoderTellStatus_FLAC__STREAM_ENCODER_TELL_STATUS_ERROR:
    FLAC__StreamEncoderTellStatus = 1;
pub const FLAC__StreamEncoderTellStatus_FLAC__STREAM_ENCODER_TELL_STATUS_UNSUPPORTED:
    FLAC__StreamEncoderTellStatus = 2;
pub type FLAC__StreamEncoderTellStatus = u32;
extern "C" {
    #[link_name = "\u{1}_FLAC__StreamEncoderTellStatusString"]
    pub static mut FLAC__StreamEncoderTellStatusString: [*const ::std::os::raw::c_char; 0usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamEncoderProtected {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamEncoderPrivate {
    _unused: [u8; 0],
}
/// The opaque structure definition for the stream encoder type.
/// See the \link flac_stream_encoder stream encoder module \endlink
/// for a detailed description.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamEncoder {
    pub protected_: *mut FLAC__StreamEncoderProtected,
    pub private_: *mut FLAC__StreamEncoderPrivate,
}
#[test]
fn bindgen_test_layout_FLAC__StreamEncoder() {
    assert_eq!(
        ::std::mem::size_of::<FLAC__StreamEncoder>(),
        16usize,
        concat!("Size of: ", stringify!(FLAC__StreamEncoder))
    );
    assert_eq!(
        ::std::mem::align_of::<FLAC__StreamEncoder>(),
        8usize,
        concat!("Alignment of ", stringify!(FLAC__StreamEncoder))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FLAC__StreamEncoder>())).protected_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamEncoder),
            "::",
            stringify!(protected_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FLAC__StreamEncoder>())).private_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FLAC__StreamEncoder),
            "::",
            stringify!(private_)
        )
    );
}
/// Signature for the read callback.
///
/// A function pointer matching this signature must be passed to
/// FLAC__stream_encoder_init_ogg_stream() if seeking is supported.
/// The supplied function will be called when the encoder needs to read back
/// encoded data.  This happens during the metadata callback, when the encoder
/// has to read, modify, and rewrite the metadata (e.g. seekpoints) gathered
/// while encoding.  The address of the buffer to be filled is supplied, along
/// with the number of bytes the buffer can hold.  The callback may choose to
/// supply less data and modify the byte count but must be careful not to
/// overflow the buffer.  The callback then returns a status code chosen from
/// FLAC__StreamEncoderReadStatus.
///
/// Here is an example of a read callback for stdio streams:
/// \code
/// FLAC__StreamEncoderReadStatus read_cb(const FLAC__StreamEncoder *encoder, FLAC__byte buffer[], size_t *bytes, void *client_data)
/// {
/// FILE *file = ((MyClientData*)client_data)->file;
/// if(*bytes > 0) {
/// *bytes = fread(buffer, sizeof(FLAC__byte), *bytes, file);
/// if(ferror(file))
/// return FLAC__STREAM_ENCODER_READ_STATUS_ABORT;
/// else if(*bytes == 0)
/// return FLAC__STREAM_ENCODER_READ_STATUS_END_OF_STREAM;
/// else
/// return FLAC__STREAM_ENCODER_READ_STATUS_CONTINUE;
/// }
/// else
/// return FLAC__STREAM_ENCODER_READ_STATUS_ABORT;
/// }
/// \endcode
///
/// \note In general, FLAC__StreamEncoder functions which change the
/// state should not be called on the \a encoder while in the callback.
///
/// \param  encoder  The encoder instance calling the callback.
/// \param  buffer   A pointer to a location for the callee to store
/// data to be encoded.
/// \param  bytes    A pointer to the size of the buffer.  On entry
/// to the callback, it contains the maximum number
/// of bytes that may be stored in \a buffer.  The
/// callee must set it to the actual number of bytes
/// stored (0 in case of error or end-of-stream) before
/// returning.
/// \param  client_data  The callee's client data set through
/// FLAC__stream_encoder_set_client_data().
/// \retval FLAC__StreamEncoderReadStatus
/// The callee's return status.
pub type FLAC__StreamEncoderReadCallback = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *const FLAC__StreamEncoder,
        buffer: *mut FLAC__byte,
        bytes: *mut usize,
        client_data: *mut ::std::os::raw::c_void,
    ) -> FLAC__StreamEncoderReadStatus,
>;
/// Signature for the write callback.
///
/// A function pointer matching this signature must be passed to
/// FLAC__stream_encoder_init*_stream().  The supplied function will be called
/// by the encoder anytime there is raw encoded data ready to write.  It may
/// include metadata mixed with encoded audio frames and the data is not
/// guaranteed to be aligned on frame or metadata block boundaries.
///
/// The only duty of the callback is to write out the \a bytes worth of data
/// in \a buffer to the current position in the output stream.  The arguments
/// \a samples and \a current_frame are purely informational.  If \a samples
/// is greater than \c 0, then \a current_frame will hold the current frame
/// number that is being written; otherwise it indicates that the write
/// callback is being called to write metadata.
///
/// \note
/// Unlike when writing to native FLAC, when writing to Ogg FLAC the
/// write callback will be called twice when writing each audio
/// frame; once for the page header, and once for the page body.
/// When writing the page header, the \a samples argument to the
/// write callback will be \c 0.
///
/// \note In general, FLAC__StreamEncoder functions which change the
/// state should not be called on the \a encoder while in the callback.
///
/// \param  encoder  The encoder instance calling the callback.
/// \param  buffer   An array of encoded data of length \a bytes.
/// \param  bytes    The byte length of \a buffer.
/// \param  samples  The number of samples encoded by \a buffer.
/// \c 0 has a special meaning; see above.
/// \param  current_frame  The number of the current frame being encoded.
/// \param  client_data  The callee's client data set through
/// FLAC__stream_encoder_init_*().
/// \retval FLAC__StreamEncoderWriteStatus
/// The callee's return status.
pub type FLAC__StreamEncoderWriteCallback = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *const FLAC__StreamEncoder,
        buffer: *const FLAC__byte,
        bytes: usize,
        samples: ::std::os::raw::c_uint,
        current_frame: ::std::os::raw::c_uint,
        client_data: *mut ::std::os::raw::c_void,
    ) -> FLAC__StreamEncoderWriteStatus,
>;
/// Signature for the seek callback.
///
/// A function pointer matching this signature may be passed to
/// FLAC__stream_encoder_init*_stream().  The supplied function will be called
/// when the encoder needs to seek the output stream.  The encoder will pass
/// the absolute byte offset to seek to, 0 meaning the beginning of the stream.
///
/// Here is an example of a seek callback for stdio streams:
/// \code
/// FLAC__StreamEncoderSeekStatus seek_cb(const FLAC__StreamEncoder *encoder, FLAC__uint64 absolute_byte_offset, void *client_data)
/// {
/// FILE *file = ((MyClientData*)client_data)->file;
/// if(file == stdin)
/// return FLAC__STREAM_ENCODER_SEEK_STATUS_UNSUPPORTED;
/// else if(fseeko(file, (off_t)absolute_byte_offset, SEEK_SET) < 0)
/// return FLAC__STREAM_ENCODER_SEEK_STATUS_ERROR;
/// else
/// return FLAC__STREAM_ENCODER_SEEK_STATUS_OK;
/// }
/// \endcode
///
/// \note In general, FLAC__StreamEncoder functions which change the
/// state should not be called on the \a encoder while in the callback.
///
/// \param  encoder  The encoder instance calling the callback.
/// \param  absolute_byte_offset  The offset from the beginning of the stream
/// to seek to.
/// \param  client_data  The callee's client data set through
/// FLAC__stream_encoder_init_*().
/// \retval FLAC__StreamEncoderSeekStatus
/// The callee's return status.
pub type FLAC__StreamEncoderSeekCallback = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *const FLAC__StreamEncoder,
        absolute_byte_offset: FLAC__uint64,
        client_data: *mut ::std::os::raw::c_void,
    ) -> FLAC__StreamEncoderSeekStatus,
>;
/// Signature for the tell callback.
///
/// A function pointer matching this signature may be passed to
/// FLAC__stream_encoder_init*_stream().  The supplied function will be called
/// when the encoder needs to know the current position of the output stream.
///
/// \warning
/// The callback must return the true current byte offset of the output to
/// which the encoder is writing.  If you are buffering the output, make
/// sure and take this into account.  If you are writing directly to a
/// FILE* from your write callback, ftell() is sufficient.  If you are
/// writing directly to a file descriptor from your write callback, you
/// can use lseek(fd, SEEK_CUR, 0).  The encoder may later seek back to
/// these points to rewrite metadata after encoding.
///
/// Here is an example of a tell callback for stdio streams:
/// \code
/// FLAC__StreamEncoderTellStatus tell_cb(const FLAC__StreamEncoder *encoder, FLAC__uint64 *absolute_byte_offset, void *client_data)
/// {
/// FILE *file = ((MyClientData*)client_data)->file;
/// off_t pos;
/// if(file == stdin)
/// return FLAC__STREAM_ENCODER_TELL_STATUS_UNSUPPORTED;
/// else if((pos = ftello(file)) < 0)
/// return FLAC__STREAM_ENCODER_TELL_STATUS_ERROR;
/// else {
/// *absolute_byte_offset = (FLAC__uint64)pos;
/// return FLAC__STREAM_ENCODER_TELL_STATUS_OK;
/// }
/// }
/// \endcode
///
/// \note In general, FLAC__StreamEncoder functions which change the
/// state should not be called on the \a encoder while in the callback.
///
/// \param  encoder  The encoder instance calling the callback.
/// \param  absolute_byte_offset  The address at which to store the current
/// position of the output.
/// \param  client_data  The callee's client data set through
/// FLAC__stream_encoder_init_*().
/// \retval FLAC__StreamEncoderTellStatus
/// The callee's return status.
pub type FLAC__StreamEncoderTellCallback = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *const FLAC__StreamEncoder,
        absolute_byte_offset: *mut FLAC__uint64,
        client_data: *mut ::std::os::raw::c_void,
    ) -> FLAC__StreamEncoderTellStatus,
>;
/// Signature for the metadata callback.
///
/// A function pointer matching this signature may be passed to
/// FLAC__stream_encoder_init*_stream().  The supplied function will be called
/// once at the end of encoding with the populated STREAMINFO structure.  This
/// is so the client can seek back to the beginning of the file and write the
/// STREAMINFO block with the correct statistics after encoding (like
/// minimum/maximum frame size and total samples).
///
/// \note In general, FLAC__StreamEncoder functions which change the
/// state should not be called on the \a encoder while in the callback.
///
/// \param  encoder      The encoder instance calling the callback.
/// \param  metadata     The final populated STREAMINFO block.
/// \param  client_data  The callee's client data set through
/// FLAC__stream_encoder_init_*().
pub type FLAC__StreamEncoderMetadataCallback = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *const FLAC__StreamEncoder,
        metadata: *const FLAC__StreamMetadata,
        client_data: *mut ::std::os::raw::c_void,
    ),
>;
/// Signature for the progress callback.
///
/// A function pointer matching this signature may be passed to
/// FLAC__stream_encoder_init*_file() or FLAC__stream_encoder_init*_FILE().
/// The supplied function will be called when the encoder has finished
/// writing a frame.  The \c total_frames_estimate argument to the
/// callback will be based on the value from
/// FLAC__stream_encoder_set_total_samples_estimate().
///
/// \note In general, FLAC__StreamEncoder functions which change the
/// state should not be called on the \a encoder while in the callback.
///
/// \param  encoder          The encoder instance calling the callback.
/// \param  bytes_written    Bytes written so far.
/// \param  samples_written  Samples written so far.
/// \param  frames_written   Frames written so far.
/// \param  total_frames_estimate  The estimate of the total number of
/// frames to be written.
/// \param  client_data      The callee's client data set through
/// FLAC__stream_encoder_init_*().
pub type FLAC__StreamEncoderProgressCallback = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *const FLAC__StreamEncoder,
        bytes_written: FLAC__uint64,
        samples_written: FLAC__uint64,
        frames_written: ::std::os::raw::c_uint,
        total_frames_estimate: ::std::os::raw::c_uint,
        client_data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    /// Create a new stream encoder instance.  The instance is created with
    /// default settings; see the individual FLAC__stream_encoder_set_*()
    /// functions for each setting's default.
    ///
    /// \retval FLAC__StreamEncoder*
    /// \c NULL if there was an error allocating memory, else the new instance.
    #[link_name = "\u{1}_FLAC__stream_encoder_new"]
    pub fn FLAC__stream_encoder_new() -> *mut FLAC__StreamEncoder;
}
extern "C" {
    /// Free an encoder instance.  Deletes the object pointed to by \a encoder.
    ///
    /// \param encoder  A pointer to an existing encoder.
    /// \assert
    /// \code encoder != NULL \endcode
    #[link_name = "\u{1}_FLAC__stream_encoder_delete"]
    pub fn FLAC__stream_encoder_delete(encoder: *mut FLAC__StreamEncoder);
}
extern "C" {
    /// Set the serial number for the FLAC stream to use in the Ogg container.
    ///
    /// \note
    /// This does not need to be set for native FLAC encoding.
    ///
    /// \note
    /// It is recommended to set a serial number explicitly as the default of '0'
    /// may collide with other streams.
    ///
    /// \default \c 0
    /// \param  encoder        An encoder instance to set.
    /// \param  serial_number  See above.
    /// \assert
    /// \code encoder != NULL \endcode
    /// \retval FLAC__bool
    /// \c false if the encoder is already initialized, else \c true.
    #[link_name = "\u{1}_FLAC__stream_encoder_set_ogg_serial_number"]
    pub fn FLAC__stream_encoder_set_ogg_serial_number(
        encoder: *mut FLAC__StreamEncoder,
        serial_number: ::std::os::raw::c_long,
    ) -> FLAC__bool;
}
extern "C" {
    /// Set the "verify" flag.  If \c true, the encoder will verify it's own
    /// encoded output by feeding it through an internal decoder and comparing
    /// the original signal against the decoded signal.  If a mismatch occurs,
    /// the process call will return \c false.  Note that this will slow the
    /// encoding process by the extra time required for decoding and comparison.
    ///
    /// \default \c false
    /// \param  encoder  An encoder instance to set.
    /// \param  value    Flag value (see above).
    /// \assert
    /// \code encoder != NULL \endcode
    /// \retval FLAC__bool
    /// \c false if the encoder is already initialized, else \c true.
    #[link_name = "\u{1}_FLAC__stream_encoder_set_verify"]
    pub fn FLAC__stream_encoder_set_verify(
        encoder: *mut FLAC__StreamEncoder,
        value: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    /// Set the <A HREF="../format.html#subset">Subset</A> flag.  If \c true,
    /// the encoder will comply with the Subset and will check the
    /// settings during FLAC__stream_encoder_init_*() to see if all settings
    /// comply.  If \c false, the settings may take advantage of the full
    /// range that the format allows.
    ///
    /// Make sure you know what it entails before setting this to \c false.
    ///
    /// \default \c true
    /// \param  encoder  An encoder instance to set.
    /// \param  value    Flag value (see above).
    /// \assert
    /// \code encoder != NULL \endcode
    /// \retval FLAC__bool
    /// \c false if the encoder is already initialized, else \c true.
    #[link_name = "\u{1}_FLAC__stream_encoder_set_streamable_subset"]
    pub fn FLAC__stream_encoder_set_streamable_subset(
        encoder: *mut FLAC__StreamEncoder,
        value: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    /// Set the number of channels to be encoded.
    ///
    /// \default \c 2
    /// \param  encoder  An encoder instance to set.
    /// \param  value    See above.
    /// \assert
    /// \code encoder != NULL \endcode
    /// \retval FLAC__bool
    /// \c false if the encoder is already initialized, else \c true.
    #[link_name = "\u{1}_FLAC__stream_encoder_set_channels"]
    pub fn FLAC__stream_encoder_set_channels(
        encoder: *mut FLAC__StreamEncoder,
        value: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    /// Set the sample resolution of the input to be encoded.
    ///
    /// \warning
    /// Do not feed the encoder data that is wider than the value you
    /// set here or you will generate an invalid stream.
    ///
    /// \default \c 16
    /// \param  encoder  An encoder instance to set.
    /// \param  value    See above.
    /// \assert
    /// \code encoder != NULL \endcode
    /// \retval FLAC__bool
    /// \c false if the encoder is already initialized, else \c true.
    #[link_name = "\u{1}_FLAC__stream_encoder_set_bits_per_sample"]
    pub fn FLAC__stream_encoder_set_bits_per_sample(
        encoder: *mut FLAC__StreamEncoder,
        value: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    /// Set the sample rate (in Hz) of the input to be encoded.
    ///
    /// \default \c 44100
    /// \param  encoder  An encoder instance to set.
    /// \param  value    See above.
    /// \assert
    /// \code encoder != NULL \endcode
    /// \retval FLAC__bool
    /// \c false if the encoder is already initialized, else \c true.
    #[link_name = "\u{1}_FLAC__stream_encoder_set_sample_rate"]
    pub fn FLAC__stream_encoder_set_sample_rate(
        encoder: *mut FLAC__StreamEncoder,
        value: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    /// Set the compression level
    ///
    /// The compression level is roughly proportional to the amount of effort
    /// the encoder expends to compress the file.  A higher level usually
    /// means more computation but higher compression.  The default level is
    /// suitable for most applications.
    ///
    /// Currently the levels range from \c 0 (fastest, least compression) to
    /// \c 8 (slowest, most compression).  A value larger than \c 8 will be
    /// treated as \c 8.
    ///
    /// This function automatically calls the following other \c _set_
    /// functions with appropriate values, so the client does not need to
    /// unless it specifically wants to override them:
    /// - FLAC__stream_encoder_set_do_mid_side_stereo()
    /// - FLAC__stream_encoder_set_loose_mid_side_stereo()
    /// - FLAC__stream_encoder_set_apodization()
    /// - FLAC__stream_encoder_set_max_lpc_order()
    /// - FLAC__stream_encoder_set_qlp_coeff_precision()
    /// - FLAC__stream_encoder_set_do_qlp_coeff_prec_search()
    /// - FLAC__stream_encoder_set_do_escape_coding()
    /// - FLAC__stream_encoder_set_do_exhaustive_model_search()
    /// - FLAC__stream_encoder_set_min_residual_partition_order()
    /// - FLAC__stream_encoder_set_max_residual_partition_order()
    /// - FLAC__stream_encoder_set_rice_parameter_search_dist()
    ///
    /// The actual values set for each level are:
    /// <table>
    /// <tr>
    /// <td><b>level</b></td>
    /// <td>do mid-side stereo</td>
    /// <td>loose mid-side stereo</td>
    /// <td>apodization</td>
    /// <td>max lpc order</td>
    /// <td>qlp coeff precision</td>
    /// <td>qlp coeff prec search</td>
    /// <td>escape coding</td>
    /// <td>exhaustive model search</td>
    /// <td>min residual partition order</td>
    /// <td>max residual partition order</td>
    /// <td>rice parameter search dist</td>
    /// </tr>
    /// <tr>  <td><b>0</b></td> <td>false</td> <td>false</td> <td>tukey(0.5)<td>                                     <td>0</td>  <td>0</td> <td>false</td> <td>false</td> <td>false</td> <td>0</td> <td>3</td> <td>0</td> </tr>
    /// <tr>  <td><b>1</b></td> <td>true</td>  <td>true</td>  <td>tukey(0.5)<td>                                     <td>0</td>  <td>0</td> <td>false</td> <td>false</td> <td>false</td> <td>0</td> <td>3</td> <td>0</td> </tr>
    /// <tr>  <td><b>2</b></td> <td>true</td>  <td>false</td> <td>tukey(0.5)<td>                                     <td>0</td>  <td>0</td> <td>false</td> <td>false</td> <td>false</td> <td>0</td> <td>3</td> <td>0</td> </tr>
    /// <tr>  <td><b>3</b></td> <td>false</td> <td>false</td> <td>tukey(0.5)<td>                                     <td>6</td>  <td>0</td> <td>false</td> <td>false</td> <td>false</td> <td>0</td> <td>4</td> <td>0</td> </tr>
    /// <tr>  <td><b>4</b></td> <td>true</td>  <td>true</td>  <td>tukey(0.5)<td>                                     <td>8</td>  <td>0</td> <td>false</td> <td>false</td> <td>false</td> <td>0</td> <td>4</td> <td>0</td> </tr>
    /// <tr>  <td><b>5</b></td> <td>true</td>  <td>false</td> <td>tukey(0.5)<td>                                     <td>8</td>  <td>0</td> <td>false</td> <td>false</td> <td>false</td> <td>0</td> <td>5</td> <td>0</td> </tr>
    /// <tr>  <td><b>6</b></td> <td>true</td>  <td>false</td> <td>tukey(0.5);partial_tukey(2)<td>                    <td>8</td>  <td>0</td> <td>false</td> <td>false</td> <td>false</td> <td>0</td> <td>6</td> <td>0</td> </tr>
    /// <tr>  <td><b>7</b></td> <td>true</td>  <td>false</td> <td>tukey(0.5);partial_tukey(2)<td>                    <td>12</td> <td>0</td> <td>false</td> <td>false</td> <td>false</td> <td>0</td> <td>6</td> <td>0</td> </tr>
    /// <tr>  <td><b>8</b></td> <td>true</td>  <td>false</td> <td>tukey(0.5);partial_tukey(2);punchout_tukey(3)</td> <td>12</td> <td>0</td> <td>false</td> <td>false</td> <td>false</td> <td>0</td> <td>6</td> <td>0</td> </tr>
    /// </table>
    ///
    /// \default \c 5
    /// \param  encoder  An encoder instance to set.
    /// \param  value    See above.
    /// \assert
    /// \code encoder != NULL \endcode
    /// \retval FLAC__bool
    /// \c false if the encoder is already initialized, else \c true.
    #[link_name = "\u{1}_FLAC__stream_encoder_set_compression_level"]
    pub fn FLAC__stream_encoder_set_compression_level(
        encoder: *mut FLAC__StreamEncoder,
        value: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    /// Set the blocksize to use while encoding.
    ///
    /// The number of samples to use per frame.  Use \c 0 to let the encoder
    /// estimate a blocksize; this is usually best.
    ///
    /// \default \c 0
    /// \param  encoder  An encoder instance to set.
    /// \param  value    See above.
    /// \assert
    /// \code encoder != NULL \endcode
    /// \retval FLAC__bool
    /// \c false if the encoder is already initialized, else \c true.
    #[link_name = "\u{1}_FLAC__stream_encoder_set_blocksize"]
    pub fn FLAC__stream_encoder_set_blocksize(
        encoder: *mut FLAC__StreamEncoder,
        value: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    /// Set to \c true to enable mid-side encoding on stereo input.  The
    /// number of channels must be 2 for this to have any effect.  Set to
    /// \c false to use only independent channel coding.
    ///
    /// \default \c false
    /// \param  encoder  An encoder instance to set.
    /// \param  value    Flag value (see above).
    /// \assert
    /// \code encoder != NULL \endcode
    /// \retval FLAC__bool
    /// \c false if the encoder is already initialized, else \c true.
    #[link_name = "\u{1}_FLAC__stream_encoder_set_do_mid_side_stereo"]
    pub fn FLAC__stream_encoder_set_do_mid_side_stereo(
        encoder: *mut FLAC__StreamEncoder,
        value: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    /// Set to \c true to enable adaptive switching between mid-side and
    /// left-right encoding on stereo input.  Set to \c false to use
    /// exhaustive searching.  Setting this to \c true requires
    /// FLAC__stream_encoder_set_do_mid_side_stereo() to also be set to
    /// \c true in order to have any effect.
    ///
    /// \default \c false
    /// \param  encoder  An encoder instance to set.
    /// \param  value    Flag value (see above).
    /// \assert
    /// \code encoder != NULL \endcode
    /// \retval FLAC__bool
    /// \c false if the encoder is already initialized, else \c true.
    #[link_name = "\u{1}_FLAC__stream_encoder_set_loose_mid_side_stereo"]
    pub fn FLAC__stream_encoder_set_loose_mid_side_stereo(
        encoder: *mut FLAC__StreamEncoder,
        value: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    /// Sets the apodization function(s) the encoder will use when windowing
    /// audio data for LPC analysis.
    ///
    /// The \a specification is a plain ASCII string which specifies exactly
    /// which functions to use.  There may be more than one (up to 32),
    /// separated by \c ';' characters.  Some functions take one or more
    /// comma-separated arguments in parentheses.
    ///
    /// The available functions are \c bartlett, \c bartlett_hann,
    /// \c blackman, \c blackman_harris_4term_92db, \c connes, \c flattop,
    /// \c gauss(STDDEV), \c hamming, \c hann, \c kaiser_bessel, \c nuttall,
    /// \c rectangle, \c triangle, \c tukey(P), \c partial_tukey(n[/ov[/P]]),
    /// \c punchout_tukey(n[/ov[/P]]), \c welch.
    ///
    /// For \c gauss(STDDEV), STDDEV specifies the standard deviation
    /// (0<STDDEV<=0.5).
    ///
    /// For \c tukey(P), P specifies the fraction of the window that is
    /// tapered (0<=P<=1).  P=0 corresponds to \c rectangle and P=1
    /// corresponds to \c hann.
    ///
    /// Specifying \c partial_tukey or \c punchout_tukey works a little
    /// different. These do not specify a single apodization function, but
    /// a series of them with some overlap. partial_tukey specifies a series
    /// of small windows (all treated separately) while punchout_tukey
    /// specifies a series of windows that have a hole in them. In this way,
    /// the predictor is constructed with only a part of the block, which
    /// helps in case a block consists of dissimilar parts.
    ///
    /// The three parameters that can be specified for the functions are
    /// n, ov and P. n is the number of functions to add, ov is the overlap
    /// of the windows in case of partial_tukey and the overlap in the gaps
    /// in case of punchout_tukey. P is the fraction of the window that is
    /// tapered, like with a regular tukey window. The function can be
    /// specified with only a number, a number and an overlap, or a number
    /// an overlap and a P, for example, partial_tukey(3), partial_tukey(3/0.3)
    /// and partial_tukey(3/0.3/0.5) are all valid. ov should be smaller than 1
    /// and can be negative.
    ///
    /// Example specifications are \c "blackman" or
    /// \c "hann;triangle;tukey(0.5);tukey(0.25);tukey(0.125)"
    ///
    /// Any function that is specified erroneously is silently dropped.  Up
    /// to 32 functions are kept, the rest are dropped.  If the specification
    /// is empty the encoder defaults to \c "tukey(0.5)".
    ///
    /// When more than one function is specified, then for every subframe the
    /// encoder will try each of them separately and choose the window that
    /// results in the smallest compressed subframe.
    ///
    /// Note that each function specified causes the encoder to occupy a
    /// floating point array in which to store the window. Also note that the
    /// values of P, STDDEV and ov are locale-specific, so if the comma
    /// separator specified by the locale is a comma, a comma should be used.
    ///
    /// \default \c "tukey(0.5)"
    /// \param  encoder        An encoder instance to set.
    /// \param  specification  See above.
    /// \assert
    /// \code encoder != NULL \endcode
    /// \code specification != NULL \endcode
    /// \retval FLAC__bool
    /// \c false if the encoder is already initialized, else \c true.
    #[link_name = "\u{1}_FLAC__stream_encoder_set_apodization"]
    pub fn FLAC__stream_encoder_set_apodization(
        encoder: *mut FLAC__StreamEncoder,
        specification: *const ::std::os::raw::c_char,
    ) -> FLAC__bool;
}
extern "C" {
    /// Set the maximum LPC order, or \c 0 to use only the fixed predictors.
    ///
    /// \default \c 0
    /// \param  encoder  An encoder instance to set.
    /// \param  value    See above.
    /// \assert
    /// \code encoder != NULL \endcode
    /// \retval FLAC__bool
    /// \c false if the encoder is already initialized, else \c true.
    #[link_name = "\u{1}_FLAC__stream_encoder_set_max_lpc_order"]
    pub fn FLAC__stream_encoder_set_max_lpc_order(
        encoder: *mut FLAC__StreamEncoder,
        value: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    /// Set the precision, in bits, of the quantized linear predictor
    /// coefficients, or \c 0 to let the encoder select it based on the
    /// blocksize.
    ///
    /// \note
    /// In the current implementation, qlp_coeff_precision + bits_per_sample must
    /// be less than 32.
    ///
    /// \default \c 0
    /// \param  encoder  An encoder instance to set.
    /// \param  value    See above.
    /// \assert
    /// \code encoder != NULL \endcode
    /// \retval FLAC__bool
    /// \c false if the encoder is already initialized, else \c true.
    #[link_name = "\u{1}_FLAC__stream_encoder_set_qlp_coeff_precision"]
    pub fn FLAC__stream_encoder_set_qlp_coeff_precision(
        encoder: *mut FLAC__StreamEncoder,
        value: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    /// Set to \c false to use only the specified quantized linear predictor
    /// coefficient precision, or \c true to search neighboring precision
    /// values and use the best one.
    ///
    /// \default \c false
    /// \param  encoder  An encoder instance to set.
    /// \param  value    See above.
    /// \assert
    /// \code encoder != NULL \endcode
    /// \retval FLAC__bool
    /// \c false if the encoder is already initialized, else \c true.
    #[link_name = "\u{1}_FLAC__stream_encoder_set_do_qlp_coeff_prec_search"]
    pub fn FLAC__stream_encoder_set_do_qlp_coeff_prec_search(
        encoder: *mut FLAC__StreamEncoder,
        value: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    /// Deprecated.  Setting this value has no effect.
    ///
    /// \default \c false
    /// \param  encoder  An encoder instance to set.
    /// \param  value    See above.
    /// \assert
    /// \code encoder != NULL \endcode
    /// \retval FLAC__bool
    /// \c false if the encoder is already initialized, else \c true.
    #[link_name = "\u{1}_FLAC__stream_encoder_set_do_escape_coding"]
    pub fn FLAC__stream_encoder_set_do_escape_coding(
        encoder: *mut FLAC__StreamEncoder,
        value: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    /// Set to \c false to let the encoder estimate the best model order
    /// based on the residual signal energy, or \c true to force the
    /// encoder to evaluate all order models and select the best.
    ///
    /// \default \c false
    /// \param  encoder  An encoder instance to set.
    /// \param  value    See above.
    /// \assert
    /// \code encoder != NULL \endcode
    /// \retval FLAC__bool
    /// \c false if the encoder is already initialized, else \c true.
    #[link_name = "\u{1}_FLAC__stream_encoder_set_do_exhaustive_model_search"]
    pub fn FLAC__stream_encoder_set_do_exhaustive_model_search(
        encoder: *mut FLAC__StreamEncoder,
        value: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    /// Set the minimum partition order to search when coding the residual.
    /// This is used in tandem with
    /// FLAC__stream_encoder_set_max_residual_partition_order().
    ///
    /// The partition order determines the context size in the residual.
    /// The context size will be approximately <tt>blocksize / (2 ^ order)</tt>.
    ///
    /// Set both min and max values to \c 0 to force a single context,
    /// whose Rice parameter is based on the residual signal variance.
    /// Otherwise, set a min and max order, and the encoder will search
    /// all orders, using the mean of each context for its Rice parameter,
    /// and use the best.
    ///
    /// \default \c 0
    /// \param  encoder  An encoder instance to set.
    /// \param  value    See above.
    /// \assert
    /// \code encoder != NULL \endcode
    /// \retval FLAC__bool
    /// \c false if the encoder is already initialized, else \c true.
    #[link_name = "\u{1}_FLAC__stream_encoder_set_min_residual_partition_order"]
    pub fn FLAC__stream_encoder_set_min_residual_partition_order(
        encoder: *mut FLAC__StreamEncoder,
        value: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    /// Set the maximum partition order to search when coding the residual.
    /// This is used in tandem with
    /// FLAC__stream_encoder_set_min_residual_partition_order().
    ///
    /// The partition order determines the context size in the residual.
    /// The context size will be approximately <tt>blocksize / (2 ^ order)</tt>.
    ///
    /// Set both min and max values to \c 0 to force a single context,
    /// whose Rice parameter is based on the residual signal variance.
    /// Otherwise, set a min and max order, and the encoder will search
    /// all orders, using the mean of each context for its Rice parameter,
    /// and use the best.
    ///
    /// \default \c 0
    /// \param  encoder  An encoder instance to set.
    /// \param  value    See above.
    /// \assert
    /// \code encoder != NULL \endcode
    /// \retval FLAC__bool
    /// \c false if the encoder is already initialized, else \c true.
    #[link_name = "\u{1}_FLAC__stream_encoder_set_max_residual_partition_order"]
    pub fn FLAC__stream_encoder_set_max_residual_partition_order(
        encoder: *mut FLAC__StreamEncoder,
        value: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    /// Deprecated.  Setting this value has no effect.
    ///
    /// \default \c 0
    /// \param  encoder  An encoder instance to set.
    /// \param  value    See above.
    /// \assert
    /// \code encoder != NULL \endcode
    /// \retval FLAC__bool
    /// \c false if the encoder is already initialized, else \c true.
    #[link_name = "\u{1}_FLAC__stream_encoder_set_rice_parameter_search_dist"]
    pub fn FLAC__stream_encoder_set_rice_parameter_search_dist(
        encoder: *mut FLAC__StreamEncoder,
        value: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    /// Set an estimate of the total samples that will be encoded.
    /// This is merely an estimate and may be set to \c 0 if unknown.
    /// This value will be written to the STREAMINFO block before encoding,
    /// and can remove the need for the caller to rewrite the value later
    /// if the value is known before encoding.
    ///
    /// \default \c 0
    /// \param  encoder  An encoder instance to set.
    /// \param  value    See above.
    /// \assert
    /// \code encoder != NULL \endcode
    /// \retval FLAC__bool
    /// \c false if the encoder is already initialized, else \c true.
    #[link_name = "\u{1}_FLAC__stream_encoder_set_total_samples_estimate"]
    pub fn FLAC__stream_encoder_set_total_samples_estimate(
        encoder: *mut FLAC__StreamEncoder,
        value: FLAC__uint64,
    ) -> FLAC__bool;
}
extern "C" {
    /// Set the metadata blocks to be emitted to the stream before encoding.
    /// A value of \c NULL, \c 0 implies no metadata; otherwise, supply an
    /// array of pointers to metadata blocks.  The array is non-const since
    /// the encoder may need to change the \a is_last flag inside them, and
    /// in some cases update seek point offsets.  Otherwise, the encoder will
    /// not modify or free the blocks.  It is up to the caller to free the
    /// metadata blocks after encoding finishes.
    ///
    /// \note
    /// The encoder stores only copies of the pointers in the \a metadata array;
    /// the metadata blocks themselves must survive at least until after
    /// FLAC__stream_encoder_finish() returns.  Do not free the blocks until then.
    ///
    /// \note
    /// The STREAMINFO block is always written and no STREAMINFO block may
    /// occur in the supplied array.
    ///
    /// \note
    /// By default the encoder does not create a SEEKTABLE.  If one is supplied
    /// in the \a metadata array, but the client has specified that it does not
    /// support seeking, then the SEEKTABLE will be written verbatim.  However
    /// by itself this is not very useful as the client will not know the stream
    /// offsets for the seekpoints ahead of time.  In order to get a proper
    /// seektable the client must support seeking.  See next note.
    ///
    /// \note
    /// SEEKTABLE blocks are handled specially.  Since you will not know
    /// the values for the seek point stream offsets, you should pass in
    /// a SEEKTABLE 'template', that is, a SEEKTABLE object with the
    /// required sample numbers (or placeholder points), with \c 0 for the
    /// \a frame_samples and \a stream_offset fields for each point.  If the
    /// client has specified that it supports seeking by providing a seek
    /// callback to FLAC__stream_encoder_init_stream() or both seek AND read
    /// callback to FLAC__stream_encoder_init_ogg_stream() (or by using
    /// FLAC__stream_encoder_init*_file() or FLAC__stream_encoder_init*_FILE()),
    /// then while it is encoding the encoder will fill the stream offsets in
    /// for you and when encoding is finished, it will seek back and write the
    /// real values into the SEEKTABLE block in the stream.  There are helper
    /// routines for manipulating seektable template blocks; see metadata.h:
    /// FLAC__metadata_object_seektable_template_*().  If the client does
    /// not support seeking, the SEEKTABLE will have inaccurate offsets which
    /// will slow down or remove the ability to seek in the FLAC stream.
    ///
    /// \note
    /// The encoder instance \b will modify the first \c SEEKTABLE block
    /// as it transforms the template to a valid seektable while encoding,
    /// but it is still up to the caller to free all metadata blocks after
    /// encoding.
    ///
    /// \note
    /// A VORBIS_COMMENT block may be supplied.  The vendor string in it
    /// will be ignored.  libFLAC will use it's own vendor string. libFLAC
    /// will not modify the passed-in VORBIS_COMMENT's vendor string, it
    /// will simply write it's own into the stream.  If no VORBIS_COMMENT
    /// block is present in the \a metadata array, libFLAC will write an
    /// empty one, containing only the vendor string.
    ///
    /// \note The Ogg FLAC mapping requires that the VORBIS_COMMENT block be
    /// the second metadata block of the stream.  The encoder already supplies
    /// the STREAMINFO block automatically.  If \a metadata does not contain a
    /// VORBIS_COMMENT block, the encoder will supply that too.  Otherwise, if
    /// \a metadata does contain a VORBIS_COMMENT block and it is not the
    /// first, the init function will reorder \a metadata by moving the
    /// VORBIS_COMMENT block to the front; the relative ordering of the other
    /// blocks will remain as they were.
    ///
    /// \note The Ogg FLAC mapping limits the number of metadata blocks per
    /// stream to \c 65535.  If \a num_blocks exceeds this the function will
    /// return \c false.
    ///
    /// \default \c NULL, 0
    /// \param  encoder     An encoder instance to set.
    /// \param  metadata    See above.
    /// \param  num_blocks  See above.
    /// \assert
    /// \code encoder != NULL \endcode
    /// \retval FLAC__bool
    /// \c false if the encoder is already initialized, else \c true.
    /// \c false if the encoder is already initialized, or if
    /// \a num_blocks > 65535 if encoding to Ogg FLAC, else \c true.
    #[link_name = "\u{1}_FLAC__stream_encoder_set_metadata"]
    pub fn FLAC__stream_encoder_set_metadata(
        encoder: *mut FLAC__StreamEncoder,
        metadata: *mut *mut FLAC__StreamMetadata,
        num_blocks: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    /// Get the current encoder state.
    ///
    /// \param  encoder  An encoder instance to query.
    /// \assert
    /// \code encoder != NULL \endcode
    /// \retval FLAC__StreamEncoderState
    /// The current encoder state.
    #[link_name = "\u{1}_FLAC__stream_encoder_get_state"]
    pub fn FLAC__stream_encoder_get_state(
        encoder: *const FLAC__StreamEncoder,
    ) -> FLAC__StreamEncoderState;
}
extern "C" {
    /// Get the state of the verify stream decoder.
    /// Useful when the stream encoder state is
    /// \c FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR.
    ///
    /// \param  encoder  An encoder instance to query.
    /// \assert
    /// \code encoder != NULL \endcode
    /// \retval FLAC__StreamDecoderState
    /// The verify stream decoder state.
    #[link_name = "\u{1}_FLAC__stream_encoder_get_verify_decoder_state"]
    pub fn FLAC__stream_encoder_get_verify_decoder_state(
        encoder: *const FLAC__StreamEncoder,
    ) -> FLAC__StreamDecoderState;
}
extern "C" {
    /// Get the current encoder state as a C string.
    /// This version automatically resolves
    /// \c FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR by getting the
    /// verify decoder's state.
    ///
    /// \param  encoder  A encoder instance to query.
    /// \assert
    /// \code encoder != NULL \endcode
    /// \retval const char *
    /// The encoder state as a C string.  Do not modify the contents.
    #[link_name = "\u{1}_FLAC__stream_encoder_get_resolved_state_string"]
    pub fn FLAC__stream_encoder_get_resolved_state_string(
        encoder: *const FLAC__StreamEncoder,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Get relevant values about the nature of a verify decoder error.
    /// Useful when the stream encoder state is
    /// \c FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR.  The arguments should
    /// be addresses in which the stats will be returned, or NULL if value
    /// is not desired.
    ///
    /// \param  encoder  An encoder instance to query.
    /// \param  absolute_sample  The absolute sample number of the mismatch.
    /// \param  frame_number  The number of the frame in which the mismatch occurred.
    /// \param  channel       The channel in which the mismatch occurred.
    /// \param  sample        The number of the sample (relative to the frame) in
    /// which the mismatch occurred.
    /// \param  expected      The expected value for the sample in question.
    /// \param  got           The actual value returned by the decoder.
    /// \assert
    /// \code encoder != NULL \endcode
    #[link_name = "\u{1}_FLAC__stream_encoder_get_verify_decoder_error_stats"]
    pub fn FLAC__stream_encoder_get_verify_decoder_error_stats(
        encoder: *const FLAC__StreamEncoder,
        absolute_sample: *mut FLAC__uint64,
        frame_number: *mut ::std::os::raw::c_uint,
        channel: *mut ::std::os::raw::c_uint,
        sample: *mut ::std::os::raw::c_uint,
        expected: *mut FLAC__int32,
        got: *mut FLAC__int32,
    );
}
extern "C" {
    /// Get the "verify" flag.
    ///
    /// \param  encoder  An encoder instance to query.
    /// \assert
    /// \code encoder != NULL \endcode
    /// \retval FLAC__bool
    /// See FLAC__stream_encoder_set_verify().
    #[link_name = "\u{1}_FLAC__stream_encoder_get_verify"]
    pub fn FLAC__stream_encoder_get_verify(encoder: *const FLAC__StreamEncoder) -> FLAC__bool;
}
extern "C" {
    /// Get the <A HREF="../format.html#subset>Subset</A> flag.
    ///
    /// \param  encoder  An encoder instance to query.
    /// \assert
    /// \code encoder != NULL \endcode
    /// \retval FLAC__bool
    /// See FLAC__stream_encoder_set_streamable_subset().
    #[link_name = "\u{1}_FLAC__stream_encoder_get_streamable_subset"]
    pub fn FLAC__stream_encoder_get_streamable_subset(
        encoder: *const FLAC__StreamEncoder,
    ) -> FLAC__bool;
}
extern "C" {
    /// Get the number of input channels being processed.
    ///
    /// \param  encoder  An encoder instance to query.
    /// \assert
    /// \code encoder != NULL \endcode
    /// \retval unsigned
    /// See FLAC__stream_encoder_set_channels().
    #[link_name = "\u{1}_FLAC__stream_encoder_get_channels"]
    pub fn FLAC__stream_encoder_get_channels(
        encoder: *const FLAC__StreamEncoder,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    /// Get the input sample resolution setting.
    ///
    /// \param  encoder  An encoder instance to query.
    /// \assert
    /// \code encoder != NULL \endcode
    /// \retval unsigned
    /// See FLAC__stream_encoder_set_bits_per_sample().
    #[link_name = "\u{1}_FLAC__stream_encoder_get_bits_per_sample"]
    pub fn FLAC__stream_encoder_get_bits_per_sample(
        encoder: *const FLAC__StreamEncoder,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    /// Get the input sample rate setting.
    ///
    /// \param  encoder  An encoder instance to query.
    /// \assert
    /// \code encoder != NULL \endcode
    /// \retval unsigned
    /// See FLAC__stream_encoder_set_sample_rate().
    #[link_name = "\u{1}_FLAC__stream_encoder_get_sample_rate"]
    pub fn FLAC__stream_encoder_get_sample_rate(
        encoder: *const FLAC__StreamEncoder,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    /// Get the blocksize setting.
    ///
    /// \param  encoder  An encoder instance to query.
    /// \assert
    /// \code encoder != NULL \endcode
    /// \retval unsigned
    /// See FLAC__stream_encoder_set_blocksize().
    #[link_name = "\u{1}_FLAC__stream_encoder_get_blocksize"]
    pub fn FLAC__stream_encoder_get_blocksize(
        encoder: *const FLAC__StreamEncoder,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    /// Get the "mid/side stereo coding" flag.
    ///
    /// \param  encoder  An encoder instance to query.
    /// \assert
    /// \code encoder != NULL \endcode
    /// \retval FLAC__bool
    /// See FLAC__stream_encoder_get_do_mid_side_stereo().
    #[link_name = "\u{1}_FLAC__stream_encoder_get_do_mid_side_stereo"]
    pub fn FLAC__stream_encoder_get_do_mid_side_stereo(
        encoder: *const FLAC__StreamEncoder,
    ) -> FLAC__bool;
}
extern "C" {
    /// Get the "adaptive mid/side switching" flag.
    ///
    /// \param  encoder  An encoder instance to query.
    /// \assert
    /// \code encoder != NULL \endcode
    /// \retval FLAC__bool
    /// See FLAC__stream_encoder_set_loose_mid_side_stereo().
    #[link_name = "\u{1}_FLAC__stream_encoder_get_loose_mid_side_stereo"]
    pub fn FLAC__stream_encoder_get_loose_mid_side_stereo(
        encoder: *const FLAC__StreamEncoder,
    ) -> FLAC__bool;
}
extern "C" {
    /// Get the maximum LPC order setting.
    ///
    /// \param  encoder  An encoder instance to query.
    /// \assert
    /// \code encoder != NULL \endcode
    /// \retval unsigned
    /// See FLAC__stream_encoder_set_max_lpc_order().
    #[link_name = "\u{1}_FLAC__stream_encoder_get_max_lpc_order"]
    pub fn FLAC__stream_encoder_get_max_lpc_order(
        encoder: *const FLAC__StreamEncoder,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    /// Get the quantized linear predictor coefficient precision setting.
    ///
    /// \param  encoder  An encoder instance to query.
    /// \assert
    /// \code encoder != NULL \endcode
    /// \retval unsigned
    /// See FLAC__stream_encoder_set_qlp_coeff_precision().
    #[link_name = "\u{1}_FLAC__stream_encoder_get_qlp_coeff_precision"]
    pub fn FLAC__stream_encoder_get_qlp_coeff_precision(
        encoder: *const FLAC__StreamEncoder,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    /// Get the qlp coefficient precision search flag.
    ///
    /// \param  encoder  An encoder instance to query.
    /// \assert
    /// \code encoder != NULL \endcode
    /// \retval FLAC__bool
    /// See FLAC__stream_encoder_set_do_qlp_coeff_prec_search().
    #[link_name = "\u{1}_FLAC__stream_encoder_get_do_qlp_coeff_prec_search"]
    pub fn FLAC__stream_encoder_get_do_qlp_coeff_prec_search(
        encoder: *const FLAC__StreamEncoder,
    ) -> FLAC__bool;
}
extern "C" {
    /// Get the "escape coding" flag.
    ///
    /// \param  encoder  An encoder instance to query.
    /// \assert
    /// \code encoder != NULL \endcode
    /// \retval FLAC__bool
    /// See FLAC__stream_encoder_set_do_escape_coding().
    #[link_name = "\u{1}_FLAC__stream_encoder_get_do_escape_coding"]
    pub fn FLAC__stream_encoder_get_do_escape_coding(
        encoder: *const FLAC__StreamEncoder,
    ) -> FLAC__bool;
}
extern "C" {
    /// Get the exhaustive model search flag.
    ///
    /// \param  encoder  An encoder instance to query.
    /// \assert
    /// \code encoder != NULL \endcode
    /// \retval FLAC__bool
    /// See FLAC__stream_encoder_set_do_exhaustive_model_search().
    #[link_name = "\u{1}_FLAC__stream_encoder_get_do_exhaustive_model_search"]
    pub fn FLAC__stream_encoder_get_do_exhaustive_model_search(
        encoder: *const FLAC__StreamEncoder,
    ) -> FLAC__bool;
}
extern "C" {
    /// Get the minimum residual partition order setting.
    ///
    /// \param  encoder  An encoder instance to query.
    /// \assert
    /// \code encoder != NULL \endcode
    /// \retval unsigned
    /// See FLAC__stream_encoder_set_min_residual_partition_order().
    #[link_name = "\u{1}_FLAC__stream_encoder_get_min_residual_partition_order"]
    pub fn FLAC__stream_encoder_get_min_residual_partition_order(
        encoder: *const FLAC__StreamEncoder,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    /// Get maximum residual partition order setting.
    ///
    /// \param  encoder  An encoder instance to query.
    /// \assert
    /// \code encoder != NULL \endcode
    /// \retval unsigned
    /// See FLAC__stream_encoder_set_max_residual_partition_order().
    #[link_name = "\u{1}_FLAC__stream_encoder_get_max_residual_partition_order"]
    pub fn FLAC__stream_encoder_get_max_residual_partition_order(
        encoder: *const FLAC__StreamEncoder,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    /// Get the Rice parameter search distance setting.
    ///
    /// \param  encoder  An encoder instance to query.
    /// \assert
    /// \code encoder != NULL \endcode
    /// \retval unsigned
    /// See FLAC__stream_encoder_set_rice_parameter_search_dist().
    #[link_name = "\u{1}_FLAC__stream_encoder_get_rice_parameter_search_dist"]
    pub fn FLAC__stream_encoder_get_rice_parameter_search_dist(
        encoder: *const FLAC__StreamEncoder,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    /// Get the previously set estimate of the total samples to be encoded.
    /// The encoder merely mimics back the value given to
    /// FLAC__stream_encoder_set_total_samples_estimate() since it has no
    /// other way of knowing how many samples the client will encode.
    ///
    /// \param  encoder  An encoder instance to set.
    /// \assert
    /// \code encoder != NULL \endcode
    /// \retval FLAC__uint64
    /// See FLAC__stream_encoder_get_total_samples_estimate().
    #[link_name = "\u{1}_FLAC__stream_encoder_get_total_samples_estimate"]
    pub fn FLAC__stream_encoder_get_total_samples_estimate(
        encoder: *const FLAC__StreamEncoder,
    ) -> FLAC__uint64;
}
extern "C" {
    /// Initialize the encoder instance to encode native FLAC streams.
    ///
    /// This flavor of initialization sets up the encoder to encode to a
    /// native FLAC stream. I/O is performed via callbacks to the client.
    /// For encoding to a plain file via filename or open \c FILE*,
    /// FLAC__stream_encoder_init_file() and FLAC__stream_encoder_init_FILE()
    /// provide a simpler interface.
    ///
    /// This function should be called after FLAC__stream_encoder_new() and
    /// FLAC__stream_encoder_set_*() but before FLAC__stream_encoder_process()
    /// or FLAC__stream_encoder_process_interleaved().
    /// initialization succeeded.
    ///
    /// The call to FLAC__stream_encoder_init_stream() currently will also
    /// immediately call the write callback several times, once with the \c fLaC
    /// signature, and once for each encoded metadata block.
    ///
    /// \param  encoder            An uninitialized encoder instance.
    /// \param  write_callback     See FLAC__StreamEncoderWriteCallback.  This
    /// pointer must not be \c NULL.
    /// \param  seek_callback      See FLAC__StreamEncoderSeekCallback.  This
    /// pointer may be \c NULL if seeking is not
    /// supported.  The encoder uses seeking to go back
    /// and write some some stream statistics to the
    /// STREAMINFO block; this is recommended but not
    /// necessary to create a valid FLAC stream.  If
    /// \a seek_callback is not \c NULL then a
    /// \a tell_callback must also be supplied.
    /// Alternatively, a dummy seek callback that just
    /// returns \c FLAC__STREAM_ENCODER_SEEK_STATUS_UNSUPPORTED
    /// may also be supplied, all though this is slightly
    /// less efficient for the encoder.
    /// \param  tell_callback      See FLAC__StreamEncoderTellCallback.  This
    /// pointer may be \c NULL if seeking is not
    /// supported.  If \a seek_callback is \c NULL then
    /// this argument will be ignored.  If
    /// \a seek_callback is not \c NULL then a
    /// \a tell_callback must also be supplied.
    /// Alternatively, a dummy tell callback that just
    /// returns \c FLAC__STREAM_ENCODER_TELL_STATUS_UNSUPPORTED
    /// may also be supplied, all though this is slightly
    /// less efficient for the encoder.
    /// \param  metadata_callback  See FLAC__StreamEncoderMetadataCallback.  This
    /// pointer may be \c NULL if the callback is not
    /// desired.  If the client provides a seek callback,
    /// this function is not necessary as the encoder
    /// will automatically seek back and update the
    /// STREAMINFO block.  It may also be \c NULL if the
    /// client does not support seeking, since it will
    /// have no way of going back to update the
    /// STREAMINFO.  However the client can still supply
    /// a callback if it would like to know the details
    /// from the STREAMINFO.
    /// \param  client_data        This value will be supplied to callbacks in their
    /// \a client_data argument.
    /// \assert
    /// \code encoder != NULL \endcode
    /// \retval FLAC__StreamEncoderInitStatus
    /// \c FLAC__STREAM_ENCODER_INIT_STATUS_OK if initialization was successful;
    /// see FLAC__StreamEncoderInitStatus for the meanings of other return values.
    #[link_name = "\u{1}_FLAC__stream_encoder_init_stream"]
    pub fn FLAC__stream_encoder_init_stream(
        encoder: *mut FLAC__StreamEncoder,
        write_callback: FLAC__StreamEncoderWriteCallback,
        seek_callback: FLAC__StreamEncoderSeekCallback,
        tell_callback: FLAC__StreamEncoderTellCallback,
        metadata_callback: FLAC__StreamEncoderMetadataCallback,
        client_data: *mut ::std::os::raw::c_void,
    ) -> FLAC__StreamEncoderInitStatus;
}
extern "C" {
    /// Initialize the encoder instance to encode Ogg FLAC streams.
    ///
    /// This flavor of initialization sets up the encoder to encode to a FLAC
    /// stream in an Ogg container.  I/O is performed via callbacks to the
    /// client.  For encoding to a plain file via filename or open \c FILE*,
    /// FLAC__stream_encoder_init_ogg_file() and FLAC__stream_encoder_init_ogg_FILE()
    /// provide a simpler interface.
    ///
    /// This function should be called after FLAC__stream_encoder_new() and
    /// FLAC__stream_encoder_set_*() but before FLAC__stream_encoder_process()
    /// or FLAC__stream_encoder_process_interleaved().
    /// initialization succeeded.
    ///
    /// The call to FLAC__stream_encoder_init_ogg_stream() currently will also
    /// immediately call the write callback several times to write the metadata
    /// packets.
    ///
    /// \param  encoder            An uninitialized encoder instance.
    /// \param  read_callback      See FLAC__StreamEncoderReadCallback.  This
    /// pointer must not be \c NULL if \a seek_callback
    /// is non-NULL since they are both needed to be
    /// able to write data back to the Ogg FLAC stream
    /// in the post-encode phase.
    /// \param  write_callback     See FLAC__StreamEncoderWriteCallback.  This
    /// pointer must not be \c NULL.
    /// \param  seek_callback      See FLAC__StreamEncoderSeekCallback.  This
    /// pointer may be \c NULL if seeking is not
    /// supported.  The encoder uses seeking to go back
    /// and write some some stream statistics to the
    /// STREAMINFO block; this is recommended but not
    /// necessary to create a valid FLAC stream.  If
    /// \a seek_callback is not \c NULL then a
    /// \a tell_callback must also be supplied.
    /// Alternatively, a dummy seek callback that just
    /// returns \c FLAC__STREAM_ENCODER_SEEK_STATUS_UNSUPPORTED
    /// may also be supplied, all though this is slightly
    /// less efficient for the encoder.
    /// \param  tell_callback      See FLAC__StreamEncoderTellCallback.  This
    /// pointer may be \c NULL if seeking is not
    /// supported.  If \a seek_callback is \c NULL then
    /// this argument will be ignored.  If
    /// \a seek_callback is not \c NULL then a
    /// \a tell_callback must also be supplied.
    /// Alternatively, a dummy tell callback that just
    /// returns \c FLAC__STREAM_ENCODER_TELL_STATUS_UNSUPPORTED
    /// may also be supplied, all though this is slightly
    /// less efficient for the encoder.
    /// \param  metadata_callback  See FLAC__StreamEncoderMetadataCallback.  This
    /// pointer may be \c NULL if the callback is not
    /// desired.  If the client provides a seek callback,
    /// this function is not necessary as the encoder
    /// will automatically seek back and update the
    /// STREAMINFO block.  It may also be \c NULL if the
    /// client does not support seeking, since it will
    /// have no way of going back to update the
    /// STREAMINFO.  However the client can still supply
    /// a callback if it would like to know the details
    /// from the STREAMINFO.
    /// \param  client_data        This value will be supplied to callbacks in their
    /// \a client_data argument.
    /// \assert
    /// \code encoder != NULL \endcode
    /// \retval FLAC__StreamEncoderInitStatus
    /// \c FLAC__STREAM_ENCODER_INIT_STATUS_OK if initialization was successful;
    /// see FLAC__StreamEncoderInitStatus for the meanings of other return values.
    #[link_name = "\u{1}_FLAC__stream_encoder_init_ogg_stream"]
    pub fn FLAC__stream_encoder_init_ogg_stream(
        encoder: *mut FLAC__StreamEncoder,
        read_callback: FLAC__StreamEncoderReadCallback,
        write_callback: FLAC__StreamEncoderWriteCallback,
        seek_callback: FLAC__StreamEncoderSeekCallback,
        tell_callback: FLAC__StreamEncoderTellCallback,
        metadata_callback: FLAC__StreamEncoderMetadataCallback,
        client_data: *mut ::std::os::raw::c_void,
    ) -> FLAC__StreamEncoderInitStatus;
}
extern "C" {
    /// Initialize the encoder instance to encode native FLAC files.
    ///
    /// This flavor of initialization sets up the encoder to encode to a
    /// plain native FLAC file.  For non-stdio streams, you must use
    /// FLAC__stream_encoder_init_stream() and provide callbacks for the I/O.
    ///
    /// This function should be called after FLAC__stream_encoder_new() and
    /// FLAC__stream_encoder_set_*() but before FLAC__stream_encoder_process()
    /// or FLAC__stream_encoder_process_interleaved().
    /// initialization succeeded.
    ///
    /// \param  encoder            An uninitialized encoder instance.
    /// \param  file               An open file.  The file should have been opened
    /// with mode \c "w+b" and rewound.  The file
    /// becomes owned by the encoder and should not be
    /// manipulated by the client while encoding.
    /// Unless \a file is \c stdout, it will be closed
    /// when FLAC__stream_encoder_finish() is called.
    /// Note however that a proper SEEKTABLE cannot be
    /// created when encoding to \c stdout since it is
    /// not seekable.
    /// \param  progress_callback  See FLAC__StreamEncoderProgressCallback.  This
    /// pointer may be \c NULL if the callback is not
    /// desired.
    /// \param  client_data        This value will be supplied to callbacks in their
    /// \a client_data argument.
    /// \assert
    /// \code encoder != NULL \endcode
    /// \code file != NULL \endcode
    /// \retval FLAC__StreamEncoderInitStatus
    /// \c FLAC__STREAM_ENCODER_INIT_STATUS_OK if initialization was successful;
    /// see FLAC__StreamEncoderInitStatus for the meanings of other return values.
    #[link_name = "\u{1}_FLAC__stream_encoder_init_FILE"]
    pub fn FLAC__stream_encoder_init_FILE(
        encoder: *mut FLAC__StreamEncoder,
        file: *mut FILE,
        progress_callback: FLAC__StreamEncoderProgressCallback,
        client_data: *mut ::std::os::raw::c_void,
    ) -> FLAC__StreamEncoderInitStatus;
}
extern "C" {
    /// Initialize the encoder instance to encode Ogg FLAC files.
    ///
    /// This flavor of initialization sets up the encoder to encode to a
    /// plain Ogg FLAC file.  For non-stdio streams, you must use
    /// FLAC__stream_encoder_init_ogg_stream() and provide callbacks for the I/O.
    ///
    /// This function should be called after FLAC__stream_encoder_new() and
    /// FLAC__stream_encoder_set_*() but before FLAC__stream_encoder_process()
    /// or FLAC__stream_encoder_process_interleaved().
    /// initialization succeeded.
    ///
    /// \param  encoder            An uninitialized encoder instance.
    /// \param  file               An open file.  The file should have been opened
    /// with mode \c "w+b" and rewound.  The file
    /// becomes owned by the encoder and should not be
    /// manipulated by the client while encoding.
    /// Unless \a file is \c stdout, it will be closed
    /// when FLAC__stream_encoder_finish() is called.
    /// Note however that a proper SEEKTABLE cannot be
    /// created when encoding to \c stdout since it is
    /// not seekable.
    /// \param  progress_callback  See FLAC__StreamEncoderProgressCallback.  This
    /// pointer may be \c NULL if the callback is not
    /// desired.
    /// \param  client_data        This value will be supplied to callbacks in their
    /// \a client_data argument.
    /// \assert
    /// \code encoder != NULL \endcode
    /// \code file != NULL \endcode
    /// \retval FLAC__StreamEncoderInitStatus
    /// \c FLAC__STREAM_ENCODER_INIT_STATUS_OK if initialization was successful;
    /// see FLAC__StreamEncoderInitStatus for the meanings of other return values.
    #[link_name = "\u{1}_FLAC__stream_encoder_init_ogg_FILE"]
    pub fn FLAC__stream_encoder_init_ogg_FILE(
        encoder: *mut FLAC__StreamEncoder,
        file: *mut FILE,
        progress_callback: FLAC__StreamEncoderProgressCallback,
        client_data: *mut ::std::os::raw::c_void,
    ) -> FLAC__StreamEncoderInitStatus;
}
extern "C" {
    /// Initialize the encoder instance to encode native FLAC files.
    ///
    /// This flavor of initialization sets up the encoder to encode to a plain
    /// FLAC file.  If POSIX fopen() semantics are not sufficient (for example,
    /// with Unicode filenames on Windows), you must use
    /// FLAC__stream_encoder_init_FILE(), or FLAC__stream_encoder_init_stream()
    /// and provide callbacks for the I/O.
    ///
    /// This function should be called after FLAC__stream_encoder_new() and
    /// FLAC__stream_encoder_set_*() but before FLAC__stream_encoder_process()
    /// or FLAC__stream_encoder_process_interleaved().
    /// initialization succeeded.
    ///
    /// \param  encoder            An uninitialized encoder instance.
    /// \param  filename           The name of the file to encode to.  The file will
    /// be opened with fopen().  Use \c NULL to encode to
    /// \c stdout.  Note however that a proper SEEKTABLE
    /// cannot be created when encoding to \c stdout since
    /// it is not seekable.
    /// \param  progress_callback  See FLAC__StreamEncoderProgressCallback.  This
    /// pointer may be \c NULL if the callback is not
    /// desired.
    /// \param  client_data        This value will be supplied to callbacks in their
    /// \a client_data argument.
    /// \assert
    /// \code encoder != NULL \endcode
    /// \retval FLAC__StreamEncoderInitStatus
    /// \c FLAC__STREAM_ENCODER_INIT_STATUS_OK if initialization was successful;
    /// see FLAC__StreamEncoderInitStatus for the meanings of other return values.
    #[link_name = "\u{1}_FLAC__stream_encoder_init_file"]
    pub fn FLAC__stream_encoder_init_file(
        encoder: *mut FLAC__StreamEncoder,
        filename: *const ::std::os::raw::c_char,
        progress_callback: FLAC__StreamEncoderProgressCallback,
        client_data: *mut ::std::os::raw::c_void,
    ) -> FLAC__StreamEncoderInitStatus;
}
extern "C" {
    /// Initialize the encoder instance to encode Ogg FLAC files.
    ///
    /// This flavor of initialization sets up the encoder to encode to a plain
    /// Ogg FLAC file.  If POSIX fopen() semantics are not sufficient (for example,
    /// with Unicode filenames on Windows), you must use
    /// FLAC__stream_encoder_init_ogg_FILE(), or FLAC__stream_encoder_init_ogg_stream()
    /// and provide callbacks for the I/O.
    ///
    /// This function should be called after FLAC__stream_encoder_new() and
    /// FLAC__stream_encoder_set_*() but before FLAC__stream_encoder_process()
    /// or FLAC__stream_encoder_process_interleaved().
    /// initialization succeeded.
    ///
    /// \param  encoder            An uninitialized encoder instance.
    /// \param  filename           The name of the file to encode to.  The file will
    /// be opened with fopen().  Use \c NULL to encode to
    /// \c stdout.  Note however that a proper SEEKTABLE
    /// cannot be created when encoding to \c stdout since
    /// it is not seekable.
    /// \param  progress_callback  See FLAC__StreamEncoderProgressCallback.  This
    /// pointer may be \c NULL if the callback is not
    /// desired.
    /// \param  client_data        This value will be supplied to callbacks in their
    /// \a client_data argument.
    /// \assert
    /// \code encoder != NULL \endcode
    /// \retval FLAC__StreamEncoderInitStatus
    /// \c FLAC__STREAM_ENCODER_INIT_STATUS_OK if initialization was successful;
    /// see FLAC__StreamEncoderInitStatus for the meanings of other return values.
    #[link_name = "\u{1}_FLAC__stream_encoder_init_ogg_file"]
    pub fn FLAC__stream_encoder_init_ogg_file(
        encoder: *mut FLAC__StreamEncoder,
        filename: *const ::std::os::raw::c_char,
        progress_callback: FLAC__StreamEncoderProgressCallback,
        client_data: *mut ::std::os::raw::c_void,
    ) -> FLAC__StreamEncoderInitStatus;
}
extern "C" {
    /// Finish the encoding process.
    /// Flushes the encoding buffer, releases resources, resets the encoder
    /// settings to their defaults, and returns the encoder state to
    /// FLAC__STREAM_ENCODER_UNINITIALIZED.  Note that this can generate
    /// one or more write callbacks before returning, and will generate
    /// a metadata callback.
    ///
    /// Note that in the course of processing the last frame, errors can
    /// occur, so the caller should be sure to check the return value to
    /// ensure the file was encoded properly.
    ///
    /// In the event of a prematurely-terminated encode, it is not strictly
    /// necessary to call this immediately before FLAC__stream_encoder_delete()
    /// but it is good practice to match every FLAC__stream_encoder_init_*()
    /// with a FLAC__stream_encoder_finish().
    ///
    /// \param  encoder  An uninitialized encoder instance.
    /// \assert
    /// \code encoder != NULL \endcode
    /// \retval FLAC__bool
    /// \c false if an error occurred processing the last frame; or if verify
    /// mode is set (see FLAC__stream_encoder_set_verify()), there was a
    /// verify mismatch; else \c true.  If \c false, caller should check the
    /// state with FLAC__stream_encoder_get_state() for more information
    /// about the error.
    #[link_name = "\u{1}_FLAC__stream_encoder_finish"]
    pub fn FLAC__stream_encoder_finish(encoder: *mut FLAC__StreamEncoder) -> FLAC__bool;
}
extern "C" {
    /// Submit data for encoding.
    /// This version allows you to supply the input data via an array of
    /// pointers, each pointer pointing to an array of \a samples samples
    /// representing one channel.  The samples need not be block-aligned,
    /// but each channel should have the same number of samples.  Each sample
    /// should be a signed integer, right-justified to the resolution set by
    /// FLAC__stream_encoder_set_bits_per_sample().  For example, if the
    /// resolution is 16 bits per sample, the samples should all be in the
    /// range [-32768,32767].
    ///
    /// For applications where channel order is important, channels must
    /// follow the order as described in the
    /// <A HREF="../format.html#frame_header">frame header</A>.
    ///
    /// \param  encoder  An initialized encoder instance in the OK state.
    /// \param  buffer   An array of pointers to each channel's signal.
    /// \param  samples  The number of samples in one channel.
    /// \assert
    /// \code encoder != NULL \endcode
    /// \code FLAC__stream_encoder_get_state(encoder) == FLAC__STREAM_ENCODER_OK \endcode
    /// \retval FLAC__bool
    /// \c true if successful, else \c false; in this case, check the
    /// encoder state with FLAC__stream_encoder_get_state() to see what
    /// went wrong.
    #[link_name = "\u{1}_FLAC__stream_encoder_process"]
    pub fn FLAC__stream_encoder_process(
        encoder: *mut FLAC__StreamEncoder,
        buffer: *const *const FLAC__int32,
        samples: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    /// Submit data for encoding.
    /// This version allows you to supply the input data where the channels
    /// are interleaved into a single array (i.e. channel0_sample0,
    /// channel1_sample0, ... , channelN_sample0, channel0_sample1, ...).
    /// The samples need not be block-aligned but they must be
    /// sample-aligned, i.e. the first value should be channel0_sample0
    /// and the last value channelN_sampleM.  Each sample should be a signed
    /// integer, right-justified to the resolution set by
    /// FLAC__stream_encoder_set_bits_per_sample().  For example, if the
    /// resolution is 16 bits per sample, the samples should all be in the
    /// range [-32768,32767].
    ///
    /// For applications where channel order is important, channels must
    /// follow the order as described in the
    /// <A HREF="../format.html#frame_header">frame header</A>.
    ///
    /// \param  encoder  An initialized encoder instance in the OK state.
    /// \param  buffer   An array of channel-interleaved data (see above).
    /// \param  samples  The number of samples in one channel, the same as for
    /// FLAC__stream_encoder_process().  For example, if
    /// encoding two channels, \c 1000 \a samples corresponds
    /// to a \a buffer of 2000 values.
    /// \assert
    /// \code encoder != NULL \endcode
    /// \code FLAC__stream_encoder_get_state(encoder) == FLAC__STREAM_ENCODER_OK \endcode
    /// \retval FLAC__bool
    /// \c true if successful, else \c false; in this case, check the
    /// encoder state with FLAC__stream_encoder_get_state() to see what
    /// went wrong.
    #[link_name = "\u{1}_FLAC__stream_encoder_process_interleaved"]
    pub fn FLAC__stream_encoder_process_interleaved(
        encoder: *mut FLAC__StreamEncoder,
        buffer: *const FLAC__int32,
        samples: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
